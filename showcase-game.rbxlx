<roblox version="4">
  <Item class="ServerScriptService" referent="0">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Game</string>
      </Properties>
      <Item class="Folder" referent="2">
        <Properties>
          <string name="Name">game</string>
        </Properties>
        <Item class="Folder" referent="3">
          <Properties>
            <string name="Name">binders</string>
          </Properties>
          <Item class="Folder" referent="4">
            <Properties>
              <string name="Name">Client</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="5">
            <Properties>
              <string name="Name">Server</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="6">
            <Properties>
              <string name="Name">Shared</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="7">
          <Properties>
            <string name="Name">core</string>
          </Properties>
          <Item class="Folder" referent="8">
            <Properties>
              <string name="Name">Client</string>
            </Properties>
            <Item class="ModuleScript" referent="9">
              <Properties>
                <string name="Name">GameServiceClient</string>
                <string name="Source">--[=[
	@class GameServiceClient
]=]

local require = require(script.Parent.loader).load(script)

local _ServiceBag = require("ServiceBag")

local GameServiceClient = {}
GameServiceClient.ServiceName = "GameServiceClient"

function GameServiceClient:Init(serviceBag: _ServiceBag.ServiceBag)
	assert(not self._serviceBag, "Already initialized")
	self._serviceBag = assert(serviceBag, "No serviceBag")

	-- External
	self._serviceBag:GetService(require("CmdrServiceClient"))

	-- Internal
	self._serviceBag:GetService(require("GameTranslator"))

	self._serviceBag:GetService(require("TestClient"))
end

return GameServiceClient</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="10">
            <Properties>
              <string name="Name">Server</string>
            </Properties>
            <Item class="ModuleScript" referent="11">
              <Properties>
                <string name="Name">GameService</string>
                <string name="Source">--[=[
	@class GameService
]=]

local require = require(script.Parent.loader).load(script)

local _ServiceBag = require("ServiceBag")

local GameService = {}
GameService.ServiceName = "GameService"

function GameService:Init(serviceBag: _ServiceBag.ServiceBag)
	assert(not self._serviceBag, "Already initialized")
	self._serviceBag = assert(serviceBag, "No serviceBag")

	-- External
	self._serviceBag:GetService(require("CmdrService"))
	
	-- Internal
	self._serviceBag:GetService(require("GameTranslator"))

	self._serviceBag:GetService(require("TestService"))
end

return GameService</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="12">
            <Properties>
              <string name="Name">Shared</string>
            </Properties>
            <Item class="ModuleScript" referent="13">
              <Properties>
                <string name="Name">GameTranslator</string>
                <string name="Source">--[[
	@class GameTranslator
]]

local require = require(script.Parent.loader).load(script)

return require("JSONTranslator").new("GameTranslator", "en", {
	gameName = "Game";
})</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="14">
          <Properties>
            <string name="Name">test</string>
          </Properties>
          <Item class="Folder" referent="15">
            <Properties>
              <string name="Name">Client</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="16">
            <Properties>
              <string name="Name">Server</string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="17">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="18">
          <Properties>
            <string name="Name">@quenty</string>
          </Properties>
          <Item class="Folder" referent="19">
            <Properties>
              <string name="Name">acceltween</string>
            </Properties>
            <Item class="Folder" referent="20">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="21">
                <Properties>
                  <string name="Name">AccelTween</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Provides a means to, with both a continuous position and velocity,
	accelerate from its current position to a target position in minimum time
	given a maximum acceleration. See [Spring] for another version of this.

	Author: TreyReynolds/AxisAngles
	@class AccelTween
]=]

local AccelTween = {}

export type AccelTween = typeof(setmetatable(
	{} :: {
		--[=[
			Gets and sets the current position of the AccelTween
			@prop p number
			@within AccelTween
		]=]
		p: number,

		--[=[
			Gets and sets the current velocity of the AccelTween
			@prop v number
			@within AccelTween
		]=]
		v: number,

		--[=[
			Gets and sets the maximum acceleration.
			@prop a number
			@within AccelTween
		]=]
		a: number,

		--[=[
			Gets and sets the target position.
			@prop t number
			@within AccelTween
		]=]
		t: number,

		--[=[
			Returns the remaining time before the AccelTween attains the target.
			@readonly
			@prop rtime number
			@within AccelTween
		]=]
		rtime: number,

		--[=[
			Sets the current and target position, and sets the velocity to 0.
			@prop pt number
			@within AccelTween
		]=]
		pt: number,

		-- Internal
		_accel: number,
		_t0: number,
		_y0: number,
		_a0: number,
		_t1: number,
		_y1: number,
		_a1: number,
	},
	{ __index = AccelTween }
))

--[=[
	Constructs a new AccelTween.

	```lua
	local accelTween = AccelTween.new(30)
	accelTween.t = 1

	conn = RunService.RenderStepped:Connect(function()
		print(accelTween.p)
	end)
	task.delay(accelTween.rtime, function()
		conn:Disconnect()
	end)
	```

	@param maxaccel number? -- The maximum acceleration applied to reach its target. Defaults to 1
	@return AccelTween
]=]
function AccelTween.new(maxaccel: number?): AccelTween
	local self = setmetatable({
		_accel = maxaccel or 1,
		_t0 = 0,
		_y0 = 0,
		_a0 = 0,
		_t1 = 0,
		_y1 = 0,
		_a1 = 0,
	}, AccelTween)

	return self :: any
end

function AccelTween:__index(index)
	if AccelTween[index] then
		return AccelTween[index]
	elseif index == "p" then
		local pos, _ = self:_getState(os.clock())
		return pos
	elseif index == "v" then
		local _, vel = self:_getState(os.clock())
		return vel
	elseif index == "a" then
		return self._accel
	elseif index == "t" then
		return self._y1
	elseif index == "rtime" then
		local time = os.clock()
		return time < self._t1 and self._t1 - time or 0
	else
		error(string.format("Bad index %q", tostring(index)))
	end
end

function AccelTween:__newindex(index, value)
	if index == "p" then
		self:_setState(value, nil, nil, nil)
	elseif index == "v" then
		self:_setState(nil, value, nil, nil)
	elseif index == "a" then
		self:_setState(nil, nil, value, nil)
	elseif index == "t" then
		self:_setState(nil, nil, nil, value)
	elseif index == "pt" then
		self:_setState(value, 0, nil, value)
	else
		error(string.format("Bad index %q", tostring(index)))
	end
end

function AccelTween:_getState(time)
	if time < (self._t0 + self._t1) / 2 then
		local t = time - self._t0
		return self._y0 + t * t / 2 * self._a0, t * self._a0
	elseif time < self._t1 then
		local t = time - self._t1
		return self._y1 + t * t / 2 * self._a1, t * self._a1
	else
		return self._y1, 0
	end
end

function AccelTween:_setState(newpos, newvel, newaccel, newtarg)
	local time = os.clock()
	local pos, vel = self:_getState(time)
	pos = newpos or pos
	vel = newvel or vel
	self._accel = newaccel or self._accel
	local targ = newtarg or self._y1

	if self._accel * self._accel < 1e-8 then
		self._t0, self._y0, self._a0 = 0, pos, 0
		self._t1, self._y1, self._a1 = math.huge, targ, 0
	else
		local conda = targ < pos
		local condb = vel < 0
		local condc = pos - vel * vel / (2 * self._accel) < targ
		local condd = pos + vel * vel / (2 * self._accel) < targ
		if conda and condb and condc or not conda and (condb or not condb and condd) then
			self._a0 = self._accel
			self._t1 = time + ((2 * vel * vel + 4 * self._accel * (targ - pos)) ^ 0.5 - vel) / self._accel
		else
			self._a0 = -self._accel
			self._t1 = time + ((2 * vel * vel - 4 * self._accel * (targ - pos)) ^ 0.5 + vel) / self._accel
		end
		self._t0 = time - vel / self._a0
		self._y0 = pos - vel * vel / (2 * self._a0)
		self._y1 = targ
		self._a1 = -self._a0
	end
end

return AccelTween
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="22">
            <Properties>
              <string name="Name">attributeutils</string>
            </Properties>
            <Item class="Folder" referent="23">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="24">
                <Properties>
                  <string name="Name">AttributeUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Provides utility functions to work with attributes in Roblox
	@class AttributeUtils
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local CancelToken = require("CancelToken")
local Maid = require("Maid")
local Promise = require("Promise")

local DEFAULT_PREDICATE = function(value)
	return value ~= nil
end

local AttributeUtils = {}

type ValidAttributeMap = { [string]: true }

local VALID_ATTRIBUTE_TYPES: ValidAttributeMap = table.freeze({
	["nil"] = true,
	["string"] = true,
	["boolean"] = true,
	["number"] = true,
	["UDim"] = true,
	["UDim2"] = true,
	["BrickColor"] = true,
	["CFrame"] = true,
	["Color3"] = true,
	["Vector2"] = true,
	["Vector3"] = true,
	["NumberSequence"] = true,
	["ColorSequence"] = true,
	["IntValue"] = true,
	["NumberRange"] = true,
	["Rect"] = true,
	["Font"] = true,
	["EnumItem"] = true,
} :: ValidAttributeMap)

--[=[
	Returns whether the attribute is a valid type or not for an attribute.

	```lua
	print(AttributeUtils.isValidAttributeType(typeof("hi"))) --> true
	```

	@param valueType string
	@return boolean
]=]
function AttributeUtils.isValidAttributeType(valueType: string): boolean
	return VALID_ATTRIBUTE_TYPES[valueType] == true
end

--[=[
	Promises attribute value fits predicate

	@param instance Instance
	@param attributeName string
	@param predicate function | nil
	@param cancelToken CancelToken
	@return Promise<unknown>
]=]
function AttributeUtils.promiseAttribute(
	instance: Instance,
	attributeName: string,
	predicate,
	cancelToken: CancelToken.CancelToken?
): Promise.Promise<unknown>
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(attributeName) == "string", "Bad attributeName")
	assert(CancelToken.isCancelToken(cancelToken) or cancelToken == nil, "Bad cancelToken")

	predicate = predicate or DEFAULT_PREDICATE

	do
		local attributeValue = instance:GetAttribute(attributeName)
		if predicate(attributeValue) then
			return Promise.resolved(attributeValue)
		end
	end

	local promise = Promise.new()
	local maid = Maid.new()
	maid:GiveTask(promise)

	if cancelToken then
		maid:GiveTask(cancelToken.Cancelled:Connect(function()
			promise:Reject()
		end))
	end

	maid:GiveTask(instance:GetAttributeChangedSignal(attributeName):Connect(function()
		local attributeValue = instance:GetAttribute(attributeName)
		if predicate(attributeValue) then
			promise:Resolve(attributeValue)
		end
	end))

	promise:Finally(function()
		maid:DoCleaning()
	end)

	return promise
end

--[=[
	Whenever the attribute is true, the binder will be bound, and when the
	binder is bound, the attribute will be true.

	@param instance Instance
	@param attributeName string
	@param binder Binder<T>
	@return Maid
]=]
function AttributeUtils.bindToBinder(instance: Instance, attributeName: string, binder): Maid.Maid
	assert(binder, "Bad binder")
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(attributeName) == "string", "Bad attributeName")

	local maid = Maid.new()

	local function syncAttribute()
		if instance:GetAttribute(attributeName) then
			if RunService:IsClient() then
				binder:BindClient(instance)
			else
				binder:Bind(instance)
			end
		else
			if RunService:IsClient() then
				binder:UnbindClient(instance)
			else
				binder:Unbind(instance)
			end
		end
	end
	maid:GiveTask(instance:GetAttributeChangedSignal(attributeName):Connect(syncAttribute))

	local function syncBoundClass()
		if binder:Get(instance) then
			instance:SetAttribute(attributeName, true)
		else
			instance:SetAttribute(attributeName, false)
		end
	end
	maid:GiveTask(binder:ObserveInstance(instance, syncBoundClass))

	if binder:Get(instance) or instance:GetAttribute(attributeName) then
		instance:SetAttribute(attributeName, true)
		if RunService:IsClient() then
			binder:BindClient(instance)
		else
			binder:Bind(instance)
		end
	else
		instance:SetAttribute(attributeName, false)
		-- no need to bind
	end

	-- Depopuplate the attribute on exit
	maid:GiveTask(function()
		-- Force all cleaning first
		maid:DoCleaning()

		-- Cleanup
		instance:SetAttribute(attributeName, nil)
	end)

	return maid
end

--[=[
	Initializes an attribute for a given instance

	@param instance Instance
	@param attributeName string
	@param default any
	@return any? -- The value of the attribute
]=]
function AttributeUtils.initAttribute(instance: Instance, attributeName: string, default: any): any
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(typeof(attributeName) == "string", "Bad attributeName")

	local value = instance:GetAttribute(attributeName)
	if value == nil then
		instance:SetAttribute(attributeName, default)
		value = default
	end
	return value
end

--[=[
	Retrieves an attribute, and if it is nil, returns the default
	instead.
	@param instance Instance
	@param attributeName string
	@param default T?
	@return T?
]=]
function AttributeUtils.getAttribute(instance: Instance, attributeName: string, default: any): any
	local value = instance:GetAttribute(attributeName)
	if value == nil then
		return default
	end

	return value
end

--[=[
	Removes all attributes from an instance.

	@param instance Instance
]=]
function AttributeUtils.removeAllAttributes(instance: Instance)
	assert(typeof(instance) == "Instance", "Bad instance")

	for key, _ in instance:GetAttributes() do
		instance:SetAttribute(key, nil)
	end
end

return AttributeUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="25">
                <Properties>
                  <string name="Name">AttributeValue</string>
                  <string name="Source"><![CDATA[--[=[
	Allows access to an attribute like a ValueObject.

	```lua
	local attributeValue = AttributeValue.new(workspace, "Version", "1.0.0")
	print(attributeValue.Value) --> 1.0.0
	print(workspace:GetAttribute("version")) --> 1.0.0

	attributeValue.Changed:Connect(function()
		print(attributeValue.Value)
	end)

	workspace:SetAttribute("1.1.0") --> 1.1.0
	attributeValue.Value = "1.2.0" --> 1.2.0
	```

	@class AttributeValue
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Observable = require("Observable")
local Rx = require("Rx")
local RxAttributeUtils = require("RxAttributeUtils")

local AttributeValue = {}
AttributeValue.ClassName = "AttributeValue"
AttributeValue.__index = AttributeValue

export type AttributeValue<T> = typeof(setmetatable(
	{} :: {
		_object: Instance,
		_attributeName: string,
		_defaultValue: T,

		-- Public
		Value: T,
		AttributeName: string,
		Changed: RBXScriptSignal<(T)>,
	},
	{} :: typeof({ __index = AttributeValue })
))

--[=[
	Constructs a new AttributeValue. If a defaultValue that is not nil
	is defined, then this value will be set on the Roblox object.

	@param object Instance
	@param attributeName string
	@param defaultValue T
	@return AttributeValue<T>
]=]
function AttributeValue.new<T>(object: Instance, attributeName: string, defaultValue: T): AttributeValue<T>
	assert(typeof(object) == "Instance", "Bad object")
	assert(type(attributeName) == "string", "Bad attributeName")

	local self = {
		_object = object,
		_attributeName = attributeName,
		_defaultValue = defaultValue,
	}

	if defaultValue ~= nil and self._object:GetAttribute(self._attributeName) == nil then
		self._object:SetAttribute(rawget(self, "_attributeName"), defaultValue)
	end

	return setmetatable(self, AttributeValue) :: any
end

--[=[
	Handles observing the value conditionalli

	@param condition function | nil
	@return Observable<Brio<any>>
]=]
function AttributeValue.ObserveBrio<T>(
	self: AttributeValue<T>,
	condition: Rx.Predicate<T>?
): Observable.Observable<Brio.Brio<any>>
	return RxAttributeUtils.observeAttributeBrio(self._object, self._attributeName, condition)
end

--[=[
	Observes an attribute on an instance.
	@return Observable<any>
]=]
function AttributeValue.Observe<T>(self: AttributeValue<T>): Observable.Observable<T>
	return RxAttributeUtils.observeAttribute(self._object, self._attributeName, rawget(self :: any, "_defaultValue"))
end

--[=[
	The current property of the Attribute. Can be assigned to to write
	the attribute.
	@prop Value T
	@within AttributeValue
]=]

--[=[
	Signal that fires when the attribute changes
	@readonly
	@prop Changed Signal<()>
	@within AttributeValue
]=]
function AttributeValue.__index<T>(self: AttributeValue<T>, index)
	if AttributeValue[index] then
		return AttributeValue[index]
	elseif index == "Value" then
		local result = self._object:GetAttribute(rawget(self :: any, "_attributeName"))
		local default = rawget(self :: any, "_defaultValue")
		if result == nil then
			return default
		else
			return result
		end
	elseif index == "Changed" then
		return self._object:GetAttributeChangedSignal(self._attributeName)
	elseif index == "AttributeName" then
		return rawget(self :: any, "_attributeName")
	else
		error(string.format("%q is not a member of AttributeValue", tostring(index)))
	end
end

function AttributeValue.__newindex<T>(self: AttributeValue<T>, index, value)
	if index == "Value" then
		self._object:SetAttribute(rawget(self :: any, "_attributeName"), value)
	elseif index == "AttributeName" then
		error("Cannot set AttributeName")
	else
		error(string.format("%q is not a member of AttributeValue", tostring(index)))
	end
end

return AttributeValue
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="26">
                <Properties>
                  <string name="Name">EncodedAttributeValue</string>
                  <string name="Source"><![CDATA[--[=[
	Allows access to an attribute like a ValueObject, but also encoded or decoded

	@class EncodedAttributeValue
]=]

local require = require(script.Parent.loader).load(script)

local Rx = require("Rx")
local RxAttributeUtils = require("RxAttributeUtils")
local RxBrioUtils = require("RxBrioUtils")

local EncodedAttributeValue = {}
EncodedAttributeValue.ClassName = "EncodedAttributeValue"
EncodedAttributeValue.__index = EncodedAttributeValue

--[=[
	Constructs a new EncodedAttributeValue. If a defaultValue that is not nil
	is defined, then this value will be set on the Roblox object.

	@param object Instance
	@param attributeName string
	@param encode (TValue) -> T
	@param decode (T) -> TValue
	@param defaultValue T?
	@return EncodedAttributeValue<T, TValue>
]=]
function EncodedAttributeValue.new(object: Instance, attributeName: string, encode, decode, defaultValue)
	assert(typeof(object) == "Instance", "Bad object")
	assert(type(attributeName) == "string", "Bad attributeName")
	assert(type(decode) == "function", "Bad decode")
	assert(type(encode) == "function", "Bad encode")

	local self = {
		_object = object,
		_attributeName = attributeName,
		_decode = decode,
		_encode = encode,
	}

	if defaultValue ~= nil and self._object:GetAttribute(self._attributeName) == nil then
		self._object:SetAttribute(rawget(self, "_attributeName"), encode(defaultValue))
	end
	return setmetatable(self, EncodedAttributeValue)
end

--[=[
	Handles observing the value conditionalli

	@param condition function | nil
	@return Observable<Brio<any>>
]=]
function EncodedAttributeValue:ObserveBrio(condition)
	return RxAttributeUtils.observeAttributeBrio(self._object, self._attributeName, condition):Pipe({
		RxBrioUtils.map(rawget(self, "_decode")),
	})
end

--[=[
	Observes an attribute on an instance.
	@return Observable<any>
]=]
function EncodedAttributeValue:Observe()
	return RxAttributeUtils.observeAttribute(self._object, self._attributeName, rawget(self, "_defaultValue")):Pipe({
		Rx.map(rawget(self, "_decode")),
	})
end

--[=[
	The current property of the Attribute. Can be assigned to to write
	the attribute.
	@prop Value T
	@within EncodedAttributeValue
]=]

--[=[
	Signal that fires when the attribute changes
	@readonly
	@prop Changed Signal<()>
	@within EncodedAttributeValue
]=]
function EncodedAttributeValue:__index(index)
	if EncodedAttributeValue[index] then
		return EncodedAttributeValue[index]
	elseif index == "Value" then
		local result = self._object:GetAttribute(rawget(self, "_attributeName"))
		local default = rawget(self, "_defaultValue")
		if result == nil then
			return default
		else
			local decode = rawget(self, "_decode")
			return decode(result)
		end
	elseif index == "Changed" then
		return self._object:GetAttributeChangedSignal(self._attributeName)
	elseif index == "AttributeName" then
		return rawget(self, "_attributeName")
	else
		error(string.format("%q is not a member of EncodedAttributeValue", tostring(index)))
	end
end

function EncodedAttributeValue:__newindex(index, value)
	if index == "Value" then
		local encode = rawget(self, "_encode")
		self._object:SetAttribute(rawget(self, "_attributeName"), encode(value))
	else
		error(string.format("%q is not a member of EncodedAttributeValue", tostring(index)))
	end
end

return EncodedAttributeValue
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="27">
                <Properties>
                  <string name="Name">JSONAttributeValue</string>
                  <string name="Source"><![CDATA[--[=[
	@class JSONAttributeValue
]=]

local require = require(script.Parent.loader).load(script)

local HttpService = game:GetService("HttpService")
local BaseObject = require("BaseObject")
local EncodedAttributeValue = require("EncodedAttributeValue")

local JSONAttributeValue = setmetatable({}, BaseObject)
JSONAttributeValue.ClassName = "JSONAttributeValue"
JSONAttributeValue.__index = JSONAttributeValue

--[=[
	Constructs a new JSONAttributeValue
	@param object Instance
	@param attributeName string
	@param defaultValue any
	@return JSONAttributeValue
]=]
function JSONAttributeValue.new(object: Instance, attributeName: string, defaultValue: any)
	return EncodedAttributeValue.new(object, attributeName, function(value)
		if type(value) == "table" or type(value) == "string" then
			return HttpService:JSONEncode(value)
		else
			return nil
		end
	end, function(value)
		if type(value) == "string" then
			return HttpService:JSONDecode(value)
		else
			return nil
		end
	end, defaultValue)
end

return JSONAttributeValue
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="28">
                <Properties>
                  <string name="Name">RxAttributeUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions involving attributes.
	@class RxAttributeUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")
local Symbol = require("Symbol")

local UNSET_VALUE = Symbol.named("unsetValue")

local RxAttributeUtils = {}

--[=[
	Observes an attribute on an instance.
	@param instance Instance
	@param attributeName string
	@param defaultValue any?
	@return Observable<any>
]=]
function RxAttributeUtils.observeAttribute<T>(
	instance: Instance,
	attributeName: string,
	defaultValue: T?
): Observable.Observable<T>
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(attributeName) == "string", "Bad attributeName")

	return Observable.new(function(sub)
		local function handleAttributeChanged()
			local attributeValue = instance:GetAttribute(attributeName)
			if attributeValue == nil then
				sub:Fire(defaultValue)
			else
				sub:Fire(attributeValue)
			end
		end

		local connection = instance:GetAttributeChangedSignal(attributeName):Connect(handleAttributeChanged)
		handleAttributeChanged()

		return connection
	end) :: any
end

--[=[
	Observes all the attribute keys that
	@param instance Instance
	@return Observable<Brio<string>>
]=]
function RxAttributeUtils.observeAttributeKeysBrio(instance: Instance): Observable.Observable<Brio.Brio<string>>
	assert(typeof(instance) == "Instance", "Bad instance")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local attributeNameToBrio: { [string]: any } = {}

		local function handleAttributeChanged(attributeName: string, attributeValue: any)
			if attributeValue == nil then
				local brio = attributeNameToBrio[attributeName]
				if brio then
					attributeNameToBrio[attributeName] = nil
					maid[brio] = nil
				end
			else
				if not attributeNameToBrio[attributeName] then
					local brio: any = Brio.new(attributeName)
					attributeNameToBrio[attributeName] = brio
					maid[brio] = brio
					sub:Fire(brio)
				end
			end
		end

		maid:GiveTask(instance.AttributeChanged:Connect(function(attributeName)
			handleAttributeChanged(attributeName, instance:GetAttribute(attributeName))
		end))

		for attributeName, attributeValue in pairs(instance:GetAttributes()) do
			if not sub:IsPending() then
				break
			end

			-- TODO: Maybe we technically need to requery here but it's expensive
			handleAttributeChanged(attributeName, attributeValue)
		end

		return maid
	end) :: any
end

--[=[
	Observes all the attribute keys for an instance

	@param instance Instance
	@return Observable<string>
]=]
function RxAttributeUtils.observeAttributeKeys(instance: Instance): Observable.Observable<string>
	assert(typeof(instance) == "Instance", "Bad instance")

	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(instance.AttributeChanged:Connect(function(attribute)
			sub:Fire(attribute)
		end))

		for attribute, _ in pairs(instance:GetAttributes()) do
			if not sub:IsPending() then
				break
			end

			sub:Fire(attribute)
		end

		return maid
	end) :: any
end

--[=[
	Observes an attribute on an instance with a conditional statement.
	@param instance Instance
	@param attributeName string
	@param condition function | nil
	@return Observable<Brio<any>>
]=]
function RxAttributeUtils.observeAttributeBrio<T>(
	instance: Instance,
	attributeName: string,
	condition: Rx.Predicate<T>?
): Observable.Observable<Brio.Brio<T>>
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(attributeName) == "string", "Bad attributeName")

	return Observable.new(function(sub)
		local maid = Maid.new()
		local lastValue = UNSET_VALUE

		local function handleAttributeChanged()
			local attributeValue = instance:GetAttribute(attributeName)

			-- Deferred events can cause multiple values to be queued at once
			-- but we operate at this post-deferred layer, so lets only output
			-- reflected values.
			if lastValue ~= attributeValue then
				lastValue = attributeValue

				if not condition or condition(attributeValue :: T) then
					local brio = Brio.new(attributeValue)
					maid._lastBrio = brio

					-- The above line can cause us to be overwritten so make sure before firing.
					if maid._lastBrio == brio then
						sub:Fire(brio)
					end
				else
					maid._lastBrio = nil
				end
			end
		end

		maid:GiveTask(instance:GetAttributeChangedSignal(attributeName):Connect(handleAttributeChanged))
		handleAttributeChanged()

		return maid
	end) :: any
end

return RxAttributeUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="29">
            <Properties>
              <string name="Name">baseobject</string>
            </Properties>
            <Item class="Folder" referent="30">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="31">
                <Properties>
                  <string name="Name">BaseObject</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	A BaseObject basically just adds the :Destroy() interface, and a _maid, along with an optional object it references.
	@class BaseObject
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")

local BaseObject = {}
BaseObject.ClassName = "BaseObject"
BaseObject.__index = BaseObject

export type BaseObject = typeof(setmetatable(
	{} :: {
		_obj: Instance?,
		_maid: Maid.Maid,
	},
	{} :: typeof({ __index = BaseObject })
))

--[=[
	Constructs a new BaseObject

	@param obj? Instance
	@return BaseObject
]=]
function BaseObject.new(obj: Instance?): BaseObject
	return setmetatable({
		_maid = Maid.new(),
		_obj = obj,
	}, BaseObject)
end

--[=[
	Cleans up the BaseObject and sets the metatable to nil
]=]
function BaseObject.Destroy(self: BaseObject): ()
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return BaseObject
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="32">
            <Properties>
              <string name="Name">binder</string>
            </Properties>
            <Item class="Folder" referent="33">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="34">
                <Properties>
                  <string name="Name">Binder</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Bind class to Roblox Instance

	```lua
	-- Setup a class!
	local MyClass = {}
	MyClass.__index = MyClass

	function MyClass.new(robloxInstance)
		print("New tagged instance of ", robloxInstance)
		return setmetatable({}, MyClass)
	end

	function MyClass:Destroy()
		print("Cleaning up")
		setmetatable(self, nil)
	end

	-- bind to every instance with tag of "TagName"!
	local binder = Binder.new("TagName", MyClass)
	binder:Start() -- listens for new instances and connects events
	```

	@class Binder
]=]

local require = require(script.Parent.loader).load(script)

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

local Brio = require("Brio")
local CancelToken = require("CancelToken")
local Maid = require("Maid")
local MaidTaskUtils = require("MaidTaskUtils")
local Observable = require("Observable")
local Promise = require("Promise")
local Signal = require("Signal")

local Binder = {}
Binder.__index = Binder
Binder.ClassName = "Binder"

export type ConstructorCallback<T> = (Instance) -> T

export type ClassDefinition<T> = {
	new: ConstructorCallback<T>,
}

export type ProviderDefition<T> = {
	Create: ConstructorCallback<T>,
}

export type BinderConstructor<T> = ClassDefinition<T> | ProviderDefition<T> | ConstructorCallback<T>

export type Binder<T> = typeof(setmetatable(
	{} :: {
		ServiceName: string,

		_tagName: string,
		_defaultClassType: string,
		_args: { any },
		_constructor: BinderConstructor<T>,

		_started: boolean,
		_initialized: boolean,
		_pendingInstSet: { [Instance]: true },
		_instToClass: { [Instance]: T },
		_allClassSet: { [T]: true },
		_maid: Maid.Maid,
		_listeners: { [Instance]: { [any]: true } },
		_classAddedSignal: Signal.Signal<T, Instance>?,
		_classRemovingSignal: Signal.Signal<T, Instance>?,
		_classRemovedSignal: Signal.Signal<T, Instance>?,
	},
	{} :: typeof({ __index = Binder })
))

--[=[
	Constructor for a binder
	@type BinderContructor (Instance, ...: any) -> T | { new: (Instance, ...: any) } | { Create(self, Instance, ...: any) }
	@within Binder
]=]

--[=[
	Constructs a new binder object.

	```lua
	local binder = Binder.new("Bird", function(inst)
		print("Wow, a new bird!", inst)

		return {
			Destroy = function()
				print("Uh oh, the bird is gone!")
			end;
		}
	end)
	binder:Start()
	```
	@param tagName string -- Name of the tag to bind to. This uses CollectionService's tag system
	@param constructor BinderContructor
	@param ... any -- Variable arguments that will be passed into the constructor
	@return Binder<T>
]=]
function Binder.new<T>(tagName: string, constructor: BinderConstructor<T>, ...): Binder<T>
	assert(type(tagName) == "string", "Bad tagName")

	local self: Binder<T> = setmetatable({} :: any, Binder)

	self._tagName = assert(tagName, "Bad argument 'tagName', expected string")
	self._constructor = assert(constructor, "Bad argument 'constructor', expected table or function")
	self._defaultClassType = "Folder"
	self.ServiceName = self._tagName .. "Binder"

	if Binder.isBinder(self._constructor) then
		error("Cannot make a binder that constructs another binder")
	end

	if select("#", ...) > 0 then
		self._args = { ... }
	end

	return self
end

--[=[
	Retrieves whether or not the given value is a binder.

	@param value any
	@return boolean true or false, whether or not it is a value
]=]
function Binder.isBinder(value: any): boolean
	return type(value) == "table"
		and type(value.Start) == "function"
		and type(value.GetTag) == "function"
		and type(value.GetConstructor) == "function"
		and type(value.ObserveInstance) == "function"
		and type(value.GetClassAddedSignal) == "function"
		and type(value.GetClassRemovingSignal) == "function"
		and type(value.GetClassRemovedSignal) == "function"
		and type(value.GetAll) == "function"
		and type(value.GetAllSet) == "function"
		and type(value.Bind) == "function"
		and type(value.Unbind) == "function"
		and type(value.BindClient) == "function"
		and type(value.UnbindClient) == "function"
		and type(value.Get) == "function"
		and type(value.Promise) == "function"
		and type(value.Destroy) == "function"
end

--[=[
	Initializes the Binder. Designed to be done via ServiceBag.

	@param ... any
]=]
function Binder:Init(...)
	if self._initialized then
		return
	end

	self._initialized = true
	self._maid = Maid.new()

	self._instToClass = {} -- [inst] = class
	self._allClassSet = {} -- [class] = true
	self._pendingInstSet = {} -- [inst] = true

	self._listeners = {} -- [inst] = callback

	if select("#", ...) > 0 then
		if not self._args then
			self._args = { ... }
		elseif not self:_argsMatch(...) then
			warn("[Binder.Init] - Non-matching args from :Init() and .new()")
		end
	elseif not self._args then
		-- Binder.new() would have captured args if we had them
		self._args = {}
	end

	self._maid._warning = task.delay(5, function()
		warn(string.format("Binder %q is not loaded. Call :Start() on it!", self._tagName))
	end)
end

function Binder:_argsMatch(...)
	if #self._args ~= select("#", ...) then
		return false
	end

	for index, value in { ... } do
		if self._args[index] ~= value then
			return false
		end
	end

	return true
end

--[=[
	Listens for new instances and connects to the GetInstanceAddedSignal() and removed signal!
]=]
function Binder.Start<T>(self: Binder<T>)
	if not self._initialized then
		self:Init()
	end

	if self._started then
		return
	end
	self._maid._warning = nil
	self._started = true

	for _, inst in CollectionService:GetTagged(self._tagName) do
		task.spawn(self._add, self, inst)
	end

	self._maid:GiveTask(CollectionService:GetInstanceAddedSignal(self._tagName):Connect(function(inst)
		self:_add(inst)
	end))
	self._maid:GiveTask(CollectionService:GetInstanceRemovedSignal(self._tagName):Connect(function(inst)
		self:_remove(inst)
	end))
end

--[=[
	Returns the tag name that the binder has.
	@return string
]=]
function Binder.GetTag<T>(self: Binder<T>): string
	return self._tagName
end

--[=[
	Returns whatever was set for the construtor. Used for meta-analysis of
	the binder, such as extracting if parameters are allowed.

	@return BinderContructor
]=]
function Binder.GetConstructor<T>(self: Binder<T>): BinderConstructor<T>
	return self._constructor
end

--[=[
	Observes the current value of the instance

	@param instance Instance
	@return Observable<T?>
]=]
function Binder:Observe(instance: Instance)
	assert(typeof(instance) == "Instance", "Bad instance")

	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(self:ObserveInstance(instance, function(...)
			sub:Fire(...)
		end))
		sub:Fire(self:Get(instance))

		return maid
	end)
end

--[=[
	Observes all entries in the binder

	@return Observable<Brio<T>>
]=]
function Binder.ObserveAllBrio<T>(self: Binder<T>): Observable.Observable<Brio.Brio<T>>
	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleNewClass(class: T)
			local brio = Brio.new(class)
			maid[class :: any] = brio

			sub:Fire(brio)
		end

		maid:GiveTask(self:GetClassAddedSignal():Connect(handleNewClass))

		for _, item in self:GetAll() do
			if not sub:IsPending() then
				break
			end

			handleNewClass(item)
		end

		if sub:IsPending() then
			maid:GiveTask(self:GetClassRemovingSignal():Connect(function(class)
				maid[class :: any] = nil
			end))
		end

		return maid
	end) :: any
end

--[=[
	Observes a bound class on a given instance.

	@param instance Instance
	@return Observable<Brio<T>>
]=]
function Binder.ObserveBrio<T>(self: Binder<T>, instance: Instance): Observable.Observable<Brio.Brio<T>>
	assert(typeof(instance) == "Instance", "Bad instance")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleClassChanged(class)
			if class then
				local brio = Brio.new(class)
				maid._lastBrio = brio

				sub:Fire(brio)
			else
				maid._lastBrio = nil
			end
		end

		maid:GiveTask(self:ObserveInstance(instance, handleClassChanged))
		handleClassChanged(self:Get(instance))

		return maid
	end) :: any
end

--[=[
	Fired when added, and then after removal, but before destroy!

	:::info
	This is before [Rx] so it doesn't follow the same Rx pattern. See [Binder.Observe] for
	an [Rx] compatible interface.
	:::

	@param inst Instance
	@param callback function
	@return function -- Cleanup function
]=]
function Binder.ObserveInstance<T>(self: Binder<T>, inst: Instance, callback: (T?) -> ()): () -> ()
	assert(typeof(inst) == "Instance", "Bad inst")
	assert(type(callback) == "function", "Bad callback")

	self._listeners[inst] = self._listeners[inst] or {}
	self._listeners[inst][callback] = true

	return function()
		if not self._listeners[inst] then
			return
		end

		self._listeners[inst][callback] = nil
		if not next(self._listeners[inst]) then
			self._listeners[inst] = nil
		end
	end
end

--[=[
	Returns a new signal that will fire whenever a class is bound to the binder

	```lua
	local birdBinder = Binder.new("Bird", require("Bird")) -- Load bird into binder

	birdBinder:GetClassAddedSignal():Connect(function(bird)
		bird:Squack() -- Make the bird squack when it's first spawned
	end)

	-- Load all birds
	birdBinder:Start()
	```

	@return Signal<T>
]=]
function Binder.GetClassAddedSignal<T>(self: Binder<T>): Signal.Signal<T, Instance>
	if self._classAddedSignal then
		return self._classAddedSignal
	end

	self._classAddedSignal = self._maid:Add(Signal.new() :: any) -- :fire(class, inst)

	return self._classAddedSignal :: any
end

--[=[
	Returns a new signal that will fire whenever a class is removing from the binder.

	@return Signal<T>
	]=]
function Binder.GetClassRemovingSignal<T>(self: Binder<T>): Signal.Signal<T, Instance>
	if self._classRemovingSignal then
		return self._classRemovingSignal
	end

	self._classRemovingSignal = self._maid:Add(Signal.new() :: any) -- :fire(class, inst)

	return self._classRemovingSignal :: any
end

--[=[
	Returns a new signal that will fire whenever a class is removed from the binder.

	@return Signal<T>
]=]
function Binder.GetClassRemovedSignal<T>(self: Binder<T>): Signal.Signal<T, Instance>
	if self._classRemovedSignal then
		return self._classRemovedSignal
	end

	self._classRemovedSignal = self._maid:Add(Signal.new() :: any) -- :fire(class, inst)

	return self._classRemovedSignal :: any
end

--[=[
	Returns all of the classes in a new table.

	```lua
	local birdBinder = Binder.new("Bird", require("Bird")) -- Load bird into binder

	-- Update every bird every frame
	RunService.Stepped:Connect(function()
		for _, bird in birdBinder:GetAll() do
			bird:Update()
		end
	end)

	birdBinder:Start()
	```

	@return {T}
]=]
function Binder.GetAll<T>(self: Binder<T>): { T }
	local all = {}
	for class, _ in self._allClassSet do
		all[#all + 1] = class
	end
	return all
end

--[=[
	Faster method to get all items in a binder

	```lua
	local birdBinder = Binder.new("Bird", require("Bird")) -- Load bird into binder

	-- Update every bird every frame
	RunService.Stepped:Connect(function()
		for bird, _ in pairs(birdBinder:GetAllSet()) do
			bird:Update()
		end
	end)

	birdBinder:Start()
	```

	:::warning
	Do not mutate this set directly
	:::

	@return { [T]: true }
]=]
function Binder.GetAllSet<T>(self: Binder<T>): { [T]: true }
	return self._allClassSet
end

--[=[
	Binds an instance to this binder using collection service and attempts
	to return it if it's bound properly. See BinderUtils.promiseBoundClass() for a safe
	way to retrieve it.

	:::warning
	Do not assume that a bound object will be retrieved
	:::

	@server
	@param inst Instance -- Instance to check
	@return T? -- Bound class
]=]
function Binder.Bind<T>(self: Binder<T>, inst: Instance): T?
	if RunService:IsClient() then
		warn(
			string.format(
				"[Binder.Bind] - Bindings '%s' done on the client! Will be disrupted upon server replication! %s",
				self._tagName,
				debug.traceback()
			)
		)
	end

	CollectionService:AddTag(inst, self._tagName)
	return self:Get(inst)
end

--[=[
	Tags the instance with the tag for the binder

	@param inst Instance
]=]
function Binder.Tag<T>(self: Binder<T>, inst: Instance)
	assert(typeof(inst) == "Instance", "Bad inst")

	CollectionService:AddTag(inst, self._tagName)
end

--[=[
	Returns true if the instance has a tag

	@param inst Instance
]=]
function Binder.HasTag<T>(self: Binder<T>, inst: Instance): boolean
	assert(typeof(inst) == "Instance", "Bad inst")

	return CollectionService:HasTag(inst, self._tagName)
end

--[=[
	Untags the instance with the tag for the binder

	@param inst Instance
]=]
function Binder.Untag<T>(self: Binder<T>, inst: Instance)
	assert(typeof(inst) == "Instance", "Bad inst")

	CollectionService:RemoveTag(inst, self._tagName)
end

--[=[
	Unbinds the instance by removing the tag.

	@server
	@param inst Instance -- Instance to unbind
]=]
function Binder.Unbind<T>(self: Binder<T>, inst: Instance)
	assert(typeof(inst) == "Instance", "Bad inst'")

	if RunService:IsClient() then
		warn(
			string.format(
				"[Binder.Bind] - Unbinding '%s' done on the client! Might be disrupted upon server replication! %s",
				self._tagName,
				debug.traceback()
			)
		)
	end

	CollectionService:RemoveTag(inst, self._tagName)
end

--[=[
 See :Bind(). Acknowledges the risk of doing this on the client.

 Using this acknowledges that we're intentionally binding on a safe client object,
 i.e. one without replication. If another tag is changed on this instance, this tag will be lost/changed.

 @client
 @param inst Instance -- Instance to bind
 @return T? -- Bound class (potentially)
]=]
function Binder.BindClient<T>(self: Binder<T>, inst: Instance)
	if not RunService:IsClient() then
		warn(
			string.format("[Binder.BindClient] - Bindings '%s' done on the server! Will be replicated!", self._tagName)
		)
	end

	CollectionService:AddTag(inst, self._tagName)
	return self:Get(inst)
end

--[=[
	See Unbind(), acknowledges risk of doing this on the client.

	@client
	@param inst Instance -- Instance to unbind
]=]
function Binder.UnbindClient<T>(self: Binder<T>, inst: Instance)
	assert(typeof(inst) == "Instance", "Bad inst")
	CollectionService:RemoveTag(inst, self._tagName)
end

--[=[
	Returns a instance of the class that is bound to the instance given.

	@param inst Instance -- Instance to check
	@return T?
]=]
function Binder.Get<T>(self: Binder<T>, inst: Instance): T?
	assert(typeof(inst) == "Instance", "Argument 'inst' is not an Instance")
	return self._instToClass[inst]
end

--[=[
	Returns a promise which will resolve when the instance is bound.

	@param inst Instance -- Instance to check
	@param cancelToken CancelToken?
	@return Promise<T>
]=]
function Binder.Promise<T>(self: Binder<T>, inst: Instance, cancelToken: CancelToken.CancelToken?): Promise.Promise<T>
	assert(typeof(inst) == "Instance", "Argument 'inst' is not an Instance")

	local class = self:Get(inst)
	if class then
		return Promise.resolved(class)
	end

	local maid = Maid.new()
	local promise = Promise.new()

	if cancelToken then
		cancelToken:ErrorIfCancelled()
		maid:GivePromise(cancelToken.PromiseCancelled):Then(function()
			promise:Reject()
		end)
	end

	maid:GiveTask(self:ObserveInstance(inst, function(classAdded)
		if classAdded then
			promise:Resolve(classAdded)
		end
	end))

	task.delay(5, function()
		if promise:IsPending() then
			warn(
				string.format(
					"[promiseBoundClass] - Infinite yield possible on %q for binder %q\n",
					inst:GetFullName(),
					self:GetTag()
				)
			)
		end
	end)

	promise:Finally(function()
		maid:Destroy()
	end)

	return promise
end

--[=[
	Creates a new class tagged with this binder's instance

	@param className string?
	@return Instance
]=]
function Binder.Create<T>(self: Binder<T>, className: string): Instance
	assert(type(className) == "string" or className == nil, "Bad className")

	local instance = Instance.new(className or self._defaultClassType)
	instance.Name = self._tagName
	instance.Archivable = false

	self:Tag(instance)

	return instance
end

function Binder._add<T>(self: Binder<T>, inst: Instance)
	assert(typeof(inst) == "Instance", "Argument 'inst' is not an Instance")

	if self._instToClass[inst] then
		-- https://devforum.roblox.com/t/double-firing-of-collectionservice-getinstanceaddedsignal-when-applying-tag/244235
		return
	end

	if self._pendingInstSet[inst] == true then
		warn("[Binder._add] - Reentered add. Still loading, probably caused by error in constructor.")
		return
	end

	self._pendingInstSet[inst] = true

	local constructor: any = self._constructor
	local class: T
	if type(constructor) == "function" then
		class = constructor(inst, unpack(self._args))
	elseif constructor.Create then
		class = constructor:Create(inst, unpack(self._args))
	else
		class = constructor.new(inst, unpack(self._args))
	end

	if self._pendingInstSet[inst] ~= true then
		-- Got GCed in the process of loading?!
		-- Constructor probably yields. Yikes.
		warn(
			string.format(
				"[Binder._add] - Failed to load instance %q of %q, removed while loading!",
				inst:GetFullName(),
				tostring(type(constructor) == "table" and constructor.ClassName or constructor)
			)
		)
		return
	end

	self._pendingInstSet[inst] = nil
	assert(self._instToClass[inst] == nil, "Overwrote")

	class = class or {} :: any

	-- Add to state
	self._allClassSet[class] = true
	self._instToClass[inst] = class

	-- Fire events
	local listeners = self._listeners[inst]
	if listeners then
		for callback, _ in listeners do
			task.spawn(callback, class)
		end
	end

	if self._classAddedSignal then
		self._classAddedSignal:Fire(class, inst)
	end
end

function Binder._remove<T>(self: Binder<T>, inst: Instance)
	self._pendingInstSet[inst] = nil

	local class = self._instToClass[inst]
	if class == nil then
		return
	end

	-- Fire off events
	if self._classRemovingSignal then
		self._classRemovingSignal:Fire(class, inst)
	end

	-- Clean up state
	self._instToClass[inst] = nil
	self._allClassSet[class] = nil

	-- Fire listener here
	local listeners = self._listeners[inst]
	if listeners then
		for callback, _ in listeners do
			task.spawn(callback, nil)
		end
	end

	if MaidTaskUtils.isValidTask(class) then
		MaidTaskUtils.doTask(class)
	end

	-- Fire off events
	if self._classRemovedSignal then
		self._classRemovedSignal:Fire(class, inst)
	end
end

--[=[
	Cleans up all bound classes, and disconnects all events.
]=]
function Binder.Destroy<T>(self: Binder<T>)
	local inst, class = next(self._instToClass)
	while class ~= nil and inst ~= nil do
		task.spawn(self._remove, self, inst)
		inst, class = next(self._instToClass)
	end

	-- Disconnect events
	self._maid:DoCleaning()
end

return Binder
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="35">
                <Properties>
                  <string name="Name">BinderGroup</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Groups binders together into a list, and allows binders to be dynamically
	added or removed.

	Also allows their interface to be validated using a validation function.
	This ensures that all added objects are the same type, so they can be used
	for dynamic interactions.

	@class BinderGroup
]=]

local require = require(script.Parent.loader).load(script)

local Binder = require("Binder")
local Signal = require("Signal")

local BinderGroup = {}
BinderGroup.ClassName = "BinderGroup"
BinderGroup.__index = BinderGroup

export type BinderConstructorValidator = (constructor: Binder.BinderConstructor<any>) -> boolean

export type BinderGroup = typeof(setmetatable(
	{} :: {
		_binders: { Binder.Binder<any> },
		_bindersByTag: { [string]: Binder.Binder<any> },
		_validateConstructor: BinderConstructorValidator?,
		BinderAdded: Signal.Signal<Binder.Binder<any>>,
	},
	{} :: typeof({ __index = BinderGroup })
))
--[=[
	Constructs a new BinderGroup

	@param binders { Binder<T> } -- A list of binders that
	@param validateConstructor (constructor: any) -> boolean -- Validates a binder matches T
	@return BinderGroup<T>
]=]
function BinderGroup.new(binders: { Binder.Binder<any> }, validateConstructor: BinderConstructorValidator?): BinderGroup
	local self: BinderGroup = setmetatable({} :: any, BinderGroup)

	self._binders = {}
	self._bindersByTag = {}
	self._validateConstructor = validateConstructor

	self.BinderAdded = Signal.new() :: any

	self:AddList(binders)

	return self
end

--[=[
	Adds a list of binders to the group.

	@param binders { Binder<T> }
]=]
function BinderGroup.AddList(self: BinderGroup, binders: { Binder.Binder<any> })
	assert(type(binders) == "table", "Bad binders")

	-- Assume to be using osyris's typechecking library,
	-- we have an optional constructor to validate binder classes.
	for _, binder in binders do
		self:Add(binder :: any)
	end
end

--[=[
	Adds the specific binder to the list

	@param binder Binder<T>
]=]
function BinderGroup.Add(self: BinderGroup, binder: Binder.Binder<any>)
	assert(Binder.isBinder(binder), "Binder is not a binder")

	if self._validateConstructor then
		assert(self._validateConstructor(binder:GetConstructor()))
	end

	local tag = binder:GetTag()
	if self._bindersByTag[tag] then
		warn("[BinderGroup.Add] - Binder with tag %q already added. Adding again.")
	end

	self._bindersByTag[tag] = binder
	table.insert(self._binders, binder)

	self.BinderAdded:Fire(binder)
end

--[=[
	Returns a list of binders.

	:::warning
	Do not modify the list of binders returned here
	:::

	@return { Binder.Binder<any> }
]=]
function BinderGroup.GetBinders(self: BinderGroup): { Binder.Binder<any> }
	assert(self._binders, "No self._binders")

	return self._binders
end

return BinderGroup
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="36">
                <Properties>
                  <string name="Name">BinderGroupProvider</string>
                  <string name="Source"><![CDATA[--[=[
	Provides a basis for binderGroups that can be retrieved anywhere
	@class BinderGroupProvider
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

local BinderGroupProvider = {}
BinderGroupProvider.ClassName = "BinderGroupProvider"
BinderGroupProvider.ServiceName = "BinderGroupProvider"
BinderGroupProvider.__index = BinderGroupProvider

--[=[
	Constructs a new BinderGroupProvider
	@param initMethod (BinderGroupProvider) -> ()
	@return BinderGroupProvider
]=]
function BinderGroupProvider.new(initMethod)
	local self = setmetatable({}, BinderGroupProvider)

	self._initMethod = initMethod or error("No initMethod")
	self._groupsAddedPromise = Promise.new()

	self._init = false
	self._binderGroups = {}

	return self
end

--[=[
	Returns a promise that will resolve once groups are added.
	@return Promise
]=]
function BinderGroupProvider:PromiseGroupsAdded()
	return self._groupsAddedPromise
end

--[=[
	Starts the binder provider. Should be called via ServiceBag.
	@param ... ServiceBag | any
]=]
function BinderGroupProvider:Init(...)
	assert(not self._init, "Already initialized")

	self._initMethod(self, ...)
	self._init = true

	self._groupsAddedPromise:Resolve()
end

--[=[
	Starts the binder provider. Should be called via ServiceBag.
]=]
function BinderGroupProvider:Start()
	-- Do nothing
end

function BinderGroupProvider:__index(index)
	if BinderGroupProvider[index] then
		return BinderGroupProvider[index]
	end

	error(string.format("%q Not a valid index", tostring(index)))
end

--[=[
	Returns a binder group given the binderName

	@param groupName string
	@return BinderGroup?
]=]
function BinderGroupProvider:Get(groupName: string)
	assert(type(groupName) == "string", "Bad groupName")
	return rawget(self, groupName)
end

--[=[
	Adds a new group at the given name

	@param groupName string
	@param binderGroup BinderGroup
]=]
function BinderGroupProvider:Add(groupName, binderGroup)
	assert(type(groupName) == "string", "Bad groupName")
	assert(type(binderGroup) == "table", "Bad binderGroup")
	assert(not self._init, "Already initialized")
	assert(not self:Get(groupName), "Duplicate groupName")

	table.insert(self._binderGroups, binderGroup)
	self[groupName] = binderGroup
end

function BinderGroupProvider:Destroy()
	-- Do nothing
end

return BinderGroupProvider
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="37">
                <Properties>
                  <string name="Name">BinderProvider</string>
                  <string name="Source"><![CDATA[--[=[
	Provides a basis for binders that can be retrieved anywhere
	@class BinderProvider
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Promise = require("Promise")

local BinderProvider = {}
BinderProvider.ClassName = "BinderProvider"
BinderProvider.ServiceName = "BinderProvider"
BinderProvider.__index = BinderProvider

--[=[
	Constructs a new BinderProvider.

	:::tip
	Don't use this! You can retrieve binders from the service bag directly
	:::

	```lua
	local serviceBag = ServiceBag.new()

	-- Usually in a separate file!
	local binderProvider = BinderProvider.new("BirdBinders", function(self, serviceBag)
		self:Add(Binder.new("Bird", require("Bird"), serviceBag))
	end)

	-- Retrieve binders
	local binders = serviceBag:GetService(binderProvider)

	-- Runs the game (including binders)
	serviceBag:Init()
	serviceBag:Start()
	```

	@param serviceName string -- Name of the service (used for memory tracking)
	@param initMethod (self, serviceBag: ServiceBag)
	@return BinderProvider
]=]
function BinderProvider.new(serviceName: string, initMethod)
	local self = setmetatable({}, BinderProvider)

	if type(serviceName) == "string" then
		self.ServiceName = serviceName
	else
		-- Backwords compatibility (for now)
		if type(serviceName) == "function" and initMethod == nil then
			warn(
				"[BinderProvider] - Missing serviceName for binder provider. Please pass in a service name as the first argument."
			)
			initMethod = serviceName
		else
			error("Bad serviceName")
		end
	end

	self._initMethod = initMethod or error("No initMethod")
	self._initialized = false
	self._destroyed = false
	self._started = false

	return self
end

--[=[
	Retrieves whether or not its a binder provider
	@param value any
	@return boolean -- True if it is a binder provider
]=]
function BinderProvider.isBinderProvider(value: any): boolean
	return type(value) == "table" and value.ClassName == "BinderProvider"
end

--[=[
	Resolves to the given binder given the binderName.

	@param binderName string
	@return Promise<Binder<T>>
]=]
function BinderProvider:PromiseBinder(binderName)
	if self._bindersAddedPromise:IsFulfilled() then
		local binder = self:Get(binderName)
		if binder then
			return Promise.resolved(binder)
		else
			return Promise.rejected()
		end
	end

	return self._bindersAddedPromise:Then(function()
		local binder = self:Get(binderName)
		if binder then
			return binder
		else
			return Promise.rejected()
		end
	end)
end

--[=[
	Initializes itself and all binders

	@param ... ServiceBag | any
]=]
function BinderProvider:Init(...)
	assert(not self._initialized, "Already initialized")

	self._maid = Maid.new()

	self._binders = {}
	self._initialized = true

	-- Pretty sure this is a bad idea
	self._bindersAddedPromise = self._maid:Add(Promise.new())
	self._startPromise = self._maid:Add(Promise.new())

	self._initMethod(self, ...)

	for _, binder in self._binders do
		binder:Init(...)
	end

	self._bindersAddedPromise:Resolve()
end

--[=[
	Returns a promise that will resolve once all binders are added.

	@return Promise
]=]
function BinderProvider:PromiseBindersAdded()
	return assert(self._bindersAddedPromise, "Be sure to require via serviceBag")
end

--[=[
	Returns a promise that will resolve once all binders are started.

	@return Promise
]=]
function BinderProvider:PromiseBindersStarted()
	return assert(self._startPromise, "Be sure to require via serviceBag")
end

--[=[
	Starts all of the binders.
]=]
function BinderProvider:Start()
	assert(self._initialized, "Not initialized")
	assert(not self._started, "Already started")

	self._started = true
	for _, binder in self._binders do
		binder:Start()
	end

	self._startPromise:Resolve()
end

function BinderProvider:__index(index)
	if BinderProvider[index] then
		return BinderProvider[index]
	end

	if rawget(self, "_destroyed") then
		error(string.format("BinderProvider is destroyed. Cannot index %q", tostring(index)))
	end

	error(string.format("%q Not a valid binder", tostring(index)))
end

--[=[
	Retrieves a binder given a tagName

	@param tagName string
	@return Binder<T>?
]=]
function BinderProvider:Get(tagName: string)
	assert(type(tagName) == "string", "Bad tagName")
	return rawget(self, tagName)
end

--[=[
	Adds a binder given a tag name.

	@param binder Binder<T>
]=]
function BinderProvider:Add(binder)
	assert(not self._started, "Already inited")
	assert(not self:Get(binder:GetTag()), "Binder already exists")

	self._maid:GiveTask(binder)

	table.insert(self._binders, binder)
	self[binder:GetTag()] = binder
end

function BinderProvider:Destroy()
	self._destroyed = true

	for _, item in self._binders do
		rawset(self, item:GetTag(), nil)
	end

	self._maid:DoCleaning()
	self._binders = nil
end

return BinderProvider
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="38">
                <Properties>
                  <string name="Name">BinderProvider.spec</string>
                  <string name="Source"><![CDATA[--[[
	@class BinderProvider.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Binder = require("Binder")
local BinderProvider = require("BinderProvider")
local Jest = require("Jest")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("BinderProvider.new()", function()
	local provider
	local initialized = false

	it("should execute immediately", function()
		provider = BinderProvider.new("BinderServiceName", function(self, arg)
			initialized = true
			assert(arg == 12345, "Bad arg")

			self:Add(Binder.new("Test", function()
				return { Destroy = function() end }
			end))
		end)

		expect(provider).toEqual(expect.any("table"))
	end)

	it("should initialize", function()
		expect(initialized).toEqual(false)
		provider:Init(12345)
		expect(initialized).toEqual(true)
	end)

	it("should contain the binder", function()
		expect(provider.Test).toEqual(expect.any("table"))
	end)

	if provider then
		provider:Destroy()
	end
end)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="39">
                <Properties>
                  <string name="Name">BinderUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility methods for the binder object.
	@class BinderUtils
]=]

local require = require(script.Parent.loader).load(script)

local CollectionService = game:GetService("CollectionService")

local Binder = require("Binder")

local BinderUtils = {}

--[=[
	Finds the first ancestor that is bound with the current child.
	Skips the child class, of course.

	@param binder Binder<T>
	@param child Instance
	@return T?
]=]
function BinderUtils.findFirstAncestor<T>(binder: Binder.Binder<T>, child: Instance): T?
	assert(type(binder) == "table", "Binder must be binder")
	assert(typeof(child) == "Instance", "Child parameter must be instance")

	local current = child.Parent
	while current do
		local class = binder:Get(current)
		if class then
			return class
		end
		current = current.Parent
	end
	return nil
end

--[=[
	Finds the first child bound with the given binder and returns
	the bound class.

	@param binder Binder<T>
	@param parent Instance
	@return T?
]=]
function BinderUtils.findFirstChild<T>(binder: Binder.Binder<T>, parent: Instance): T?
	assert(type(binder) == "table", "Binder must be binder")
	assert(typeof(parent) == "Instance", "Parent parameter must be instance")

	for _, child in parent:GetChildren() do
		local class = binder:Get(child)
		if class then
			return class
		end
	end

	return nil
end

--[=[
	Gets all bound children of the given binder for the parent.

	@param binder Binder<T>
	@param parent Instance
	@return {T}
]=]
function BinderUtils.getChildren<T>(binder: Binder.Binder<T>, parent: Instance): { T }
	assert(type(binder) == "table", "Binder must be binder")
	assert(typeof(parent) == "Instance", "Parent parameter must be instance")

	local objects = {}
	for _, item in parent:GetChildren() do
		local obj = binder:Get(item)
		if obj then
			table.insert(objects, obj)
		end
	end
	return objects
end

--[=[
	Maps a list of binders into a look up table where the keys are
	tags and the value is the binder.

	Duplicates are overwritten by the last entry.

	@param bindersList { Binder<any> }
	@return { [string]: Binder<any> }
]=]
function BinderUtils.mapBinderListToTable<T>(bindersList: { Binder.Binder<T> }): { [string]: Binder.Binder<T> }
	assert(type(bindersList) == "table", "bindersList must be a table of binders")

	local tags: { [string]: Binder.Binder<T> } = {}
	for _, binder in bindersList do
		tags[(binder :: any):GetTag()] = binder :: any
	end

	return tags
end

--[=[
	Given a mapping of tags to binders, retrieves the bound values
	from an instanceList by quering the list of :GetTags() instead
	of iterating over each binder.

	This lookup should be faster when there are potentially many
	interaction points for a given tag map, but the actual bound
	list should be low.

	@param tagsMap { [string]: Binder<T> }
	@param instanceList { Instance }
	@return { T }
]=]
function BinderUtils.getMappedFromList<T>(tagsMap: { [string]: Binder.Binder<T> }, instanceList: { Instance }): { T }
	local objects = {}

	for _, instance in instanceList do
		for _, tag in CollectionService:GetTags(instance) do
			local binder = tagsMap[tag]
			if binder then
				local obj = binder:Get(instance)
				if obj then
					table.insert(objects, obj)
				end
			end
		end
	end

	return objects
end

--[=[
	Given a list of binders retrieves all children bound with the given value.

	@param bindersList { Binder<T> }
	@param parent Instance
	@return { T }
]=]
function BinderUtils.getChildrenOfBinders<T>(bindersList: { Binder.Binder<T> }, parent: Instance): { T }
	assert(type(bindersList) == "table", "bindersList must be a table of binders")
	assert(typeof(parent) == "Instance", "Parent parameter must be instance")

	local tagsMap = BinderUtils.mapBinderListToTable(bindersList)
	return BinderUtils.getMappedFromList(tagsMap, parent:GetChildren())
end

--[=[
	Gets all the linked (via objectValues of name `linkName`) bound objects

	@param binder Binder<T>
	@param linkName string -- Name of the object values required
	@param parent Instance
	@return {T}
]=]
function BinderUtils.getLinkedChildren<T>(binder: Binder.Binder<T>, linkName: string, parent: Instance): { T }
	local seen = {}
	local objects = {}
	for _, item in parent:GetChildren() do
		if item.Name == linkName and item:IsA("ObjectValue") and item.Value then
			local obj = binder:Get(item.Value)
			if obj then
				if not seen[obj] then
					seen[obj] = true
					table.insert(objects, obj)
				else
					warn(
						string.format(
							"[BinderUtils.getLinkedChildren] - Double linked children at %q",
							item:GetFullName()
						)
					)
				end
			end
		end
	end
	return objects
end

--[=[
	Gets all bound descendants of the given binder for the parent.

	@param binder Binder<T>
	@param parent Instance
	@return {T}
]=]
function BinderUtils.getDescendants<T>(binder: Binder.Binder<T>, parent: Instance): { T }
	assert(type(binder) == "table", "Binder must be binder")
	assert(typeof(parent) == "Instance", "Parent parameter must be instance")

	local objects = {}
	for _, item in parent:GetDescendants() do
		local obj = binder:Get(item)
		if obj then
			table.insert(objects, obj)
		end
	end
	return objects
end

return BinderUtils
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="40">
                <Properties>
                  <string name="Name">Collection</string>
                </Properties>
                <Item class="ModuleScript" referent="41">
                  <Properties>
                    <string name="Name">BoundChildCollection</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Tracks child of type of a binder.
	@class BoundChildCollection
]=]

local require = require(script.Parent.loader).load(script)

local BaseObject = require("BaseObject")
local Binder = require("Binder")
local Set = require("Set")
local Signal = require("Signal")

local BoundChildCollection = setmetatable({}, BaseObject)
BoundChildCollection.ClassName = "BoundChildCollection"
BoundChildCollection.__index = BoundChildCollection

export type BoundChildCollection<T> = typeof(setmetatable(
	{} :: {
		_binder: Binder.Binder<T>,
		_parent: Instance,
		_classes: Set.Set<T>,
		ClassAdded: Signal.Signal<T>,
		ClassRemoved: Signal.Signal<T>,
		_size: number,
	},
	{} :: typeof({ __index = BoundChildCollection })
)) & BaseObject.BaseObject

--[=[
	Constructcs a new BoundChildCollection.
	@param binder Binder<T>
	@param parent Instance
	@return BoundChildCollection<T>
]=]
function BoundChildCollection.new<T>(binder: Binder.Binder<T>, parent: Instance): BoundChildCollection<T>
	local self: BoundChildCollection<T> = setmetatable(BaseObject.new() :: any, BoundChildCollection)

	self._binder = binder or error("No binder")
	self._parent = parent or error("No parent")

	--[=[
	Fires on class addition
	@prop ClassAdded Signal<T>
	@within BoundChildCollection
]=]
	self.ClassAdded = self._maid:Add(Signal.new() :: any) -- :Fire(class)

	--[=[
	Fires on class removal
	@prop ClassRemoved Signal<T>
	@within BoundChildCollection
]=]
	self.ClassRemoved = self._maid:Add(Signal.new() :: any) -- :Fire(class)

	self._classes = {} -- [class] = true
	self._size = 0

	self._maid:GiveTask(self._binder:GetClassAddedSignal():Connect(function(...)
		self:_handleNewClassBound(...)
	end))
	self._maid:GiveTask(self._binder:GetClassRemovingSignal():Connect(function(class)
		self:_removeClass(class)
	end))

	self:_startTracking()

	return self
end

--[=[
	Returns whether the track has the class
	@param class T
	@return boolean? -- true if the class exists, nil otherwise
]=]
function BoundChildCollection.HasClass<T>(self: BoundChildCollection<T>, class: T): boolean
	return self._classes[class]
end

--[=[
	Gets the size
	@return number
]=]
function BoundChildCollection.GetSize<T>(self: BoundChildCollection<T>): number
	return self._size
end

--[=[
	Returns the raw classes variable as [class] = true.

	:::warning
	Do not modify the set
	:::

	@return { [T] = true } -- The set
]=]
function BoundChildCollection.GetSet<T>(self: BoundChildCollection<T>): Set.Set<T>
	return self._classes
end

--[=[
	Slow than :GetSet(), but adds them in an ordered list
	@return { T }
]=]
function BoundChildCollection.GetClasses<T>(self: BoundChildCollection<T>): { T }
	local list = {}
	for class, _ in self._classes do
		table.insert(list, class)
	end
	return list
end

function BoundChildCollection._startTracking<T>(self: BoundChildCollection<T>)
	self._maid:GiveTask(self._parent.ChildAdded:Connect(function(child)
		self:_addChild(child)
	end))

	self._maid:GiveTask(self._parent.ChildRemoved:Connect(function(child)
		self:_removeChild(child)
	end))

	for _, child in self._parent:GetChildren() do
		-- Specifically do not fire on init because nothing is listening
		self:_addChild(child, true)
	end
end

function BoundChildCollection._addChild<T>(self: BoundChildCollection<T>, inst: Instance, doNotFire: boolean?): ()
	local class = self._binder:Get(inst)
	if not class then
		return
	end

	self:_addClass(class, doNotFire)
end

function BoundChildCollection._handleNewClassBound<T>(self: BoundChildCollection<T>, class: T, inst: Instance): ()
	if inst.Parent ~= self._parent then
		return
	end

	self:_addClass(class)
end

function BoundChildCollection._removeChild<T>(self: BoundChildCollection<T>, inst: Instance): ()
	local class = self._binder:Get(inst)
	if not class then
		return
	end

	self:_removeClass(class)
end

function BoundChildCollection._addClass<T>(self: BoundChildCollection<T>, class: T, doNotFire: boolean?): ()
	if self._classes[class] then
		return
	end

	self._classes[class] = true
	self._size = self._size + 1
	if not doNotFire then
		self.ClassAdded:Fire(class)
	end
end

function BoundChildCollection._removeClass<T>(self: BoundChildCollection<T>, class: T): ()
	if not self._classes[class] then
		return
	end

	self._classes[class] = nil
	self._size = self._size - 1
	self.ClassRemoved:Fire(class)
end

return BoundChildCollection
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="42">
                <Properties>
                  <string name="Name">Promise</string>
                </Properties>
                <Item class="ModuleScript" referent="43">
                  <Properties>
                    <string name="Name">promiseBoundClass</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Utility function to promise a bound class on an object
	@class promiseBoundClass
]=]

local require = require(script.Parent.loader).load(script)

local Binder = require("Binder")
local CancelToken = require("CancelToken")
local Promise = require("Promise")

--[=[
	Returns a promise that resolves when the class is bound to the instance.
	@param binder Binder<T>
	@param inst Instance
	@param cancelToken CancelToken
	@return Promise<T>
	@function promiseBoundClass
	@within promiseBoundClass
]=]
return function<T>(binder: Binder.Binder<T>, inst: Instance, cancelToken: CancelToken.CancelToken?): Promise.Promise<T>
	assert(Binder.isBinder(binder), "'binder' must be table")
	assert(typeof(inst) == "Instance", "'inst' must be instance")

	return binder:Promise(inst, cancelToken)
end
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="44">
                <Properties>
                  <string name="Name">Trackers</string>
                </Properties>
                <Item class="ModuleScript" referent="45">
                  <Properties>
                    <string name="Name">BoundAncestorTracker</string>
                    <string name="Source"><![CDATA[--[=[
	Tracks a parent bound to a specific binder
	@class BoundAncestorTracker
]=]

local require = require(script.Parent.loader).load(script)

local BaseObject = require("BaseObject")
local BinderUtils = require("BinderUtils")
local ValueObject = require("ValueObject")

local BoundAncestorTracker = setmetatable({}, BaseObject)
BoundAncestorTracker.ClassName = "BoundAncestorTracker"
BoundAncestorTracker.__index = BoundAncestorTracker

--[=[
Constructs a new BoundAncestorTracker

@param binder Binder<T>
@param child Instance
@return BoundAncestorTracker
]=]
function BoundAncestorTracker.new(binder, child)
	local self = setmetatable(BaseObject.new(), BoundAncestorTracker)

	self._child = child or error("No child")
	self._binder = binder or error("No binder")

	--[=[
	@prop Class ValueObject<T>
	@readonly
	@within BoundAncestorTracker
	Bound value
]=]
	self.Class = ValueObject.new()
	self._maid:GiveTask(self.Class)

	-- Handle instance removing
	self._maid:GiveTask(self._binder:GetClassRemovingSignal():Connect(function(class)
		if class == self.Class.Value then
			self.Class.Value = nil
		end
	end))

	self._maid:GiveTask(self._binder:GetClassAddedSignal():Connect(function(_, instance)
		if self._child:IsDescendantOf(instance) then
			self:_update()
		end
	end))

	-- Perform update
	self._maid:GiveTask(self._child.AncestryChanged:Connect(function()
		self:_update()
	end))
	self:_update()

	return self
end

function BoundAncestorTracker:_update()
	local parent = self._child.Parent
	if not parent then
		self.Class.Value = nil
		return
	end

	self.Class.Value = BinderUtils.findFirstAncestor(self._binder, parent)
end

return BoundAncestorTracker
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="46">
                  <Properties>
                    <string name="Name">BoundParentTracker</string>
                    <string name="Source"><![CDATA[--[=[
	Tracks a parent bound to a specific binder
	@class BoundParentTracker
]=]

local require = require(script.Parent.loader).load(script)

local BaseObject = require("BaseObject")
local ValueObject = require("ValueObject")

local BoundParentTracker = setmetatable({}, BaseObject)
BoundParentTracker.ClassName = "BoundParentTracker"
BoundParentTracker.__index = BoundParentTracker

function BoundParentTracker.new(binder, child)
	local self = setmetatable(BaseObject.new(), BoundParentTracker)

	self._child = child or error("No child")
	self._binder = binder or error("No binder")

	-- Bound value
	self.Class = ValueObject.new()
	self._maid:GiveTask(self.Class)

	-- Handle instance removing
	self._maid:GiveTask(self._binder:GetClassRemovingSignal():Connect(function(class)
		if class == self.Class.Value then
			self.Class.Value = nil
		end
	end))

	-- Perform update
	self._maid:GiveTask(self._child:GetPropertyChangedSignal("Parent"):Connect(function()
		self:_update()
	end))
	self:_update()

	return self
end

function BoundParentTracker:_update()
	local parent = self._child.Parent
	if not parent then
		self.Class.Value = nil
		return
	end

	self.Class.Value = self._binder:Get(parent)
end

return BoundParentTracker
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="47">
            <Properties>
              <string name="Name">blend</string>
            </Properties>
            <Item class="Folder" referent="48">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="Folder" referent="49">
                <Properties>
                  <string name="Name">Blend</string>
                </Properties>
                <Item class="ModuleScript" referent="50">
                  <Properties>
                    <string name="Name">Blend</string>
                    <string name="Source"><![CDATA[--[=[
	Declarative UI system inspired by Fusion.
	@class Blend
]=]

local require = require(script.Parent.loader).load(script)

local AccelTween = require("AccelTween")
local BlendDefaultProps = require("BlendDefaultProps")
local Brio = require("Brio")
local BrioUtils = require("BrioUtils")
local Maid = require("Maid")
local MaidTaskUtils = require("MaidTaskUtils")
local Observable = require("Observable")
local Promise = require("Promise")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local RxInstanceUtils = require("RxInstanceUtils")
local RxValueBaseUtils = require("RxValueBaseUtils")
local Signal = require("Signal")
local StepUtils = require("StepUtils")
local ValueBaseUtils = require("ValueBaseUtils")
local ValueObject = require("ValueObject")
local SpringObject

local Blend = {}

export type BlendProps = { [any]: any }

--[=[
	Creates a new function which will return an observable that, given the props
	in question, will construct a new instance and assign all props. This is the
	equivalent of a pipe-able Rx command.

	```lua
	local render = Blend.New "ScreenGui" {
		Parent = game.Players.LocalPlayer.PlayerGui;

		Blend.New "Frame" {
			Size = UDim2.new(1, 0, 1, 0);
			BackgroundTransparency = 0.5;
		};
	};

	maid:GiveTask(render:Subscribe(function(gui)
		print(gui)
	end))
	```

	@param className string
	@return (props: { [string]: any; }) -> Observable<Instance>
]=]
function Blend.New(className: string): (props: BlendProps) -> Observable.Observable<Instance>
	assert(type(className) == "string", "Bad className")

	return function(props: BlendProps)
		return Observable.new(function(sub)
			local instance = Instance.new(className)

			if BlendDefaultProps[className] then
				for key, value in BlendDefaultProps[className] do
					instance[key] = value
				end
			end

			local maid = Blend.mount(instance, props)
			maid:GiveTask(function()
				Blend._safeCleanupInstance(instance)
			end)

			sub:Fire(instance)

			return maid
		end)
	end
end

--[=[
	Creates a new Blend State which is actually just a ValueObject underneath.

	@param defaultValue T
	@param checkType string?
	@return ValueObject<T>
]=]
function Blend.State<T>(defaultValue: T, checkType: ValueObject.ValueObjectTypeArg?): ValueObject.ValueObject<T>
	return ValueObject.new(defaultValue, checkType)
end

--[=[
	Throttles the update to the end of the defer lane. Can help optimize scenarios when
	Compute() can trigger multiple times per a frame.

	Generally not needed.

	@param observable Observable<T>
	@return Observable<T>
]=]
function Blend.Throttled<T>(observable: Observable.Observable<T>): Observable.Observable<T>
	return observable:Pipe({
		Rx.throttleDefer(),
	}) :: any
end

--[=[
	Shares this observables state/computation with all down-stream observables. This can be useful
	when a very expensive computation was done and needs to be shared.

	Generally not needed.

	@param observable Observable<T>
	@return Observable<T>
]=]
function Blend.Shared<T>(observable: Observable.Observable<T>): Observable.Observable<T>
	return observable:Pipe({
		Rx.cache() :: any,
	}) :: any
end

function Blend.Dynamic(...)
	-- stylua: ignore
	return Blend.Computed(...):Pipe({
		-- This switch map is relatively expensive, so we don't do this for defaul computed
		-- and instead force the user to switch to another promise
		Rx.switchMap(function(promise, ...)
			if Promise.isPromise(promise) then
				return Rx.fromPromise(promise) :: any
			elseif Observable.isObservable(promise) then
				return promise
			else
				return Rx.of(promise, ...)
			end
		end) :: any,
	})
end

--[=[
	Takes a list of variables and uses them to compute an observable that
	will combine into any value. These variables can be any value, and if they
	can be converted into an Observable, they will be, which will be used to compute
	the value.

	```lua
	local verbState = Blend.State("hi")
	local nameState = Blend.State("alice")

	local computed = Blend.Computed(verbState, nameState, function(verb, name)
		return verb .. " " .. name
	end)

	maid:GiveTask(computed:Subscribe(function(sentence)
		print(sentence)
	end)) --> "hi alice"

	nameState.Value = "bob" --> "hi bob"
	verbState.Value = "bye" --> "bye bob"
	nameState.Value = "alice" --> "bye alice"
	```

	@param ... A series of convertable states, followed by a function at the end.
	@return Observable<T>
]=]
function Blend.Computed(...)
	local n = select("#", ...)
	local compute = select(n, ...)
	assert(type(compute) == "function", "Bad compute")

	if n == 1 then
		-- static value?
		return Observable.new(function(sub)
			sub:Fire(compute())
		end)
	elseif n == 2 then
		local arg = ...
		local observable = Blend.toPropertyObservable(arg) or Rx.of(arg)
		return Rx.map(compute)(observable)
	else
		local args = table.create(n - 1)

		for i = 1, n - 1 do
			local found = select(i, ...)
			local observable = Blend.toPropertyObservable(found)
			if observable then
				args[i] = observable
			else
				args[i] = found
			end
		end

		return Rx.combineLatest(args):Pipe({
			Rx.map(function(result)
				return compute(unpack(result, 1, n - 1))
			end),
		})
	end
end

--[=[
	Short hand to register a propertyEvent changing

	```lua
	Blend.mount(workspace, {
		[Blend.OnChange "Name"] = function(name)
			print(name)
		end;
	}) --> Immediately will print "Workspace"

	workspace.Name = "Hello" --> Prints "Hello"
	```

	@param propertyName string
	@return (instance: Instance) -> Observable
]=]
function Blend.OnChange(propertyName: string): (instance: Instance) -> Observable.Observable<any>
	assert(type(propertyName) == "string", "Bad propertyName")

	return function(instance: Instance)
		return RxInstanceUtils.observeProperty(instance, propertyName)
	end
end

--[=[
	Short hand to register an event from the instance

	```lua
		Blend.mount(workspace, {
			[Blend.OnEvent "ChildAdded"] = function(child)
				print("Child added", child)
			end;
		})

		local folder = Instance.new("Folder")
		folder.Name = "Hi"
		folder.Parent = workspace --> prints "Child added Hi"
	```

	@param eventName string
	@return (instance: Instance) -> Observable
]=]
function Blend.OnEvent(eventName: string)
	assert(type(eventName) == "string", "Bad eventName")

	return function(instance)
		return Rx.fromSignal(instance[eventName])
	end
end

--[=[
	Uses the constructor to attach a class or resource to the actual object
	for the lifetime of the subscription of that object.

	```lua
	return Blend.New "Frame" {
		Parent = variables.Parent;
		[Blend.Attached(function(parent)
			local maid = Maid.new()

			print("Got", parent)

			maid:GiveTask(function()
				print("Dead!")
			end)

			return maid
		end)] = true;
	}
	```

	@param constructor T
	@return (parent: Instance) -> Observable<T>
]=]
function Blend.Attached(constructor)
	return function(parent: Instance)
		return Observable.new(function(sub)
			local resource = constructor(parent)

			local cleanup = nil
			if MaidTaskUtils.isValidTask(resource) then
				cleanup = resource
			end

			sub:Fire(resource)

			return cleanup
		end)
	end
end

--[=[
	Similiar to Fusion's ComputedPairs, where the changes are cached, and the lifetime limited.
	@param source Observable<T> | any
	@param compute (key: any, value: any, innerMaid: Maid) -> Instance | Observable<Instance>
	@return Observable<Brio<Instance>>
]=]
function Blend.ComputedPairs(source, compute)
	local sourceObservable = Blend.toPropertyObservable(source) or Rx.of(source)

	return Observable.new(function(sub)
		local cache = {}
		local topMaid = Maid.new()

		local maidForKeys = Maid.new()
		topMaid:GiveTask(maidForKeys)

		topMaid:GiveTask(
			sourceObservable:Subscribe(function(newValue)
				-- It's gotta be a table
				assert(type(newValue) == "table", "Bad value emitted from source")

				local excluded = {}
				for key, _ in cache do
					excluded[key] = true
				end

				for key, value in newValue do
					excluded[key] = nil

					if cache[key] ~= value then
						local innerMaid = Maid.new()
						local result = compute(key, value, innerMaid)

						local brio = Brio.new(result)
						innerMaid:GiveTask(brio)

						sub:Fire(brio)

						maidForKeys[key] = innerMaid
						cache[key] = value
					end
				end

				for key, _ in excluded do
					maidForKeys[key] = nil
					cache[key] = nil
				end
			end),
			sub:GetFailComplete()
		)

		return topMaid
	end)
end

--[=[
	Like Blend.Spring, but for AccelTween

	@param source any -- Source observable (or convertable)
	@param acceleration any -- Source acceleration (or convertable)
	@return Observable
]=]
function Blend.AccelTween(source, acceleration)
	local sourceObservable = Blend.toPropertyObservable(source) or Rx.of(source)
	local accelerationObservable = Blend.toNumberObservable(acceleration)

	local function createAccelTween(maid, initialValue)
		local accelTween = AccelTween.new()

		if initialValue then
			accelTween.p = initialValue
			accelTween.t = initialValue
			accelTween.v = 0
		end

		if accelerationObservable then
			maid:GiveTask(accelerationObservable:Subscribe(function(value)
				assert(type(value) == "number", "Bad value")
				accelTween.a = value
			end))
		end

		return accelTween
	end

	-- TODO: Centralize and cache
	return Observable.new(function(sub)
		local accelTween
		local maid = Maid.new()

		local startAnimate, stopAnimate = StepUtils.bindToRenderStep(function()
			sub:Fire(accelTween.p)
			return accelTween.rtime > 0
		end)

		maid:GiveTask(stopAnimate)
		maid:GiveTask(sourceObservable:Subscribe(function(value)
			accelTween = accelTween or createAccelTween(maid, value)
			accelTween.t = value
			startAnimate()
		end))

		return maid
	end)
end

--[=[
	Converts this arbitrary value into an observable that will initialize a spring
	and interpolate it between values upon subscription.

	```lua
	local percentVisible = Blend.State(0)
	local visibleSpring = Blend.Spring(percentVisible, 30)
	local transparency = Blend.Computed(visibleSpring, function(percent)
		return 1 - percent
	end);

	Blend.mount(frame, {
		BackgroundTransparency = visibleSpring;
	})
	```

	@param source any
	@param speed any
	@param damper any
	@return Observable?
]=]
function Blend.Spring(source, speed, damper)
	if not SpringObject then
		SpringObject = (require :: any)("SpringObject")
	end

	return Observable.new(function(sub)
		local spring = SpringObject.new(source, speed, damper)
		spring.Epsilon = 1e-3

		spring._maid:GiveTask(spring:Observe():Subscribe(sub:GetFireFailComplete()))

		return spring
	end)
end

--[=[
	Converts this arbitrary value into an observable suitable for use in properties.

	@param value any
	@return Observable?
]=]
function Blend.toPropertyObservable(value)
	if type(value) == "table" then
		if Observable.isObservable(value) then
			return value
		elseif Promise.isPromise(value) then
			return Rx.fromPromise(value)
		elseif value.Observe then
			return value:Observe()
		else
			return nil
		end
	elseif typeof(value) == "Instance" then
		-- IntValue, ObjectValue, et cetera
		if ValueBaseUtils.isValueBase(value) then
			return RxValueBaseUtils.observeValue(value)
		else
			return nil
		end
	else
		return nil
	end
end

--[=[
	Converts this arbitrary value into an observable that emits numbers.

	@param value number | any
	@return Observable<number>?
]=]
function Blend.toNumberObservable(value)
	if type(value) == "number" then
		return Rx.of(value)
	else
		return Blend.toPropertyObservable(value)
	end
end

--[=[
	Converts this arbitrary value into an observable that can be used to emit events.

	@param value any
	@return Observable?
]=]
function Blend.toEventObservable(value)
	if Observable.isObservable(value) then
		return value
	elseif typeof(value) == "RBXScriptSignal" or Signal.isSignal(value) then
		return Rx.fromSignal(value)
	else
		return nil
	end
end

--[=[
	Converts this arbitrary value into an event handler, which can be subscribed to

	@param value any
	@return function?
]=]
function Blend.toEventHandler(value)
	if type(value) == "function" then
		return value
	elseif typeof(value) == "Instance" then
		-- IntValue, ObjectValue, et cetera
		if ValueBaseUtils.isValueBase(value) then
			return function(result)
				(value :: any).Value = result
			end
		end
	elseif type(value) == "table" then
		if Signal.isSignal(value) then
			return function(...)
				value:Fire(...)
			end
		elseif value.ClassName == "ValueObject" then
			return function(result)
				value.Value = result
			end
		end
	end

	return nil
end

--[=[
	Mounts children to the parent and returns an object which will cleanup and delete
	all children when removed.

	Note that this effectively recursively mounts children and their values, which is
	the heart of the reactive tree.

	```lua
	Blend.New "ScreenGui" {
		Parent = game.Players.LocalPlayer.PlayerGui;
		[Blend.Children] = {
			Blend.New "Frame" {
				Size = UDim2.new(1, 0, 1, 0);
				BackgroundTransparency = 0.5;
			};
		};
	};
	```

	Note since 6.14 you don't need to be explicit about [Blend.Children]. Any number-based
	index in the mounting process will be automatically inferred as children to mount.

	```lua
	Blend.New "ScreenGui" {
		Parent = game.Players.LocalPlayer.PlayerGui;

		Blend.New "Frame" {
			Size = UDim2.new(1, 0, 1, 0);
			BackgroundTransparency = 0.5;
		};
	};
	```

	Rules:

	* `{ Instance }` - Tables of instances are all parented to the parent
	* Brio<Instance> will last for the lifetime of the brio
	* Brio<Observable<Instance>> will last for the lifetime of the brio
		* Brio<Signal<Instance>> will also act as above
		* Brio<Promise<Instance>> will also act as above
		* Brio<{ Instance } will also act as above
	* Observable<Instance> will parent to the parent
		* Signal<Instance> will act as Observable<Instance>
		* ValueObject<Instance> will act as an Observable<Instance>
		* Promise<Instance> will act as an Observable<Instance>
	*  will parent all instances to the parent
	* Observables may emit non-observables (in form of Computed/Dynamic)
		* Observable<Brio<Instance>> will last for the lifetime of the brio, and parent the instance.
		* Observable<Observable<Instance>> occurs when computed returns a value.
	* ValueObject<Instance> will switch to the current value
	* function - Will be invoked as `func(parent)` and then the standard scheme will be applied

	Cleanup:
	* Instances will be cleaned up on unsubscribe

	@param parent Instance
	@param value any
	@return Observable
]=]
function Blend.Children(parent: Instance, value)
	assert(typeof(parent) == "Instance", "Bad parent")

	local observe = Blend._observeChildren(value, parent)

	if observe then
		return Observable.new(function(_sub)
			return observe:Subscribe(function(child)
				child.Parent = parent
			end)
		end)
	else
		return Rx.EMPTY
	end
end

--[=[
	Allows you to add [CollectionService] tags to a Blend object.

	```lua
	Blend.New "ScreenGui" {
		[Blend.Tags] = { "Hide", "ScreenGui" };
	};
	```

	@param parent Instance
	@param value any
	@return Observable
]=]
function Blend.Tags(parent: Instance, value)
	assert(typeof(parent) == "Instance", "Bad parent")

	local observe = Blend._observeTags(value)

	if observe then
		return observe:Pipe({
			Rx.tap(function(tag)
				if type(tag) == "string" then
					parent:AddTag(tag)
				else
					error("Bad tag")
				end
			end),
		})
	else
		return Rx.EMPTY
	end
end

function Blend._observeTags(tags)
	if type(tags) == "string" then
		return Rx.of(tags)
	elseif type(tags) == "table" then
		if Observable.isObservable(tags) then
			return tags
		else
			error("Bad tags")
		end
	else
		error("Bad tags")
	end
end

--[=[
	Mounts Blend objects into an existing instance.

	:::tip
	Normally specifying ClassName as a property breaks mounting, since you
	can't write to ClassName. However, if you specify ClassName here, it will only
	listen to changes on children with that class name.
	:::

	If multiple instances are named the same thing, then this will
	bind to both.

	:::tip
	This explicitly listens for any children underneath the mounted
	instance with the name passed in here. This is fine for small amounts
	of instances, like in most Gui hierarchies. However, it will be way less
	performance friendly for large class hierarchies.
	:::

	```lua
	maid:GiveTask(Blend.mount(frame, {
		Size = UDim2.new(0.5, 0, 0.5, 0);

		Blend.Find "UIScale" {
			Scale = 2;
		};
	}))
	```

	:::tip

	:::

	@param className string
	@return function
]=]
function Blend.Find(className: string)
	assert(type(className) == "string", "Bad className")

	return function(props)
		assert(type(props) == "table", "Bad props")
		assert(type(props.Name) == "string", "No props.Name")

		-- Return observable and assume we're being used in anexternal context
		-- TODO: Maybe not this
		if props.Parent then
			local propertyObservable = Blend.toPropertyObservable(props.Parent)

			local function handleChildBrio(brio)
				if brio:IsDead() then
					return
				end

				local maid, instance = brio:ToMaidAndValue()

				maid:GiveTask(Blend.mount(instance, props))

				if brio:IsDead() then
					maid:DoCleaning()
				end

				-- Emit back found value (we're used in property scenario)
				return Rx.of(instance)
			end

			if propertyObservable then
				return propertyObservable:Pipe({
					RxBrioUtils.switchToBrio(function(parent)
						return parent ~= nil
					end),
					RxBrioUtils.switchMapBrio(function(parent)
						assert(typeof(parent) == "Instance", "Bad parent retrieved during find spec")

						return RxInstanceUtils.observeChildrenOfNameBrio(parent, className, props.Name)
					end),
					Rx.flatMap(handleChildBrio),
				})
			else
				return RxInstanceUtils.observeChildrenOfNameBrio(props.Parent, className, props.Name):Pipe({
					Rx.flatMap(handleChildBrio),
				})
			end
		end

		-- Return callback
		return function(parent)
			-- TODO: Swap based upon name
			-- TODO: Avoid assigning name
			return RxInstanceUtils.observeChildrenOfNameBrio(parent, className, props.Name):Pipe({
				Blend._mountToFinding(props),
			})
		end
	end
end

function Blend._mountToFinding(props)
	return Rx.flatMap(function(brio)
		if brio:IsDead() then
			return
		end

		local maid, instance = brio:ToMaidAndValue()

		maid:GiveTask(Blend.mount(instance, props))

		-- Dead after mounting? Clean up...
		-- Probably caused by name change.
		if brio:IsDead() then
			maid:DoCleaning()
		end

		-- Avoid emitting anything else so we don't get cleaned up
		return Rx.EMPTY
	end)
end

--[=[
	An event emitter that emits the instance that was actually created. This is
	useful for a variety of things.

	Using this to track an instance

	```lua
	local currentCamera = Blend.State()

	return Blend.New "ViewportFrame" {
		CurrentCamera = currentCamera;
		[Blend.Children] = {
			self._current;
			Blend.New "Camera" {
				[Blend.Instance] = currentCamera;
			};
		};
	};
	```

	Note that since 6.14 you should also be able to just use the reification scheme of
	[Blend.Children] implicitly in [Blend.mount] to get somewhat equivalent behavior.

	```lua
	Blend.mount(frame, {
		-- Array indexed methods get treated as children-constructors, which get the parent
		-- in them;

		function(parent)
			print("Got parent!", parent)
		end;
	})
	```

	You can also use this to execute code against an instance.

	```lua
	return Blend.New "Frame" {
		[Blend.Instance] = function(frame)
			print("We got a new frame!")
		end;
	};
	```

	Note that if you subscribe twice to the resulting observable, the internal function
	will execute twice.

	@param parent Instance
	@return Observable<Instance>
]=]
function Blend.Instance(parent: Instance): Observable.Observable<Instance>
	return Observable.new(function(sub)
		sub:Fire(parent)
	end)
end

--[=[
	Ensures the computed version of a value is limited by lifetime instead
	of multiple. Used in conjunction with [Blend.Children] and [Blend.Computed].

	:::warning
	In general, cosntructing new instances like this is a bad idea, so it's recommended against it.
	:::

	```
	local render = Blend.New "ScreenGui" {
		Parent = game.Players.LocalPlayer.PlayerGui;
		[Blend.Children] = {
			Blend.Single(Blend.Computed(percentVisible, function()
				-- you generally would not want to do this anyway because this reconstructs a new frame
				-- every frame.

				Blend.New "Frame" {
					Size = UDim2.new(1, 0, 1, 0);
					BackgroundTransparency = 0.5;
				};
			end)
		};
	};

	maid:GiveTask(render:Subscribe(function(gui)
		print(gui)
	end))
	```

	@function Single
	@param Observable<Instance | Brio<Instance>>
	@return Observable<Brio<Instance>>
	@within Blend
]=]
function Blend.Single(observable)
	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(observable:Subscribe(function(result)
			if Brio.isBrio(result) then
				local copy = BrioUtils.clone(result)
				maid._current = copy
				sub:Fire(copy)
				return copy
			end

			local current = Brio.new(result)
			maid._current = current
			sub:Fire(current)

			return current
		end))

		return maid
	end)
end

function Blend._safeCleanupInstance(result: Instance)
	-- Unparent all children incase we want to resurrect them
	for _, child in result:GetChildren() do
		child.Parent = nil
	end
	result:Destroy()
end

--[=[
	Observes children and ensures that the value is cleaned up
	afterwards.
	@param value any
	@param parent Instance
	@return Observable<Instance>
]=]
function Blend._observeChildren(value, parent)
	if typeof(value) == "Instance" then
		-- Should be uncommon
		return Observable.new(function(sub)
			sub:Fire(value)
			-- don't complete, as this would clean everything up
			return value
		end)
	end

	if type(value) == "function" then
		value = Blend._observeChildren(value(parent), parent)
	end

	if ValueObject.isValueObject(value) then
		return Observable.new(function(sub)
			local maid = Maid.new()

			-- Switch instead of emitting every value.
			local function update()
				local result = value.Value
				if typeof(result) == "Instance" then
					maid._current = result
					sub:Fire(result)
					return
				end

				local observe = Blend._observeChildren(result, parent)
				if observe then
					maid._current = nil

					local doCleanup = false
					local cleanup
					cleanup = observe:Subscribe(function(inst)
						sub:Fire(inst)
					end, function(...)
						sub:Fail(...)
					end, function()
						-- incase of immediate execution
						doCleanup = true

						-- Do not pass complete through to the end
						if maid._current == cleanup then
							maid._current = nil
						end
					end)

					-- TODO: Complete when valueobject cleans up

					if doCleanup then
						if cleanup then
							MaidTaskUtils.doCleanup(cleanup)
						end
					else
						maid._current = cleanup
					end

					return
				end

				maid._current = nil
			end
			maid:GiveTask(value.Changed:Connect(update))
			update()

			return maid
		end)
	end

	if Brio.isBrio(value) then
		return Observable.new(function(sub)
			if value:IsDead() then
				return nil
			end

			local result = value:GetValue()
			if typeof(result) == "Instance" then
				local maid = value:ToMaid()
				maid:GiveTask(function()
					Blend._safeCleanupInstance(result)
				end)
				sub:Fire(result)

				return maid
			end

			local observe = Blend._observeChildren(result, parent)
			if observe then
				local maid = value:ToMaid()

				-- Subscription is for lifetime of brio, so we do
				-- not need to specifically add these results to the maid, and
				-- risk memory leak of the maid with a lot of items in it.
				maid:GiveTask(observe:Subscribe(function(inst)
					sub:Fire(inst)
				end, function(...)
					sub:Fail(...)
				end, function()
					-- completion should not result more than maid cleaning up
					maid:DoCleaning()
				end))

				return maid
			end

			warn(string.format("Unknown type in brio %q", typeof(result)))
			return nil
		end)
	end

	-- Handle like observable
	if Promise.isPromise(value) then
		value = Rx.fromPromise(value)
	end

	-- Handle like observable
	if Signal.isSignal(value) or typeof(value) == "RBXScriptSignal" then
		value = Rx.fromSignal(value)
	end

	if Observable.isObservable(value) then
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(value:Subscribe(function(result)
				if typeof(result) == "Instance" then
					-- lifetime of subscription
					maid:GiveTask(function()
						Blend._safeCleanupInstance(result)
					end)
					sub:Fire(result)
					return
				end

				local observe = Blend._observeChildren(result, parent)

				if observe then
					local innerMaid = Maid.new()

					-- Note: I think this still memory leaks
					innerMaid:GiveTask(observe:Subscribe(function(inst)
						sub:Fire(inst)
					end, function(...)
						innerMaid:DoCleaning()
						sub:Fail(...)
					end, function()
						innerMaid:DoCleaning()
					end))

					innerMaid:GiveTask(function()
						maid[innerMaid] = nil
					end)
					maid[innerMaid] = innerMaid
				else
					warn(string.format("Failed to convert %q into children", tostring(result)))
				end
			end, function(...)
				sub:Fire(...)
			end, function()
				-- Drop completion, other inner components may have completed.
			end))

			return maid
		end)
	end

	if type(value) == "table" and not getmetatable(value) then
		local observables = {}
		for key, item in value do
			local observe = Blend._observeChildren(item, parent)
			if observe then
				table.insert(observables, observe)
			else
				warn(string.format("Failed to convert [%s] %q into children", tostring(key), tostring(item)))
			end
		end

		if next(observables) then
			return Rx.merge(observables)
		else
			return nil
		end
	end

	return nil
end

--[=[
	Mounts the instance to the props. This handles mounting children, and events.

	The contract is that the props table is turned into observables. Note the following.

	* Keys of strings are turned into properties
		* If this can be turned into an observable, it will be used to subscribe to this event
		* Otherwise, we assign directly
	* Keys of functions are invoked on the instance in question
		* `(instance, value) -> Observable
		* If this returns an observable (or can be turned into one), we subscribe the event immediately
	* Keys of numbers (array components) are treated as implicit children
	* If the key is [Blend.Children] then we invoke mountChildren on it.

	```lua
	maid:GiveTask(Blend.mount(frame, {
		BackgroundTransparency = 1;

		-- All items named InventoryFrame
		Blend.Find "Frame" {
			Name = "InventoryFrame"

			-- Apply the following properties
			Blend.New "UIScale" {
				Scale = 0.5;
			};
		};
	}))
	```

	@param instance Instance
	@param props table
	@return Maid
]=]
function Blend.mount(instance: Instance, props: BlendProps): Maid.Maid
	assert(typeof(instance) == "Instance", "Bad instance")

	local maid = Maid.new()

	local parent = nil
	local dependentObservables = {}
	local children = {}

	for key, value in props do
		if type(key) == "string" then
			if key == "Parent" then
				parent = value
			else
				local observable = Blend.toPropertyObservable(value)
				if observable then
					maid:GiveTask(observable:Subscribe(function(result)
						instance[key] = result
						-- task.spawn(function()
						-- 	instance[key] = result
						-- end)
					end))
				else
					-- task.spawn(function()
					-- 	instance[key] = value
					-- end)
					instance[key] = value
				end
			end
		elseif type(key) == "function" then
			local observable = Blend.toEventObservable(key(instance, value))

			if Observable.isObservable(observable) then
				table.insert(dependentObservables, { observable, value })
			else
				warn(string.format("Unable to apply event listener %q", tostring(key)))
			end
		elseif type(key) == "number" then
			-- Treat this as an implicit children contract
			-- Thus, we don't need an explicit [Blend.Children] call.
			table.insert(children, value)
		else
			warn(string.format("Unable to apply property %q", tostring(key)))
		end
	end

	if #children > 0 then
		maid:GiveTask(Blend.Children(instance, children):Subscribe())
	end

	-- Subscribe dependentObservables (which includes adding children)
	for _, event in dependentObservables do
		maid:GiveTask(event[1]:Subscribe(Blend.toEventHandler(event[2])))
	end

	if parent then
		local observable = Blend.toPropertyObservable(parent)
		if observable then
			maid:GiveTask(observable:Subscribe(function(result)
				instance.Parent = result
			end))
		else
			instance.Parent = parent
		end
	end

	return maid
end

return Blend
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="51">
                  <Properties>
                    <string name="Name">BlendDefaultProps</string>
                    <string name="Source"><![CDATA[--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

--[[

MIT License

Copyright (c) 2021 Elttob
Copyright (c) 2021-2023 Quenty

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50,
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0),
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14,
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14,
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14,
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
	},

	UIListLayout = {
		SortOrder = Enum.SortOrder.LayoutOrder,
	},

	Sound = {
		RollOffMode = Enum.RollOffMode.InverseTapered,
	},

	Part = {
		TopSurface = Enum.SurfaceType.Smooth,
		BottomSurface = Enum.SurfaceType.Smooth,
	},
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="52">
                  <Properties>
                    <string name="Name">SpringObject</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	This is like a [Spring], but it can be observed, and emits events. It handles [Observable]s and

	@class SpringObject
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local DuckTypeUtils = require("DuckTypeUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local Promise = require("Promise")
local Signal = require("Signal")
local Spring = require("Spring")
local SpringUtils = require("SpringUtils")
local StepUtils = require("StepUtils")

local SpringObject = {}
SpringObject.ClassName = "SpringObject"
SpringObject.__index = SpringObject

export type SpringObject<T> = typeof(setmetatable(
	{} :: {
		-- Public
		Changed: Signal.Signal<()>,
		Observe: (self: SpringObject<T>) -> Observable.Observable<T>,
		ObserveRenderStepped: (self: SpringObject<T>) -> Observable.Observable<T>,
		ObserveTarget: (self: SpringObject<T>) -> Observable.Observable<T>,
		ObserveVelocityOnRenderStepped: (self: SpringObject<T>) -> Observable.Observable<T>,
		PromiseFinished: (self: SpringObject<T>, signal: RBXScriptSignal?) -> Promise.Promise<boolean>,
		ObserveVelocityOnSignal: (self: SpringObject<T>, signal: RBXScriptSignal) -> Observable.Observable<T>,
		ObserveOnSignal: (self: SpringObject<T>, signal: RBXScriptSignal) -> Observable.Observable<T>,
		IsAnimating: (self: SpringObject<T>) -> boolean,
		Impulse: (self: SpringObject<T>, velocity: T) -> (),
		SetTarget: (self: SpringObject<T>, target: T, doNotAnimate: boolean?) -> () -> (),
		SetVelocity: (self: SpringObject<T>, velocity: T) -> (),
		SetPosition: (self: SpringObject<T>, position: T) -> (),
		SetDamper: (self: SpringObject<T>, damper: number | Observable.Observable<number>) -> (),
		SetSpeed: (self: SpringObject<T>, speed: number | Observable.Observable<number>) -> (),
		SetClock: (self: SpringObject<T>, clock: Spring.SpringClock) -> (),
		SetEpsilon: (self: SpringObject<T>, epsilon: number) -> (),
		TimeSkip: (self: SpringObject<T>, delta: number) -> (),
		Destroy: (self: SpringObject<T>) -> (),

		-- Properties
		Value: T,
		Position: T,
		p: T,
		Velocity: T,
		v: T,
		Target: T,
		t: T,
		Damper: number,
		d: number,
		Speed: number,
		s: number,
		Clock: Spring.SpringClock,
		Epsilon: number,

		-- Members
		_maid: Maid.Maid,
		_epsilon: number,
		_currentSpring: Spring.Spring<T>,
		_initInfo: { Clock: () -> number, Damper: number, Speed: number },
	},
	SpringObject
))

--[=[
	Constructs a new SpringObject.

	The spring object is initially initialized as a spring at 0, with a target of 0. Upon setting
	a target or position, it will be initialized and begin emitting events.

	If two observables emit different types the spring will retain the speed, damper, and switch to
	an initializes.

	@param target T
	@param speed number | Observable<number> | ValueObject<number> | NumberValue | any
	@param damper number | Observable<number> | NumberValue | any
	@return Spring<T>
]=]
function SpringObject.new<T>(target: T, speed, damper): SpringObject<T>
	local self = setmetatable({
		_maid = Maid.new(),
		_epsilon = 1e-6,
		Changed = Signal.new(),
	}, SpringObject)

	--[=[
	Event fires when the spring value changes
	@prop Changed Signal<()> -- Fires whenever the spring initially changes state
	@within SpringObject
]=]
	self._maid:GiveTask(self.Changed)

	if target then
		self:SetTarget(target)
	else
		-- Ensure we initialize at 0 so we can emit a value immediately
		self:SetTarget(0)
	end

	if speed then
		self.Speed = speed
	end

	if damper then
		self.Damper = damper
	end

	return self :: any
end

--[=[
	Returns whether an object is a SpringObject.
	@param value any
	@return boolean
]=]
function SpringObject.isSpringObject(value: any): boolean
	return DuckTypeUtils.isImplementation(SpringObject, value)
end

--[=[
	Observes the spring animating
	@return Observable<T>
]=]
function SpringObject:ObserveRenderStepped()
	return self:ObserveOnSignal(RunService.RenderStepped)
end

--[=[
	Alias for [ObserveRenderStepped]

	@return Observable<T>
]=]
function SpringObject:Observe()
	if RunService:IsClient() then
		return self:ObserveOnSignal(RunService.RenderStepped)
	else
		return self:ObserveOnSignal(RunService.Stepped)
	end
end

--[=[
	Observes the current target of the spring

	@return Observable<T>
]=]
function SpringObject:ObserveTarget()
	return Observable.new(function(sub)
		local maid = Maid.new()

		local lastTarget = self.Target

		maid:GiveTask(self.Changed:Connect(function()
			local target = self.Target
			if lastTarget ~= target then
				lastTarget = target
				sub:Fire(target)
			end
		end))

		sub:Fire(lastTarget)

		return maid
	end)
end

function SpringObject:ObserveVelocityOnRenderStepped()
	return self:ObserveVelocityOnSignal(RunService.RenderStepped)
end

--[=[
	Promises that the spring is done, based upon the animating property
	Relatively expensive.

	@param signal RBXScriptSignal | nil
	@return Observable<T>
]=]
function SpringObject:PromiseFinished(signal)
	signal = signal or RunService.RenderStepped

	local maid = Maid.new()
	local promise = maid:Add(Promise.new())

	-- TODO: Mathematical solution?
	local startAnimate, stopAnimate = StepUtils.bindToSignal(signal, function()
		local currentSpring = rawget(self, "_currentSpring")
		if not currentSpring then
			return false
		end

		local animating = SpringUtils.animating(currentSpring, self._epsilon)
		if not animating then
			promise:Resolve(true)
		end

		return animating
	end)

	maid:GiveTask(stopAnimate)
	maid:GiveTask(self.Changed:Connect(startAnimate))
	startAnimate()

	self._maid[promise] = maid

	promise:Finally(function()
		self._maid[promise] = nil
	end)

	maid:GiveTask(function()
		self._maid[promise] = nil
	end)

	return promise
end

function SpringObject:ObserveVelocityOnSignal(signal)
	return Observable.new(function(sub)
		local maid = Maid.new()

		local startAnimate, stopAnimate = StepUtils.bindToSignal(signal, function()
			local currentSpring = rawget(self, "_currentSpring")
			if not currentSpring then
				return false
			end

			local animating = SpringUtils.animating(currentSpring, self._epsilon)
			if animating then
				sub:Fire(SpringUtils.fromLinearIfNeeded(currentSpring.Velocity))
			else
				sub:Fire(SpringUtils.fromLinearIfNeeded(0 * currentSpring.Velocity))
			end

			return animating
		end)

		maid:GiveTask(stopAnimate)
		maid:GiveTask(self.Changed:Connect(startAnimate))
		startAnimate()

		return maid
	end)
end

--[=[
	Observes the spring animating
	@param signal RBXScriptSignal
	@return Observable<T>
]=]
function SpringObject:ObserveOnSignal(signal)
	return Observable.new(function(sub)
		local maid = Maid.new()

		local startAnimate, stopAnimate = StepUtils.bindToSignal(signal, function()
			local currentSpring = rawget(self, "_currentSpring")
			if not currentSpring then
				return false
			end

			local animating, position = SpringUtils.animating(currentSpring, self._epsilon)
			sub:Fire(SpringUtils.fromLinearIfNeeded(position))
			return animating
		end)

		maid:GiveTask(stopAnimate)
		maid:GiveTask(self.Changed:Connect(startAnimate))
		startAnimate()

		return maid
	end)
end

--[=[
	Returns true when we're animating
	@return boolean -- True if animating
]=]
function SpringObject:IsAnimating(): boolean
	local currentSpring = rawget(self, "_currentSpring")
	if not currentSpring then
		return false
	end

	return (SpringUtils.animating(currentSpring, self._epsilon))
end

--[=[
	Impulses the spring, increasing velocity by the amount given. This is useful to make something shake,
	like a Mac password box failing.

	@param velocity T -- The velocity to impulse with
	@return ()
]=]
function SpringObject:Impulse(velocity)
	local converted = SpringUtils.toLinearIfNeeded(velocity)
	local currentSpring = self:_getSpringForType(velocity)
	currentSpring:Impulse(converted)
	self.Changed:Fire()
end

--[=[
	Sets the actual target. If doNotAnimate is set, then animation will be skipped.

	@param target T -- The target to set
	@param doNotAnimate boolean? -- Whether or not to animate
]=]
function SpringObject:SetTarget<T>(target: T, doNotAnimate: boolean?)
	assert(target ~= nil, "Bad target")

	local observable = Blend.toPropertyObservable(target)
	if not observable then
		self._maid._targetSub = nil
		self:_applyTarget(target, doNotAnimate)
		return function() end
	end

	local sub
	self._maid._targetSub = nil
	if doNotAnimate then
		local isFirst = true
		sub = observable:Subscribe(function(unconverted)
			local converted = SpringUtils.toLinearIfNeeded(unconverted)
			assert(converted, "Not a valid converted target")

			local wasFirst = isFirst
			isFirst = false
			self:_applyTarget(unconverted, wasFirst)
		end)
	else
		sub = observable:Subscribe(function(unconverted)
			self:_applyTarget(unconverted, doNotAnimate)
		end)
	end

	self._maid._targetSub = sub

	return function()
		if self._maid._targetSub == sub then
			self._maid._targetSub = nil
		end
	end
end

function SpringObject:_applyTarget(unconverted, doNotAnimate: boolean?)
	local converted = SpringUtils.toLinearIfNeeded(unconverted)
	self:_getSpringForType(converted):SetTarget(converted, doNotAnimate)
	self.Changed:Fire()
end

--[=[
	Sets the velocity for the spring

	@param velocity T
]=]
function SpringObject:SetVelocity(velocity)
	assert(velocity ~= nil, "Bad velocity")

	local observable = Blend.toPropertyObservable(velocity)
	if not observable then
		self._maid._velocitySub = nil
		self:_applyVelocity(velocity)
	else
		self._maid._velocitySub = observable:Subscribe(function(unconverted)
			self:_applyVelocity(unconverted)
		end)
	end
end

function SpringObject:_applyVelocity(unconverted)
	local converted = SpringUtils.toLinearIfNeeded(unconverted)

	self:_getSpringForType(0 * (converted :: any)).Velocity = converted
	self.Changed:Fire()
end

--[=[
	Sets the position for the spring

	@param position T
]=]
function SpringObject:SetPosition(position)
	assert(position ~= nil, "Bad position")

	local observable = Blend.toPropertyObservable(position)
	if not observable then
		self._maid._positionSub = nil
		self:_applyPosition(position)
	else
		self._maid._positionSub = observable:Subscribe(function(unconverted)
			self:_applyPosition(unconverted)
		end)
	end
end

function SpringObject:_applyPosition(unconverted)
	local converted = SpringUtils.toLinearIfNeeded(unconverted)
	self:_getSpringForType(converted).Value = converted
	self.Changed:Fire()
end

--[=[
	Sets the damper for the spring

	@param damper number | Observable<number>
]=]
function SpringObject:SetDamper(damper)
	assert(damper ~= nil, "Bad damper")

	if type(damper) == "number" then
		self._maid._damperSub = nil
		self:_applyDamper(damper)
	else
		local observable = assert(Blend.toPropertyObservable(damper), "Invalid damper")

		self._maid._damperSub = observable:Subscribe(function(unconverted)
			self:_applyDamper(unconverted)
		end)
	end
end

function SpringObject:_applyDamper(unconverted: number)
	assert(type(unconverted) == "number", "Bad unconverted")

	local currentSpring = rawget(self, "_currentSpring")
	if currentSpring then
		currentSpring.Damper = unconverted
	else
		self:_getInitInfo().Damper = unconverted
	end

	self.Changed:Fire()
end

--[=[
	Sets the damper for the spring

	@param speed number | Observable<number>
]=]
function SpringObject:SetSpeed(speed)
	assert(speed ~= nil, "Bad speed")

	if type(speed) == "number" then
		self._maid._speedSub = nil
		self:_applySpeed(speed)
	else
		local observable = assert(Blend.toPropertyObservable(speed), "Invalid speed")

		self._maid._speedSub = observable:Subscribe(function(unconverted)
			self:_applySpeed(unconverted)
		end)
	end
end

function SpringObject:_applySpeed(unconverted: number)
	assert(type(unconverted) == "number", "Bad unconverted")

	local currentSpring = rawget(self, "_currentSpring")
	if currentSpring then
		currentSpring.Speed = unconverted
	else
		self:_getInitInfo().Speed = unconverted
	end

	self.Changed:Fire()
end

--[=[
	Sets the clock function for the spring

	@param clock () -> (number)
]=]
function SpringObject:SetClock(clock: Spring.SpringClock)
	assert(type(clock) == "function", "Bad clock clock")

	local currentSpring = rawget(self, "_currentSpring")
	if currentSpring then
		currentSpring.Clock = clock
	else
		self:_getInitInfo().Clock = clock
	end

	self.Changed:Fire()
end

--[=[
	Sets the epsilon for the spring to stop animating

	@param epsilon number
]=]
function SpringObject:SetEpsilon(epsilon: number)
	assert(type(epsilon) == "number", "Bad epsilon")

	rawset(self, "_epsilon", epsilon)

	self.Changed:Fire()
end

--[=[
	Instantly skips the spring forwards by that amount time
	@param delta number -- Time to skip forwards
	@return ()
]=]
function SpringObject:TimeSkip(delta: number)
	assert(type(delta) == "number", "Bad delta")

	local currentSpring = rawget(self, "_currentSpring")
	if not currentSpring then
		return
	end

	currentSpring:TimeSkip(delta)
	self.Changed:Fire()
end

(SpringObject :: any).__index = function(self, index)
	local currentSpring = rawget(self, "_currentSpring")

	if SpringObject[index] then
		return SpringObject[index]
	elseif index == "Value" or index == "Position" or index == "p" then
		if currentSpring then
			return SpringUtils.fromLinearIfNeeded(currentSpring.Value)
		else
			return 0
		end
	elseif index == "Velocity" or index == "v" then
		if currentSpring then
			return SpringUtils.fromLinearIfNeeded(currentSpring.Velocity)
		else
			return 0
		end
	elseif index == "Target" or index == "t" then
		if currentSpring then
			return SpringUtils.fromLinearIfNeeded(currentSpring.Target)
		else
			return 0
		end
	elseif index == "Damper" or index == "d" then
		if currentSpring then
			return currentSpring.Damper
		else
			return (self :: any):_getInitInfo().Damper
		end
	elseif index == "Speed" or index == "s" then
		if currentSpring then
			return currentSpring.Speed
		else
			return (self :: any):_getInitInfo().Speed
		end
	elseif index == "Clock" then
		if currentSpring then
			return currentSpring.Clock
		else
			return (self :: any):_getInitInfo().Clock
		end
	elseif index == "Epsilon" then
		return self._epsilon
	elseif index == "_currentSpring" then
		local found = rawget(self, "_currentSpring")
		if found then
			return found
		end

		-- Note that sometimes the current spring isn't loaded yet as a type so
		-- we use a number for this.
		error("Internal error: Cannot get _currentSpring, as we aren't initialized yet")
	else
		error(string.format("%q is not a member of SpringObject", tostring(index)))
	end
end

function SpringObject:__newindex(index, value)
	if index == "Value" or index == "Position" or index == "p" then
		self:SetPosition(value)
	elseif index == "Velocity" or index == "v" then
		self:SetVelocity(value)
	elseif index == "Target" or index == "t" then
		self:SetTarget(value)
	elseif index == "Damper" or index == "d" then
		self:SetDamper(value)
	elseif index == "Speed" or index == "s" then
		self:SetSpeed(value)
	elseif index == "Clock" then
		self:SetClock(value)
	elseif index == "Epsilon" then
		self:SetEpsilon(value)
	elseif index == "_currentSpring" then
		error("Cannot set _currentSpring")
	else
		error(string.format("%q is not a member of SpringObject", tostring(index)))
	end
end

--[[
	Callers of this must invoke .Changed after using this method
]]
function SpringObject:_getSpringForType(converted)
	local currentSpring = rawget(self, "_currentSpring")

	if currentSpring == nil then
		-- only happens on init
		local newSpring = Spring.new(converted)

		local foundInitInfo = rawget(self, "_initInfo")
		if foundInitInfo then
			rawset(self, "_initInfo", nil)
			newSpring.Clock = foundInitInfo.Clock
			newSpring.Speed = foundInitInfo.Speed
			newSpring.Damper = foundInitInfo.Damper
		end

		rawset(self, "_currentSpring", newSpring)

		return newSpring
	else
		local currentType = typeof(SpringUtils.fromLinearIfNeeded(currentSpring.Value))
		if currentType == typeof(SpringUtils.fromLinearIfNeeded(converted)) then
			return currentSpring
		else
			local oldDamper = currentSpring.d
			local oldSpeed = currentSpring.s
			local clock = currentSpring.Clock

			local newSpring = Spring.new(converted)
			newSpring.Clock = clock
			newSpring.Speed = oldSpeed
			newSpring.Damper = oldDamper
			rawset(self, "_currentSpring", newSpring)
			return newSpring
		end
	end
end

function SpringObject:_getInitInfo()
	local currentSpring = rawget(self, "_currentSpring")
	if currentSpring then
		error("Should not have currentSpring")
	end

	local foundInitInfo = rawget(self, "_initInfo")
	if foundInitInfo then
		return foundInitInfo
	end

	local value = {
		Clock = os.clock,
		Damper = 1,
		Speed = 1,
	}

	rawset(self, "_initInfo", value)

	return value
end

--[=[
	Cleans up the BaseObject and sets the metatable to nil
]=]
function SpringObject:Destroy()
	self._maid:DoCleaning()
	setmetatable(self, nil)
end

return SpringObject
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="53">
                <Properties>
                  <string name="Name">Test</string>
                </Properties>
                <Item class="ModuleScript" referent="54">
                  <Properties>
                    <string name="Name">BlendChildren.story</string>
                    <string name="Source"><![CDATA[--[[
	@class Blend.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local Maid = require("Maid")
local Rx = require("Rx")
local ValueObject = require("ValueObject")

return function(target)
	local maid = Maid.new()

	local percentVisible = Blend.State(0)
	local state = Blend.State("a")
	maid:GiveTask(state)

	local uiCornerValueObject = ValueObject.new()
	uiCornerValueObject.Value = Blend.New "UICorner" {
		CornerRadius = UDim.new(0, 5),
	}
	maid:GiveTask(uiCornerValueObject)

	-- Reassign to a new value
	maid:GiveTask(task.delay(1, function()
		uiCornerValueObject.Value = Blend.New "UICorner" {
			CornerRadius = UDim.new(0, 5),
		}
	end))

	local transparency = Blend.Computed(percentVisible, function(visible)
		return 1 - visible
	end)

	-- Try a kitchen sink of items
	maid:GiveTask((Blend.New "TextLabel" {
		Parent = target,
		Font = Enum.Font.FredokaOne,
		Size = Blend.Computed(percentVisible, function(visible)
			return UDim2.new(0, visible * 100 + 50, 0, 50)
		end),
		TextTransparency = transparency,
		BackgroundTransparency = transparency,
		Position = UDim2.new(0.5, 0, 0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Text = state,
		TextSize = 15,
		TextScaled = false,

		[Blend.Children] = {
			Blend.New "UIPadding" {
				PaddingLeft = UDim.new(0, 10),
				PaddingRight = UDim.new(0, 10),
				PaddingTop = UDim.new(0, 10),
				PaddingBottom = UDim.new(0, 10),
			},

			Blend.New "UIScale" {
				Scale = Blend.Computed(percentVisible, function(visible)
					return 0.8 + 0.2 * visible
				end),
			},

			uiCornerValueObject,

			Rx.NEVER,
			Rx.EMPTY,

			{
				Blend.Single(Blend.Computed(percentVisible, function(visible)
					if visible <= 0.5 then
						return nil
					else
						return Blend.New "Frame" {
							Size = UDim2.new(0, 150, 0, 30),
							AnchorPoint = Vector2.new(0.5, 0),
							Position = UDim2.new(0.5, 0, 1, 10),
							BackgroundTransparency = transparency,

							Blend.New "UICorner" {
								CornerRadius = UDim.new(0, 10),
							},
						}
					end
				end)),
			},

			{
				Blend.Single(Blend.Computed(percentVisible, function(visible)
					local results = {}

					-- constructs a ton of children everytime this changes
					for x = 0, visible * 100, 20 do
						table.insert(
							results,
							Blend.New "Frame" {
								Size = UDim2.new(0, 8, 0, 8),
								Position = UDim2.new(x / 100, 0, 0.9, 0),
								AnchorPoint = Vector2.new(0.5, 0.5),
								BorderSizePixel = 0,
								BackgroundColor3 = Color3.new(x / 100, 0.5, 0.5),
								BackgroundTransparency = transparency,

								[Blend.Children] = {
									Blend.New "UICorner" {
										CornerRadius = UDim.new(0, 10),
									},
								},
							}
						)
					end

					return results
				end)),
			},
		},
	}):Subscribe())

	local PERIOD = 5
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		local timeElapsed = os.clock()
		state.Value = string.format(
			"%02d:%02d:%0.3d",
			math.floor(timeElapsed / 60) % 60,
			math.floor(timeElapsed % 60),
			math.floor(timeElapsed * 1000) % 1000
		)
		percentVisible.Value = math.clamp((math.sin(os.clock() * math.pi * 2 / PERIOD) + 1), 0, 1)
	end))

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="55">
                  <Properties>
                    <string name="Name">BlendComputePairs.story</string>
                    <string name="Source"><![CDATA[--[[
	@class Blend.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Blend = require("Blend")
local Maid = require("Maid")

return function(target)
	local maid = Maid.new()

	local state = Blend.State({ "a", "b", "c" })
	maid:GiveTask(state)

	maid:GiveTask((Blend.New "TextLabel" {
		Parent = target,

		[Blend.Children] = {
			Blend.New "TextButton" {
				Text = "Add",
				AutoButtonColor = true,
				Size = UDim2.new(0, 100, 0, 20),
				[Blend.OnEvent "Activated"] = function()
					local newState = {}
					for _, item in state.Value do
						table.insert(newState, item)
					end
					table.insert(newState, string.char(string.byte("a") + #newState))
					state.Value = newState
				end,
			},
			Blend.ComputedPairs(state, function(_index, value)
				print("Compute", value)
				return Blend.New "TextLabel" {
					Text = tostring(value),
					Size = UDim2.new(0, 20, 0, 20),
				}
			end),

			Blend.New "UIListLayout" {
				Padding = UDim.new(0, 5),
			},
		},
	}):Subscribe())

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="56">
                  <Properties>
                    <string name="Name">BlendFind.story</string>
                    <string name="Source"><![CDATA[--[[
	@class Blend.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local Maid = require("Maid")

return function(target)
	local maid = Maid.new()

	local isVisible = Instance.new("BoolValue")
	isVisible.Value = false

	local percentVisible = Blend.Spring(
		Blend.Computed(isVisible, function(visible)
			return visible and 1 or 0
		end),
		35
	)

	local transparency = Blend.Computed(percentVisible, function(percent)
		return 1 - percent
	end)

	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0.5, 0, 0.5, 0)
	frame.BackgroundColor3 = Color3.new(0.9, 0.9, 0.9)
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	frame.BackgroundTransparency = transparency
	frame.Parent = target
	maid:GiveTask(frame)

	local subFrame = Instance.new("Frame")
	subFrame.Name = "CenterFrame"
	subFrame.Size = UDim2.new(0.5, 0, 0.5, 0)
	subFrame.BackgroundColor3 = Color3.new(0.5, 0.5, 0.5)
	subFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	subFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	subFrame.BackgroundTransparency = transparency
	subFrame.Parent = frame

	local uiScale = Instance.new("UIScale")
	uiScale.Name = "MyUIScale"
	uiScale.Parent = subFrame

	maid:GiveTask(Blend.mount(frame, {
		Size = UDim2.new(0.5, 0, 0.5, 0),

		Blend.New "UICorner" {
			CornerRadius = UDim.new(0.05, 0),
		},

		Blend.Find "Frame" {
			Name = "CenterFrame",

			Blend.Find "UIScale" {
				Name = "MyUIScale",

				Scale = Blend.Computed(percentVisible, function(percent)
					return 0.8 + 0.2 * percent
				end),
			},

			Blend.New "UICorner" {
				CornerRadius = UDim.new(0.05, 0),
			},
		},
	}))

	local PERIOD = 2
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		isVisible.Value = os.clock() / PERIOD % 1 < 0.5
	end))

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="57">
                  <Properties>
                    <string name="Name">BlendPromise.story</string>
                    <string name="Source"><![CDATA[--[[
	@class BlendTextbox.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local Maid = require("Maid")
local PlayerThumbnailUtils = require("PlayerThumbnailUtils")

return function(target)
	local maid = Maid.new()

	local userIdState = Instance.new("IntValue")
	userIdState.Value = 4397833
	maid:GiveTask(userIdState)

	local isVisible = Instance.new("BoolValue")
	isVisible.Value = false
	maid:GiveTask(isVisible)

	local userImage = Blend.Dynamic(userIdState, function(userId)
		return PlayerThumbnailUtils.promiseUserThumbnail(userId)
	end)
	local userName = Blend.Dynamic(userIdState, function(userId)
		return PlayerThumbnailUtils.promiseUserName(userId)
	end)
	local percentVisible = Blend.Spring(
		Blend.Computed(isVisible, function(visible)
			return visible and 1 or 0
		end),
		35
	)
	local transparency = Blend.Computed(percentVisible, function(percent)
		return 1 - percent
	end)

	maid:GiveTask((Blend.New "Frame" {
		Parent = target,
		Name = "ProfileImage",
		LayoutOrder = 15,
		BackgroundTransparency = 1,
		Size = UDim2.new(0, 100, 0, 130),
		Position = UDim2.fromScale(0.5, 0.5),
		AnchorPoint = Vector2.new(0.5, 0.5),
		[Blend.Children] = {
			Blend.New "UIScale" {
				Scale = Blend.Computed(percentVisible, function(percent)
					return 0.8 + 0.2 * percent
				end),
			},

			Blend.New "TextLabel" {
				Size = UDim2.new(1, 0, 0, 30),
				Position = UDim2.new(0.5, 0, 1, 0),
				AnchorPoint = Vector2.new(0.5, 1),
				BackgroundTransparency = 1,
				TextTransparency = transparency,
				TextColor3 = Color3.new(1, 1, 1),
				TextSize = 20,
				Font = Enum.Font.Gotham,
				Text = userName,
			},

			Blend.New "Frame" {
				Position = UDim2.new(0.5, 0, 0, 0),
				AnchorPoint = Vector2.new(0.5, 0),
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundColor3 = Color3.new(0.2, 0.25, 0.2),
				BackgroundTransparency = transparency,
				[Blend.Children] = {
					Blend.New "UIAspectRatioConstraint" {
						AspectRatio = 1,
					},
					Blend.New "UICorner" {
						CornerRadius = UDim.new(1, 0),
					},
					Blend.New "UIPadding" {
						PaddingLeft = UDim.new(0, 2),
						PaddingRight = UDim.new(0, 2),
						PaddingTop = UDim.new(0, 2),
						PaddingBottom = UDim.new(0, 2),
					},

					Blend.New "ImageLabel" {
						Size = UDim2.new(1, 0, 1, 0),
						Image = userImage,
						BackgroundTransparency = transparency,
						ImageTransparency = transparency,
						BackgroundColor3 = Color3.new(0.1, 0.1, 0.1),

						[Blend.Children] = {
							Blend.New "UICorner" {
								CornerRadius = UDim.new(1, 0),
							},
						},
					},
				},
			},
		},
	}):Subscribe())

	local PERIOD = 2
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		isVisible.Value = os.clock() / PERIOD % 1 < 0.5
	end))

	local alive = true
	maid:GiveTask(function()
		alive = false
	end)
	maid:GiveTask(isVisible.Changed:Connect(function()
		if not isVisible.Value then
			task.delay(PERIOD / 2, function()
				if alive then
					userIdState.Value = Random.new():NextInteger(1, 1e9)
				end
			end)
		end
	end))

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="58">
                  <Properties>
                    <string name="Name">BlendSingle.story</string>
                    <string name="Source"><![CDATA[--[[
	@class BlendSingle.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Blend = require("Blend")
local Maid = require("Maid")
local Observable = require("Observable")

return function(target)
	local maid = Maid.new()

	local state = Blend.State("a")

	local result = Blend.Single(Blend.Dynamic(state, function(text)
		return Blend.New "TextLabel" {
			Parent = target,
			Text = text,
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 0.5,
			[function()
				return Observable.new(function()
					local internal = Maid.new()

					print("Made for", text)
					internal:GiveTask(function()
						print("Cleaning up", text)
					end)

					return internal
				end)
			end] = true,
		}
	end))

	maid:GiveTask(result:Subscribe())

	state.Value = "b"

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="59">
                  <Properties>
                    <string name="Name">BlendSpring.story</string>
                    <string name="Source"><![CDATA[--[[
	@class Blend.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local Maid = require("Maid")

return function(target)
	local maid = Maid.new()

	local isVisible = Instance.new("BoolValue")
	isVisible.Value = false

	local percentVisible = Blend.Spring(
		Blend.Computed(isVisible, function(visible)
			return visible and 1 or 0
		end),
		35
	)

	local transparency = Blend.Computed(percentVisible, function(percent)
		return 1 - percent
	end)

	maid:GiveTask((Blend.New "Frame" {
		Size = UDim2.new(0.5, 0, 0.5, 0),
		BackgroundColor3 = Color3.new(0.9, 0.9, 0.9),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5, 0, 0.5, 0),
		BackgroundTransparency = transparency,
		Parent = target,

		[Blend.Children] = {
			Blend.New "UIScale" {
				Scale = Blend.Computed(percentVisible, function(percent)
					return 0.8 + 0.2 * percent
				end),
			},
			Blend.New "UICorner" {
				CornerRadius = UDim.new(0.05, 0),
			},
		},
	}):Subscribe())

	local PERIOD = 5
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		isVisible.Value = os.clock() / PERIOD % 1 < 0.5
	end))

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="60">
                  <Properties>
                    <string name="Name">BlendTextbox.story</string>
                    <string name="Source"><![CDATA[--[[
	@class BlendTextbox.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Blend = require("Blend")
local Maid = require("Maid")

return function(target)
	local maid = Maid.new()

	local state = Blend.State("hi")

	maid:GiveTask((Blend.New "Frame" {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
		Parent = target,

		[Blend.Children] = {
			Blend.New "TextBox" {
				Size = UDim2.new(0, 200, 0, 50),
				Text = state,
				[Blend.OnChange "Text"] = state,
				[Blend.OnEvent "Focused"] = function()
					print("Focused")
				end,

				[function(inst)
					return inst.Focused
				end] = function()
					print("Focused (via func)")
				end,

				-- this also works
				[function(inst)
					return inst:GetPropertyChangedSignal("Text")
				end] = function()
					print("Property changed from :GetPropertyChangedSignal()")
				end,
			},

			Blend.New "TextBox" {
				Size = UDim2.new(0, 200, 0, 50),
				[Blend.OnChange "Text"] = state, -- read state
				Text = state, -- write state
			},

			Blend.New "UIListLayout" {
				Padding = UDim.new(0, 10),
			},
		},
	}):Subscribe())

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="61">
            <Properties>
              <string name="Name">brio</string>
            </Properties>
            <Item class="Folder" referent="62">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="63">
                <Properties>
                  <string name="Name">Brio</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Brios wrap a value (or tuple of values) and are used to convey the lifetime of that
	object. The brio is better than a maid, by providing the following constraints:

	- Can be in 2 states, dead or alive.
	- While alive, can retrieve values.
	- While dead, retrieving values is forbidden.
	- Died will fire once upon death.

	Brios encapsulate the "lifetime" of a valid resource. Unlike a maid, they
	- Can only die once, ensuring duplicate calls never occur.
	- Have less memory leaks. Memory leaks in maids can occur when use of the maid occurs
	  after the cleanup of the maid has occured, in certain race conditions.
	- Cannot be reentered, i.e. cannot retrieve values after death.

	:::info
	Calling `brio:Destroy()` or `brio:Kill()` after death does nothing. Brios cannot
	be resurrected.
	:::

	Brios are useful for downstream events where you want to emit a resource. Typically
	brios should be killed when their source is killed. Brios are intended to be merged
	with downstream brios so create a chain of reliable resources.

	```lua
	local brio = Brio.new("a", "b")
	print(brio:GetValue()) --> a b
	print(brio:IsDead()) --> false

	brio:GetDiedSignal():Connect(function()
		print("Hello from signal!")
	end)
	brio:ToMaid():GiveTask(function()
		print("Hello from maid cleanup!")
	end)
	brio:Kill()
	--> Hello from signal!
	--> Hello from maid cleanup!

	print(brio:IsDead()) --> true
	print(brio:GetValue()) --> ERROR: Brio is dead
	```

	## Design philosophy

	Brios are designed to solve this issue where we emit an object with a lifetime associated with it from an
	Observable stream. This resource is only valid for some amount of time (for example, while the object is
	in the Roblox data model).

	In order to know how long we can keep this object/use it, we wrap the object with a Brio, which denotes
	 the lifetime of the object.

	Modeling this with pure observables is very tricky because the subscriber will have to also monitor/emit
	a similar object with less clear conventions. For example  an observable that emits the object, and then nil on death.

	@class Brio
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Signal = require("Signal")

local Brio = {}
Brio.__index = Brio
Brio.ClassName = "Brio"

export type Brio<T...> = typeof(setmetatable(
	{} :: {
		n: number?,
		_diedEvent: Signal.Signal<T...>,
	},
	{} :: typeof({ __index = Brio })
))

--[=[
	Returns whether a value is a Brio.

	```lua
	print(Brio.isBrio("yolo")) --> false
	```
	@param value any
	@return boolean
]=]
function Brio.isBrio(value: any): boolean
	return type(value) == "table" and value.ClassName == "Brio"
end

--[=[
	Constructs a new Brio.

	```lua
	local brio = Brio.new("a", "b")
	print(brio:GetValue()) --> a b
	```

	@param ... any -- Brio values
	@return Brio
]=]
function Brio.new<T...>(...: T...): Brio<T...>
	return setmetatable(table.pack(...) :: any, Brio)
end

--[=[
	Constructs a new brio that will cleanup afer the set amount of time

	@since 3.6.0
	@param time number
	@param ... any -- Brio values
	@return Brio
]=]
function Brio.delayed<T...>(time: number, ...: T...): Brio<T...>
	local brio: Brio<T...> = Brio.new(...)
	task.delay(time, function()
		brio:Kill()
	end)
	return brio
end

--[=[
	Gets a signal that will fire when the Brio dies. If the brio is already dead
	calling this method will error.

	:::info
	Calling this while the brio is already dead will throw a error.
	:::

	```lua
	local brio = Brio.new("a", "b")
	brio:GetDiedSignal():Connect(function()
		print("Brio died")
	end)

	brio:Kill() --> Brio died
	brio:Kill() -- no output
	```

	@return Signal
]=]
function Brio.GetDiedSignal<T...>(self: Brio<T...>): Signal.Signal<T...>
	if self:IsDead() then
		error("Brio is dead")
	end

	if self._diedEvent then
		return self._diedEvent
	end

	local diedEvent = Signal.new()
	self._diedEvent = diedEvent
	return diedEvent
end

--[=[
	Returns true is the brio is dead.

	```lua
	local brio = Brio.new("a", "b")
	print(brio:IsDead()) --> false

	brio:Kill()

	print(brio:IsDead()) --> true
	```

	@return boolean
]=]
function Brio.IsDead<T...>(self: Brio<T...>): boolean
	return self.n == nil
end

--[=[
	Throws an error if the Brio is dead.

	```lua
	brio.DEAD:ErrorIfDead() --> ERROR: [Brio.ErrorIfDead] - Brio is dead
	```
]=]
function Brio.ErrorIfDead<T...>(self: Brio<T...>)
	if not self.n then
		error("[Brio.ErrorIfDead] - Brio is dead")
	end
end

--[=[
	Constructs a new Maid which will clean up when the brio dies.
	Will error if the Brio is dead.

	:::info
	Calling this while the brio is already dead will throw a error.
	:::

	```lua
	local brio = Brio.new("a")
	local maid = brio:ToMaid()
	maid:GiveTask(function()
		print("Cleaning up!")
	end)
	brio:Kill() --> Cleaning up!
	```

	@return Maid
]=]
function Brio.ToMaid<T...>(self: Brio<T...>): Maid.Maid
	assert(self.n ~= nil, "Brio is dead")

	local maid = Maid.new()

	maid:GiveTask(self:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return maid
end

function Brio.ToMaidAndValue<T...>(self: Brio<T...>): (any, T...)
	return self:ToMaid(), self:GetValue()
end

--[=[
	If the brio is not dead, will return the values unpacked from the brio.

	:::info
	Calling this while the brio is already dead will throw a error. Values should
	not be used past the lifetime of the brio, and can be considered invalid.
	:::

	```lua
	local brio = Brio.new("a", 1, 2)
	print(brio:GetValue()) --> "a" 1 2
	brio:Kill()

	print(brio:GetValue()) --> ERROR: Brio is dead
	```

	@return any
]=]
function Brio.GetValue<T...>(self: Brio<T...>): T...
	assert(self.n, "Brio is dead")

	return unpack(self :: any, 1, self.n)
end

--[=[
	Returns the packed values from table.pack() format

	@since 3.6.0
	@return { n: number, ... T }
]=]
function Brio.GetPackedValues<T...>(self: Brio<T...>)
	assert(self.n, "Brio is dead")

	return self
end

--[=[
	Kills the Brio.

	:::info
	You can call this multiple times and it will not error if the brio is dead.
	:::

	```lua
	local brio = Brio.new("hi")
	print(brio:GetValue()) --> "hi"
	brio:Kill()

	print(brio:GetValue()) --> ERROR: Brio is dead
	```
]=]
function Brio.Destroy<T...>(self: Brio<T...>)
	if not self.n then
		return
	end

	local diedEvent: any = self._diedEvent

	table.clear(self :: any)
	table.freeze(self)

	if diedEvent then
		diedEvent:Fire()
		diedEvent:Destroy()
		diedEvent = nil
	end
end

--[=[
	Alias for Destroy.
	@method Kill
	@within Brio
]=]
Brio.Kill = Brio.Destroy

--[=[
	An already dead brio which may be used for identity purposes.

	```lua
	print(Brio.DEAD:IsDead()) --> true
	```

	@prop DEAD Brio
	@within Brio
]=]
Brio.DEAD = Brio.new() :: Brio<...any>
Brio.DEAD:Kill()

return Brio
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="64">
                <Properties>
                  <string name="Name">BrioUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions affecting Brios.
	@class BrioUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Table = require("Table")

local BrioUtils = {}

--[=[
	Clones a brio, such that it may be killed without affecting the original
	brio.

	@param brio Brio<T>
	@return Brio<T>
]=]
function BrioUtils.clone<T...>(brio: Brio.Brio<T...>): Brio.Brio<T...>
	assert(brio, "Bad brio")

	if brio:IsDead() then
		return Brio.DEAD :: any
	end

	local newBrio = Brio.new(brio:GetValue())

	local connection
	local otherConnection
	connection = brio:GetDiedSignal():Connect(function()
		connection:Disconnect()
		otherConnection:Disconnect()
		newBrio:Kill()
	end)

	otherConnection = newBrio:GetDiedSignal():Connect(function()
		otherConnection:Disconnect()
		connection:Disconnect()
	end)

	return newBrio
end

--[=[
	Returns a list of alive Brios only

	@param brios {Brio<T>}
	@return {Brio<T>}
]=]
function BrioUtils.aliveOnly<T...>(brios: { Brio.Brio<T...> }): { Brio.Brio<T...> }
	local alive: { Brio.Brio<T...> } = {}
	for _, brio: any in brios do
		if not brio:IsDead() then
			table.insert(alive, brio)
		end
	end
	return alive
end

--[=[
	Returns the first alive Brio in a list

	@param brios {Brio<T>}
	@return Brio<T>
]=]
function BrioUtils.firstAlive<T...>(brios: { Brio.Brio<T...> }): Brio.Brio<T...>?
	for _, brio: any in brios do
		if not brio:IsDead() then
			return brio
		end
	end
	return nil
end

--[=[
	Given a list of brios of brios, flattens that list into a brio with
	just one T value.

	@param brioTable { any: Brio<T> | T }
	@return Brio<{T}>
]=]
function BrioUtils.flatten<K, T>(brioTable: Table.Map<K, Brio.Brio<T> | T>): Brio.Brio<Table.Map<K, T>>
	local newValue = {}
	local brios = {}

	for key, brio: any in brioTable do
		if Brio.isBrio(brio) then
			if brio:IsDead() then
				return Brio.DEAD :: any
			else
				table.insert(brios, brio)
				newValue[key] = brio:GetValue()
			end
		else
			newValue[key] = brio
		end
	end

	return BrioUtils.first(brios, newValue)
end

--[=[
	Returns a brio that dies whenever the first Brio in the list
	dies. The value of the Brio is the `...` value.

	@param brios {Brio<T>}
	@param ... U...
	@return Brio<U>
]=]
function BrioUtils.first<T..., U...>(brios: { Brio.Brio<T...> }, ...: U...): Brio.Brio<U...>
	for _, brio: any in brios do
		if Brio.isBrio(brio) then
			if brio:IsDead() then
				return Brio.DEAD :: any
			end
		end
	end

	local maid = Maid.new()
	local topBrio = Brio.new(...)

	for _, brio: any in brios do
		if Brio.isBrio(brio) then
			maid:GiveTask(brio:GetDiedSignal():Connect(function()
				topBrio:Kill()
			end))
		end
	end

	maid:GiveTask(topBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return topBrio
end

--[=[
	Clones a brio, such that it may be killed without affecting the original
	brio.

	@since 3.6.0
	@param brio Brio<T>
	@param ... U
	@return Brio<U>
]=]
function BrioUtils.withOtherValues<T..., U...>(brio: Brio.Brio<T...>, ...: U...): Brio.Brio<U...>
	assert(brio, "Bad brio")

	if brio:IsDead() then
		return Brio.DEAD :: any
	end

	local newBrio = Brio.new(...)

	newBrio:ToMaid():GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	return newBrio
end

--[=[
	Makes a brio that is limited by the lifetime of its parent (but could be shorter)
	and has the new values given.

	@param brio Brio<U>
	@param ... T
	@return Brio<T>
]=]
function BrioUtils.extend(brio, ...)
	if brio:IsDead() then
		return Brio.DEAD
	end

	local values = brio:GetPackedValues()
	local current = {}
	for i = 1, values.n do
		current[i] = values[i]
	end
	local otherValues = table.pack(...)
	for i = 1, otherValues.n do
		current[values.n + i] = otherValues[i]
	end

	local maid = Maid.new()
	local newBrio = Brio.new(unpack(current, 1, values.n + otherValues.n))

	maid:GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	maid:GiveTask(newBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return newBrio
end

--[=[
	Makes a brio that is limited by the lifetime of its parent (but could be shorter)
	and has the new values given at the beginning of the result

	@since 3.6.0
	@param brio Brio<U>
	@param ... T
	@return Brio<T>
]=]
function BrioUtils.prepend(brio, ...)
	if brio:IsDead() then
		return Brio.DEAD
	end

	local values = brio:GetPackedValues()
	local current = {}
	local otherValues = table.pack(...)
	for i = 1, otherValues.n do
		current[i] = otherValues[i]
	end
	for i = 1, values.n do
		current[otherValues.n + i] = values[i]
	end

	local maid = Maid.new()
	local newBrio = Brio.new(unpack(current, 1, values.n + otherValues.n))

	maid:GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	maid:GiveTask(newBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return newBrio
end

--[=[
	Merges the existing brio value with the other brio

	@param brio Brio<{T}>
	@param otherBrio Brio<{U}>
	@return Brio<{T | U}>
]=]
function BrioUtils.merge<T, U>(brio: Brio.Brio<T>, otherBrio: Brio.Brio<U>): Brio.Brio<T & U>
	assert(Brio.isBrio(brio), "Not a brio")
	assert(Brio.isBrio(otherBrio), "Not a brio")

	if brio:IsDead() or otherBrio:IsDead() then
		return Brio.DEAD :: any
	end

	local values = brio:GetPackedValues()
	local current = {}
	for i = 1, values.n do
		current[i] = values[i]
	end

	local otherValues = otherBrio:GetPackedValues()
	for i = 1, otherValues.n do
		current[values.n + i] = otherValues[i]
	end

	local maid = Maid.new()
	local newBrio: Brio.Brio<T & U> = Brio.new(unpack(current, 1, values.n + otherValues.n)) :: any

	maid:GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))
	maid:GiveTask(otherBrio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	maid:GiveTask(newBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return newBrio
end

return BrioUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="65">
                <Properties>
                  <string name="Name">BrioUtils.spec</string>
                  <string name="Source"><![CDATA[--[[
	Unit tests for BrioUtils.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Brio = require("Brio")
local BrioUtils = require("BrioUtils")
local Jest = require("Jest")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("BrioUtils.flatten({})", function()
	local brio = BrioUtils.flatten({})

	describe("should return a brio that", function()
		it("is a brio", function()
			expect(brio).toEqual(expect.any("table"))
			expect(Brio.isBrio(brio)).toEqual(true)
		end)

		it("is alive", function()
			expect(not brio:IsDead()).toEqual(true)
		end)

		it("contains a table", function()
			expect(brio:GetValue()).toEqual(expect.any("table"))
		end)

		it("contains a table with nothing in it", function()
			expect(next(brio:GetValue())).toEqual(nil)
		end)
	end)
end)

describe("BrioUtils.flatten with out a brio in it", function()
	local brio = BrioUtils.flatten({
		value = 5,
	})

	describe("should return a brio that", function()
		it("is a brio", function()
			expect(brio).toEqual(expect.any("table"))
			expect(Brio.isBrio(brio)).toEqual(true)
		end)

		it("is alive", function()
			expect(not brio:IsDead()).toEqual(true)
		end)

		it("contains a table", function()
			expect(brio:GetValue()).toEqual(expect.any("table"))
		end)

		it("contains a table with value", function()
			expect(brio:GetValue().value).toEqual(5)
		end)
	end)
end)

describe("BrioUtils.flatten a dead brio in it", function()
	local brio = BrioUtils.flatten({
		value = Brio.DEAD,
	})

	describe("should return a brio that", function()
		it("is a brio", function()
			expect(brio).toEqual(expect.any("table"))
			expect(Brio.isBrio(brio)).toEqual(true)
		end)

		it("is dead", function()
			expect(brio:IsDead()).toEqual(true)
		end)
	end)
end)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="66">
                <Properties>
                  <string name="Name">RxBrioUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions involving brios and rx. Brios encapsulate the lifetime of resources,
	which could be expired by the time a subscription occurs. These functions allow us to
	manipulate the state of these at a higher order.

	@class RxBrioUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local BrioUtils = require("BrioUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")

local RxBrioUtils = {}

--[=[
	Creates a new observable wrapping the brio with the brio lasting for the lifetime of the observable

	@param callback ((Maid.Maid) -> T) | T
	@return Observable<Brio<T>>
]=]
function RxBrioUtils.ofBrio<T>(callback: ((Maid.Maid) -> T) | T): Observable.Observable<Brio.Brio<T>>
	return Observable.new(function(sub)
		local maid = Maid.new()

		if type(callback) == "function" then
			local brio = maid:Add(Brio.new(callback(maid)))
			sub:Fire(brio)
		else
			local brio = maid:Add(Brio.new(callback))
			sub:Fire(brio)
		end

		return maid
	end) :: any
end

--[=[
	Takes a result and converts it to a brio if it is not one.

	@return (source: Observable<Brio<T> | T>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.toBrio<T>(): Observable.Transformer<(Brio.Brio<T> | T), (Brio.Brio<T>)>
	return Rx.map(function(result)
		if Brio.isBrio(result) then
			return result
		end

		return Brio.new(result)
	end) :: any
end

--[=[
	Same as [Rx.of] but wraps it in a Brio.

	@param ... T
	@return Observable<Brio<T>>
]=]
function RxBrioUtils.of<T...>(...: T...): Observable.Observable<Brio.Brio<T...>>
	return Rx.of(...):Pipe({
		RxBrioUtils.toBrio() :: any,
	}) :: any
end

--[=[
	Completes the observable on death

	@param brio Brio
	@param observable Observable<T>
	@return Observable<T>
]=]
function RxBrioUtils.completeOnDeath<T...>(
	brio: Brio.Brio<...any>,
	observable: Observable.Observable<T...>
): Observable.Observable<T...>
	assert(Brio.isBrio(brio))
	assert(Observable.isObservable(observable))

	return Observable.new(function(sub)
		if brio:IsDead() then
			sub:Complete()
			return
		end

		local maid = brio:ToMaid()

		maid:GiveTask(function()
			sub:Complete()
		end)
		maid:GiveTask(observable:Subscribe(sub:GetFireFailComplete()))

		return maid
	end)
end

--[=[
	Whenever all returned brios are dead, emits this value wrapped
	in a brio.

	@param valueToEmitWhileAllDead T
	@return (source: Observable<Brio<U>>) -> Observable<Brio<U | T>>
]=]
function RxBrioUtils.emitWhileAllDead(valueToEmitWhileAllDead)
	return function(source)
		return Observable.new(function(sub)
			local topMaid = Maid.new()

			local subscribed = true
			topMaid:GiveTask(function()
				subscribed = false
			end)
			local aliveBrios = {}
			local fired = false

			local function updateBrios()
				if not subscribed then -- No work if we don't need to.
					return
				end

				aliveBrios = BrioUtils.aliveOnly(aliveBrios)
				if next(aliveBrios) then
					topMaid._lastBrio = nil
				else
					local newBrio = Brio.new(valueToEmitWhileAllDead)
					topMaid._lastBrio = newBrio
					sub:Fire(newBrio)
				end

				fired = true
			end

			local function handleNewBrio(brio)
				-- Could happen due to throttle or delay...
				if brio:IsDead() then
					return
				end

				local maid = Maid.new()
				topMaid[maid] = maid -- Use maid as key so it's unique (reemitted brio)

				maid:GiveTask(function() -- GC properly
					topMaid[maid] = nil
					updateBrios()
				end)
				maid:GiveTask(brio:GetDiedSignal():Connect(function()
					topMaid[maid] = nil
				end))

				table.insert(aliveBrios, brio)
				updateBrios()
			end

			topMaid:GiveTask(source:Subscribe(function(brio)
				if not Brio.isBrio(brio) then
					warn(string.format("[RxBrioUtils.emitWhileAllDead] - Not a brio, %q", tostring(brio)))
					topMaid._lastBrio = nil
					sub:Fail("Not a brio")
					return
				end

				handleNewBrio(brio)
			end, function(...)
				sub:Fail(...)
			end, function(...)
				sub:Complete(...)
			end))

			-- Make sure we emit an empty list if we discover nothing
			if not fired then
				updateBrios()
			end

			return topMaid
		end)
	end
end

--[=[
	This can't be cheap. Consider deeply if you want this or not.

	@param selectFromBrio ((value: T) -> U)?
	@return (source: Observable<Brio<T>>) -> Observable<Brio{U}>
]=]
function RxBrioUtils.reduceToAliveList(selectFromBrio: any?)
	assert(type(selectFromBrio) == "function" or selectFromBrio == nil, "Bad selectFromBrio")

	return function(source)
		return Observable.new(function(sub)
			local topMaid = Maid.new()

			local subscribed = true
			topMaid:GiveTask(function()
				subscribed = false
			end)
			local aliveBrios: { Brio.Brio<any> } = {}
			local fired = false

			local function updateBrios()
				if not subscribed then -- No work if we don't need to.
					return
				end

				aliveBrios = BrioUtils.aliveOnly(aliveBrios)
				local values = {}
				if selectFromBrio then
					for _, brio: any in aliveBrios do
						-- Hope for no side effects
						local value = selectFromBrio(brio:GetValue())
						assert(value ~= nil, "Bad value")

						table.insert(values, value)
					end
				else
					for _, brio: any in aliveBrios do
						local value = brio:GetValue()
						assert(value ~= nil, "Bad value")

						table.insert(values, value)
					end
				end

				local newBrio = BrioUtils.first(aliveBrios, values)
				topMaid._lastBrio = newBrio

				fired = true
				sub:Fire(newBrio)
			end

			local function handleNewBrio(brio)
				-- Could happen due to throttle or delay...
				if brio:IsDead() then
					return
				end

				local maid = Maid.new()
				topMaid[maid] = maid -- Use maid as key so it's unique (reemitted brio)

				maid:GiveTask(function() -- GC properly
					topMaid[maid] = nil
					updateBrios()
				end)
				maid:GiveTask(brio:GetDiedSignal():Connect(function()
					topMaid[maid] = nil
				end))

				table.insert(aliveBrios, brio)
				updateBrios()
			end

			topMaid:GiveTask(source:Subscribe(function(brio)
				if not Brio.isBrio(brio) then
					warn(string.format("[RxBrioUtils.mergeToAliveList] - Not a brio, %q", tostring(brio)))
					topMaid._lastBrio = nil
					sub:Fail("Not a brio")
					return
				end

				handleNewBrio(brio)
			end, function(...)
				sub:Fail(...)
			end, function(...)
				sub:Complete(...)
			end))

			-- Make sure we emit an empty list if we discover nothing
			if not fired then
				updateBrios()
			end

			return topMaid
		end)
	end
end

--[=[
	Whenever the last brio dies, reemit it as a dead brio

	@return (source Observable<Brio<T>>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.reemitLastBrioOnDeath()
	return function(source)
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(brio)
				maid._conn = nil

				if not Brio.isBrio(brio) then
					warn(string.format("[RxBrioUtils.reemitLastBrioOnDeath] - Not a brio, %q", tostring(brio)))
					sub:Fail("Not a brio")
					return
				end

				if brio:IsDead() then
					sub:Fire(brio)
					return
				end

				-- Setup conn!
				maid._conn = brio:GetDiedSignal():Connect(function()
					sub:Fire(brio)
				end)

				sub:Fire(brio)
			end, function(...)
				sub:Fail(...)
			end, function(...)
				sub:Complete(...)
			end))

			return maid
		end)
	end
end

--[=[
	Unpacks the brio, and then repacks it. Ignored items
	still invalidate the previous brio

	@since 3.6.0
	@param predicate (T) -> boolean
	@return (source: Observable<Brio<T>>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.where<T>(predicate: Rx.Predicate<T>)
	assert(type(predicate) == "function", "Bad predicate")
	return function(source)
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(brio)
				assert(Brio.isBrio(brio), "Not a brio")
				if brio:IsDead() then
					return
				end

				if predicate(brio:GetValue()) then
					sub:Fire(brio)
				end
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Same as [RxBrioUtils.where]. Here to keep backwards compatability.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@function filter
	@param predicate (T) -> boolean
	@return (source: Observable<Brio<T>>) -> Observable<Brio<T>>
	@within RxBrioUtils
]=]
RxBrioUtils.filter = RxBrioUtils.where

--[=[
	Flattens all the brios in one brio and combines them. Note that this method leads to
	gaps in the lifetime of the brio.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param observables { [any]: Observable<Brio<T>> | Observable<T> | T }
	@return Observable<Brio<{ [any]: T }>>
]=]
function RxBrioUtils.combineLatest(observables)
	assert(type(observables) == "table", "Bad observables")

	warn("[RxBrioUtils.combineLatest] - Deprecated since 3.6.0. Use RxBrioUtils.flatCombineLatest")

	return Rx.combineLatest(observables):Pipe({
		Rx.map(BrioUtils.flatten) :: any,
		RxBrioUtils.onlyLastBrioSurvives() :: any,
	})
end

--[=[
	Flattens all the brios in one brio and combines them, and then switches it to
	a brio so only the last state is valid.

	@param observables { [any]: Observable<Brio<T>> | Observable<T> | T }
	@param filter function | nil
	@return Observable<Brio<{ [any]: T }>>
]=]
function RxBrioUtils.flatCombineLatestBrio<T>(observables, filter: Rx.Predicate<T>?)
	assert(type(observables) == "table", "Bad observables")

	return RxBrioUtils.flatCombineLatest(observables):Pipe({
		RxBrioUtils.switchToBrio() :: any,
		filter and RxBrioUtils.where(filter) :: any or nil :: never,
	})
end

--[=[
	Flat map equivalent for brios. The resulting observables will
	be disconnected at the end of the brio.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param project (value: TBrio) -> TProject
	@return (source: Observable<Brio<TBrio>> -> Observable<TResult>)
]=]
function RxBrioUtils.flatMap(project)
	assert(type(project) == "function", "Bad project")

	warn("[RxBrioUtils.flatMap] - Deprecated since 3.6.0. Use RxBrioUtils.flatMapBrio")

	return Rx.flatMap(RxBrioUtils.mapBrio(project) :: any)
end

--[=[
	Flat map equivalent for brios. The resulting observables will
	be disconnected at the end of the brio.

	Like [RxBrioUtils.flatMap], but emitted values are wrapped in brios.
	The lifetime of this brio is limited by the lifetime of the
	input brios, which are unwrapped and repackaged.

	@since 3.6.0
	@param project (value: TBrio) -> TProject | Brio<TProject>
	@return (source: Observable<Brio<TBrio>> -> Observable<Brio<TResult>>)
]=]
function RxBrioUtils.flatMapBrio(project)
	return Rx.flatMap(RxBrioUtils.mapBrioBrio(project) :: any)
end

--[=[
	Switch map but for brios. The resulting observable will be
	disconnected on the end of the brio's life.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param project (value: TBrio) -> TProject
	@return (source: Observable<Brio<TBrio>>) -> Observable<TResult>
]=]
function RxBrioUtils.switchMap(project)
	assert(type(project) == "function", "Bad project")

	warn("[RxBrioUtils.switchMap] - Deprecated since 3.6.0. Use RxBrioUtils.switchMapBrio")

	return Rx.switchMap(RxBrioUtils.mapBrio(project) :: any)
end

--[=[
	Switch map but for brios. The resulting observable will be
	disconnected on the end of the brio's life.

	Like [RxBrioUtils.switchMap] but emitted values are wrapped in brios.
	The lifetime of this brio is limited by the lifetime of the
	input brios, which are unwrapped and repackaged.

	@since 3.6.0
	@param project (value: TBrio) -> TProject | Brio<TProject>
	@return (source: Observable<Brio<TBrio>>) -> Observable<Brio<TResult>>
]=]
function RxBrioUtils.switchMapBrio(project)
	assert(type(project) == "function", "Bad project")

	return Rx.switchMap(RxBrioUtils.mapBrioBrio(project) :: any)
end

--[=[
	Works line combineLatest, but allow the transformation of a brio into an observable
	that emits the value, and then nil, on death.

	The issue here is this:

	1. Resources are found with combineLatest()
	2. One resource dies
	3. All resources are invalidated
	4. We still wanted to be able to use most of the resources

	With this method we are able to do this, as we'll re-emit a table with all resoruces
	except the invalidated one.

	@since 3.6.0
	@param observables { [any]: Observable<Brio<T>> | Observable<T> | T }
	@return Observable<{ [any]: T? }>
]=]
function RxBrioUtils.flatCombineLatest(observables)
	assert(type(observables) == "table", "Bad observables")

	local newObservables = {}
	for key, observable in observables do
		if Observable.isObservable(observable) then
			newObservables[key] = RxBrioUtils.flattenToValueAndNil(observable)
		else
			newObservables[key] = observable
		end
	end

	return Rx.combineLatest(newObservables)
end

--[=[
	Takes in a brio and returns an observable that emits the brio, and then completes
	on death.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param project (value: TBrio) -> TProject
	@return (brio<TBrio>) -> TProject
]=]
function RxBrioUtils.mapBrio(project)
	assert(type(project) == "function", "Bad project")

	warn("[RxBrioUtils.mapBrio] - Deprecated since 3.6.0. Use RxBrioUtils.mapBrioBrio")

	return function(brio)
		assert(Brio.isBrio(brio), "Not a brio")

		if brio:IsDead() then
			return Rx.EMPTY
		end

		local observable = project(brio:GetValue())
		assert(Observable.isObservable(observable), "Not an observable")

		return RxBrioUtils.completeOnDeath(brio, observable)
	end
end

--[=[
	Prepends the value onto the emitted brio
	@since 3.6.0
	@param ... T
	@return (source: Observable<Brio<U>>) -> Observable<Brio<U | T>>
]=]
function RxBrioUtils.prepend(...)
	local args = table.pack(...)

	return Rx.map(function(brio)
		assert(Brio.isBrio(brio), "Bad brio")

		return BrioUtils.prepend(brio, table.unpack(args, 1, args.n))
	end)
end

--[=[
	Extends the value onto the emitted brio
	@since 3.6.0
	@param ... T
	@return (source: Observable<Brio<U>>) -> Observable<Brio<U | T>>
]=]
function RxBrioUtils.extend(...)
	local args = table.pack(...)

	return Rx.map(function(brio)
		assert(Brio.isBrio(brio), "Bad brio")

		return BrioUtils.extend(brio, table.unpack(args, 1, args.n))
	end)
end

--[=[
	Maps the input brios to the output observables
	@since 3.6.0
	@param project project (Brio<T> | T) -> Brio<U> | U
	@return (source: Observable<Brio<T> | T>) -> Observable<Brio<U>>
]=]
function RxBrioUtils.map(project)
	return Rx.map(function(...)
		local n = select("#", ...)
		local brios = {}
		local args

		if n == 1 then
			if Brio.isBrio(...) then
				table.insert(brios, (...))
				args = (...):GetPackedValues()
			else
				args = { [1] = ... }
			end
		else
			args = {}
			for index, item in { ... } do
				if Brio.isBrio(item) then
					table.insert(brios, item)
					args[index] = item:GetValue() -- we lose data here, but I think this is fine
				else
					args[index] = item
				end
			end
			args.n = n
		end

		local results = table.pack(project(table.unpack(args, 1, args.n)))
		local transformedResults = {}
		for i = 1, results.n do
			local item = results[i]
			if Brio.isBrio(item) then
				table.insert(brios, item) -- add all subsequent brios into this table...
				transformedResults[i] = ((item :: any) :: Brio.Brio<unknown>):GetValue()
			else
				transformedResults[i] = item
			end
		end

		return BrioUtils.first(brios, table.unpack(transformedResults, 1, results.n))
	end)
end

function RxBrioUtils._mapResult(brio)
	return function(...)
		local n = select("#", ...)
		if n == 0 then
			return BrioUtils.withOtherValues(brio)
		elseif n == 1 then
			if Brio.isBrio(...) then
				return BrioUtils.first({ brio, (...) }, (...):GetValue())
			else
				return BrioUtils.withOtherValues(brio, ...)
			end
		else
			local brios = { brio }
			local args = {}

			for index, item in { ... } do
				if Brio.isBrio(item) then
					table.insert(brios, item)
					args[index] = item:GetValue() -- we lose data here, but I think this is fine
				else
					args[index] = item
				end
			end

			return BrioUtils.first(brios, unpack(args, 1, n))
		end
	end
end

--[=[
	Takes in a brio and returns an observable that emits the brio, and then completes
	on death.

	@since 3.6.0
	@param project (value: TBrio) -> TProject | Brio<TProject>
	@return (Brio<TBrio>) -> Brio<TProject>
]=]
function RxBrioUtils.mapBrioBrio(project)
	assert(type(project) == "function", "Bad project")

	return function(brio)
		assert(Brio.isBrio(brio), "Not a brio")

		if brio:IsDead() then
			return Rx.EMPTY
		end

		local observable = project(brio:GetValue())
		assert(Observable.isObservable(observable), "Not an observable")

		return RxBrioUtils.completeOnDeath(brio, observable):Pipe({
			Rx.map(RxBrioUtils._mapResult(brio)) :: any,
		}) :: any
	end
end

--[=[
	Transforms the brio into an observable that emits the initial value of the brio, and then another value on death
	@param brio Brio<T> | T
	@param emitOnDeathValue U
	@return Observable<T | U>
]=]
function RxBrioUtils.toEmitOnDeathObservable(brio, emitOnDeathValue)
	if not Brio.isBrio(brio) then
		return Rx.of(brio)
	else
		return Observable.new(function(sub)
			if brio:IsDead() then
				sub:Fire(emitOnDeathValue)
				sub:Complete()

				return nil
			end

			sub:Fire(brio:GetValue())

			-- Firing killed the subscription
			if not sub:IsPending() then
				return nil
			end

			-- Firing this event actually killed the brio
			if brio:IsDead() then
				sub:Fire(emitOnDeathValue)
				sub:Complete()

				return nil
			end

			return brio:GetDiedSignal():Connect(function()
				sub:Fire(emitOnDeathValue)
				sub:Complete()
			end)
		end)
	end
end

--[=[
	Returns a mapping function that emits the given value.

	@param emitOnDeathValue U
	@return (brio: Brio<T> | T) -> Observable<T | U>
]=]
function RxBrioUtils.mapBrioToEmitOnDeathObservable(emitOnDeathValue)
	return function(brio)
		return RxBrioUtils.toEmitOnDeathObservable(brio, emitOnDeathValue)
	end
end

--[=[
	Takes in an observable of brios and returns an observable of the inner values that will also output
	nil if there is no other value for the brio.

	@param emitOnDeathValue U
	@return (source: Observable<Brio<T> | T>) -> Observable<T | U>
]=]
function RxBrioUtils.emitOnDeath(emitOnDeathValue)
	return Rx.switchMap(function(brio)
		return RxBrioUtils.toEmitOnDeathObservable(brio, emitOnDeathValue) :: any
	end)
end

--[=[
	Flattens the observable to nil and the value

	@function flattenToValueAndNil
	@param source Observable<Brio<T> | T>
	@return T | nil
	@within RxBrioUtils
]=]
RxBrioUtils.flattenToValueAndNil = RxBrioUtils.emitOnDeath(nil)

--[=[
	Ensures only the last brio survives.

	@return (source Observable<Brio<T>>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.onlyLastBrioSurvives()
	return function(source)
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(brio)
				if not Brio.isBrio(brio) then
					warn(string.format("[RxBrioUtils.onlyLastBrioSurvives] - Not a brio, %q", tostring(brio)))
					maid._lastBrio = nil
					sub:Fail("Not a brio")
					return
				end

				local wrapperBrio = BrioUtils.clone(brio)
				maid._lastBrio = wrapperBrio

				sub:Fire(wrapperBrio)
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Switches the result to a brio, and ensures only the last brio lives.

	@since 3.6.0
	@function switchToBrio
	@param predicate ((T) -> boolean)?
	@return (source: Observable<T | Brio<T>>) -> Observable<Brio<T>>
	@within RxBrioUtils
]=]
function RxBrioUtils.switchToBrio<T>(predicate: Rx.Predicate<T>?)
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return function(source)
		return Observable.new(function(sub)
			local topMaid = Maid.new()

			topMaid:GiveTask(source:Subscribe(function(result, ...)
				-- Always kill previous brio first
				topMaid._last = nil

				if Brio.isBrio(result) then
					if result:IsDead() then
						return
					end

					if predicate == nil or predicate(result:GetValue()) then
						local newBrio = BrioUtils.clone(result)
						topMaid._last = newBrio
						sub:Fire(newBrio)
					end
				else
					if predicate == nil or predicate(result, ...) then
						local newBrio = Brio.new(result, ...)
						topMaid._last = newBrio
						sub:Fire(newBrio)
					end
				end
			end, sub:GetFailComplete()))

			return topMaid
		end)
	end
end

return RxBrioUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="67">
                <Properties>
                  <string name="Name">RxBrioUtils.spec</string>
                  <string name="Source"><![CDATA[--[[
	Unit tests for RxBrioUtils.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Brio = require("Brio")
local Jest = require("Jest")
local Observable = require("Observable")
local RxBrioUtils = require("RxBrioUtils")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("RxBrioUtils.combineLatest({})", function()
	it("should execute immediately", function()
		local observe = RxBrioUtils.combineLatest({})
		local brio
		local sub = observe:Subscribe(function(result)
			brio = result
		end)
		expect(brio).never.toBeNil()
		expect(Brio.isBrio(brio)).toEqual(true)
		expect(brio:IsDead()).toEqual(true)

		sub:Destroy()
	end)
end)

describe("RxBrioUtils.combineLatest({ value = Observable(Brio(5)) })", function()
	it("should execute immediately", function()
		local observe = RxBrioUtils.combineLatest({
			value = Observable.new(function(sub)
				sub:Fire(Brio.new(5))
			end),
			otherValue = 25,
		})
		local brio

		local sub = observe:Subscribe(function(result)
			brio = result
		end)
		expect(brio).never.toBeNil()
		expect(Brio.isBrio(brio)).toEqual(true)
		expect(not brio:IsDead()).toEqual(true)
		expect(brio:GetValue()).toEqual(expect.any("table"))
		expect(brio:GetValue().value).toEqual(5)

		sub:Destroy()
	end)
end)

describe("RxBrioUtils.flatCombineLatest", function()
	local doFire
	local brio = Brio.new(5)
	local observe = RxBrioUtils.flatCombineLatest({
		value = Observable.new(function(sub)
			sub:Fire(brio)
			doFire = function(...)
				sub:Fire(...)
			end
		end),
		otherValue = 25,
	})

	local lastResult = nil
	local fireCount = 0

	local sub = observe:Subscribe(function(result)
		lastResult = result
		fireCount = fireCount + 1
	end)

	it("should execute immediately", function()
		expect(fireCount).toEqual(1)
		expect(lastResult).toEqual(expect.any("table"))
		expect(Brio.isBrio(lastResult)).toEqual(false)
		expect(lastResult.value).toEqual(5)
		expect(lastResult.otherValue).toEqual(25)
	end)

	it("should reset when the brio is killed", function()
		expect(fireCount).toEqual(1)

		brio:Kill()

		expect(fireCount).toEqual(2)
		expect(lastResult).toEqual(expect.any("table"))
		expect(Brio.isBrio(lastResult)).toEqual(false)
		expect(lastResult.value).toEqual(nil)
		expect(lastResult.otherValue).toEqual(25)
	end)

	it("should allow a new value", function()
		expect(fireCount).toEqual(2)

		doFire(Brio.new(70))

		expect(fireCount).toEqual(3)
		expect(lastResult).toEqual(expect.any("table"))
		expect(Brio.isBrio(lastResult)).toEqual(false)
		expect(lastResult.value).toEqual(70)
		expect(lastResult.otherValue).toEqual(25)
	end)

	it("should only fire once if we replace the value", function()
		expect(fireCount).toEqual(3)

		doFire(Brio.new(75))

		expect(fireCount).toEqual(4)
		expect(lastResult).toEqual(expect.any("table"))
		expect(Brio.isBrio(lastResult)).toEqual(false)
		expect(lastResult.value).toEqual(75)
		expect(lastResult.otherValue).toEqual(25)
	end)

	it("should cleanup the sub", function()
		sub:Destroy()
	end)
end)
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="68">
            <Properties>
              <string name="Name">cancellabledelay</string>
            </Properties>
            <Item class="Folder" referent="69">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="70">
                <Properties>
                  <string name="Name">cancellableDelay</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	A version of task.delay that can be cancelled. Soon to be useless.
	@class cancellableDelay
]=]

--[=[
	@function cancellableDelay
	@param timeoutInSeconds number
	@param func function
	@param ... any -- Args to pass into the function
	@return function? -- Can be used to cancel
	@within cancellableDelay
]=]
local function cancellableDelay<T...>(timeoutInSeconds: number, func: (T...) -> ...any, ...: T...): () -> ()
	assert(type(timeoutInSeconds) == "number", "Bad timeoutInSeconds")
	assert(type(func) == "function", "Bad func")

	local args: any? = table.pack(...)

	local running: thread?
	task.spawn(function()
		running = coroutine.running()
		task.wait(timeoutInSeconds)
		local localArgs = args
		running = nil
		args = nil
		func(table.unpack(localArgs :: any, 1, localArgs.n))
	end)

	return function()
		if running then
			coroutine.close(running)
			running = nil
			args = nil
		end
	end
end

return cancellableDelay
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="71">
            <Properties>
              <string name="Name">canceltoken</string>
            </Properties>
            <Item class="Folder" referent="72">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="73">
                <Properties>
                  <string name="Name">CancelToken</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Cancellation token
	@class CancelToken
]=]

local require = require(script.Parent.loader).load(script)

local DuckTypeUtils = require("DuckTypeUtils")
local Maid = require("Maid")
local Promise = require("Promise")
local Signal = require("Signal")

local EMPTY_FUNCTION = function() end

local CancelToken = {}
CancelToken.ClassName = "CancelToken"
CancelToken.__index = CancelToken

export type Executor = (cancel: () -> (), maid: any) -> ()

export type CancelToken = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		Cancelled: Signal.Signal<()>,
		PromiseCancelled: Promise.Promise<()>,
	},
	{} :: typeof({ __index = CancelToken })
))

--[=[
	Constructs a new CancelToken

	@param executor (cancel: () -> ()) -> ()
	@return CancelToken
]=]
function CancelToken.new(executor: Executor): CancelToken
	local self = setmetatable({}, CancelToken)

	assert(type(executor) == "function", "Bad executor")

	self._maid = Maid.new()

	self.PromiseCancelled = Promise.new()
	self.Cancelled = Signal.new()

	self._maid:GiveTask(function()
		self.PromiseCancelled:Resolve()
		self.Cancelled:Fire()
		self.Cancelled:Destroy()
	end)

	self.PromiseCancelled:Then(function()
		self._maid:DoCleaning()
	end)

	executor(function()
		self:_cancel()
	end, self._maid)

	return self
end

--[=[
	Returns true if the value is a cancel token
	@param value any
	@return boolean
]=]
function CancelToken.isCancelToken(value: any): boolean
	return DuckTypeUtils.isImplementation(CancelToken, value)
end

--[=[
	Constructs a new CancelToken that cancels whenever the maid does.

	@param maid Maid
	@return CancelToken
]=]
function CancelToken.fromMaid(maid: Maid.Maid): CancelToken
	local token = CancelToken.new(EMPTY_FUNCTION)

	local taskId = maid:GiveTask(function()
		token:_cancel()
	end)

	token.PromiseCancelled:Then(function()
		maid[taskId] = nil
	end)

	return token
end

--[=[
	Cancels after the set amount of seconds

	@param seconds number
	@return CancelToken
]=]
function CancelToken.fromSeconds(seconds: number): CancelToken
	assert(type(seconds) == "number", "Bad seconds")

	return CancelToken.new(function(cancel, maid)
		maid:GiveTask(task.delay(seconds, cancel))
	end)
end

--[=[
	Errors if cancelled
]=]
function CancelToken.ErrorIfCancelled(self: CancelToken): ()
	if not self.PromiseCancelled:IsPending() then
		error("[CancelToken.ErrorIfCancelled] - Cancelled")
	end
end

--[=[
	Returns true if cancelled
	@return boolean
]=]
function CancelToken.IsCancelled(self: CancelToken): boolean
	return self.PromiseCancelled:IsFulfilled()
end

function CancelToken._cancel(self: CancelToken): ()
	self._maid:DoCleaning()
end

return CancelToken
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="74">
            <Properties>
              <string name="Name">clienttranslator</string>
            </Properties>
            <Item class="Folder" referent="75">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="Folder" referent="76">
                <Properties>
                  <string name="Name">Conversion</string>
                </Properties>
                <Item class="ModuleScript" referent="77">
                  <Properties>
                    <string name="Name">LocalizationEntryParserUtils</string>
                    <string name="Source"><![CDATA[--[=[
	Utility to build a localization table from json, intended to be used with rojo. Can also handle Rojo json
	objects turned into tables!

	@class LocalizationEntryParserUtils
]=]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local require = require(script.Parent.loader).load(script)

local PseudoLocalize = require("PseudoLocalize")

local LocalizationEntryParserUtils = {}

function LocalizationEntryParserUtils.decodeFromInstance(tableName: string, sourceLocaleId: string, folder: Instance)
	assert(type(tableName) == "string", "Bad tableName")
	assert(typeof(folder) == "Instance", "Bad folder")

	local lookupTable = {}
	local baseKey = ""

	for _, descendant in folder:GetDescendants() do
		if descendant:IsA("StringValue") then
			local localeId = LocalizationEntryParserUtils._parseLocaleFromName(descendant.Name)
			local decodedTable = HttpService:JSONDecode(descendant.Value)

			LocalizationEntryParserUtils._parseTableToResultsList(
				lookupTable,
				sourceLocaleId,
				localeId,
				baseKey,
				decodedTable,
				tableName
			)
		elseif descendant:IsA("ModuleScript") then
			local localeId = LocalizationEntryParserUtils._parseLocaleFromName(descendant.Name)
			local decodedTable = require(descendant)

			LocalizationEntryParserUtils._parseTableToResultsList(
				lookupTable,
				sourceLocaleId,
				localeId,
				baseKey,
				decodedTable,
				tableName
			)
		end
	end

	local results = {}
	for _, item in lookupTable do
		table.insert(results, item)
	end
	return results
end

function LocalizationEntryParserUtils.decodeFromTable(tableName: string, localeId: string, dataTable)
	assert(type(tableName) == "string", "Bad tableName")
	assert(type(localeId) == "string", "Bad localeId")
	assert(type(dataTable) == "table", "Bad dataTable")

	local lookupTable = {}

	local baseKey = ""
	LocalizationEntryParserUtils._parseTableToResultsList(
		lookupTable,
		localeId,
		localeId,
		baseKey,
		dataTable,
		tableName
	)

	local results = {}
	for _, item in lookupTable do
		table.insert(results, item)
	end
	return results
end

function LocalizationEntryParserUtils._parseLocaleFromName(name: string)
	if string.sub(name, -5) == ".json" then
		return string.sub(name, 1, #name - 5)
	else
		return name
	end
end

function LocalizationEntryParserUtils._parseTableToResultsList(
	lookupTable,
	sourceLocaleId: string,
	localeId: string,
	baseKey: string,
	dataTable,
	tableName: string
)
	assert(type(lookupTable) == "table", "Bad lookupTable")
	assert(type(sourceLocaleId) == "string", "Bad sourceLocaleId")
	assert(type(localeId) == "string", "Bad localeId")
	assert(type(baseKey) == "string", "Bad baseKey")
	assert(type(dataTable) == "table", "Bad dataTable")
	assert(type(tableName) == "string", "Bad tableName")

	for index, text in dataTable do
		local key = baseKey .. index
		if type(text) == "table" then
			LocalizationEntryParserUtils._parseTableToResultsList(
				lookupTable,
				sourceLocaleId,
				localeId,
				key .. ".",
				text,
				tableName
			)
		elseif type(text) == "string" then
			local found = lookupTable[key]
			if found then
				found.Values[localeId] = text
			else
				found = {
					Example = text,
					Key = key,
					Context = string.format("[TEMP] - Generated from %s with key %s", tableName, key),
					Source = text, -- Tempt!
					Values = {
						[localeId] = text,
					},
				}

				lookupTable[key] = found
			end

			-- Ensure assignment
			if sourceLocaleId == localeId then
				-- Guarantee the context is unique. This is important because Roblox will not
				-- allow something with the same source without a differing context text.
				found.Context = string.format("Generated from %s with key %s", tableName, key)
				found.Source = text

				if RunService:IsStudio() then
					found.Values[PseudoLocalize.getDefaultPseudoLocaleId()] = PseudoLocalize.pseudoLocalize(text)
				end
			end
		else
			error(string.format("Bad type for text at key '%s'", key))
		end
	end
end

return LocalizationEntryParserUtils
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="78">
                <Properties>
                  <string name="Name">JSONTranslator</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility function that loads a translator from a folder or a table.

	To get translations uploaded.

	1. Run the game
	2. On the client, check LocalizationService.GeneratedJSONTable
	3. Right click > Save as CSV
	4. Stop the game
	5. In Studio, go to plugins > "Localization Tools"
	6. Upload the CSV (update)

	@class JSONTranslator
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local LocalizationEntryParserUtils = require("LocalizationEntryParserUtils")
local Maid = require("Maid")
local NumberLocalizationUtils = require("NumberLocalizationUtils")
local Observable = require("Observable")
local Promise = require("Promise")
local PseudoLocalize = require("PseudoLocalize")
local Rx = require("Rx")
local RxInstanceUtils = require("RxInstanceUtils")
local ServiceBag = require("ServiceBag")
local TranslationKeyUtils = require("TranslationKeyUtils")
local TranslatorService = require("TranslatorService")
local ValueObject = require("ValueObject")

local JSONTranslator = {}
JSONTranslator.ClassName = "JSONTranslator"
JSONTranslator.ServiceName = "JSONTranslator"
JSONTranslator.__index = JSONTranslator

export type JSONTranslator = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_serviceBag: ServiceBag.ServiceBag,
		_translatorService: TranslatorService.TranslatorService,
		_translatorName: string,
		_entries: { [string]: any },
		_localizationTable: any,
		_localTranslator: ValueObject.ValueObject<any>,
		_sourceTranslator: ValueObject.ValueObject<any>,
	},
	{} :: typeof({ __index = JSONTranslator })
))

--[=[
	Constructs a new JSONTranslator from the given args.

	```
	local translator = JSONTranslator.new("MyTranslator", en", {
		actions = {
			respawn = "Respawn {playerName}";
		};
	})

	print(translator:FormatByKey("actions.respawn"), { playerName = "Quenty"}) --> Respawn Quenty

	-- Observing is preferred
	maid:GiveTask(translator:ObserveFormatByKey("actions.respawn", {
		playerName = RxInstanceUtils.observeProperty(player, "DisplayName");
	}):Subscribe(function(text)
		print(text) --> "Respawn Quenty"
	end)
	```

	```lua
	local translator = JSONTranslator.new(script)
	-- assume there is an `en.json` underneath the script with valid JSON.
	```

	@param translatorName string -- Name of the translator. Used for source.
	@param localeId string
	@param dataTable table
	@return JSONTranslator
]=]
function JSONTranslator.new(translatorName: string, localeId: string, dataTable): JSONTranslator
	assert(type(translatorName) == "string", "Bad translatorName")

	local self = setmetatable({}, JSONTranslator)

	self._translatorName = translatorName
	self.ServiceName = translatorName

	if type(localeId) == "string" and type(dataTable) == "table" then
		self._entries = LocalizationEntryParserUtils.decodeFromTable(self._translatorName, localeId, dataTable)
	elseif typeof(localeId) == "Instance" then
		local parent = localeId
		local sourceLocaleId = "en"
		self._entries = LocalizationEntryParserUtils.decodeFromInstance(self._translatorName, sourceLocaleId, parent)
	else
		error("Must pass a localeId and dataTable")
	end

	return self :: any
end

function JSONTranslator.Init(self: JSONTranslator, serviceBag: ServiceBag.ServiceBag)
	self._serviceBag = assert(serviceBag, "No serviceBag")
	self._translatorService = self._serviceBag:GetService(TranslatorService) :: any

	self._maid = Maid.new()
	self._localTranslator = self._maid:Add(ValueObject.new(nil))
	self._sourceTranslator = self._maid:Add(ValueObject.new(nil))

	self._localizationTable = self._translatorService:GetLocalizationTable()

	for _, item in self._entries do
		for localeId, text in item.Values do
			self._localizationTable:SetEntryValue(item.Key, item.Source, item.Context, localeId, text)
		end
		self._localizationTable:SetEntryExample(item.Key, item.Source, item.Context, item.Example)
	end

	-- TODO: Maybe don't hold these unless needed
	self._maid:GiveTask(self._translatorService:ObserveLocaleId():Subscribe(function(localeId)
		self._localTranslator.Value = self._localizationTable:GetTranslator(localeId)
	end))
	self._maid:GiveTask(
		RxInstanceUtils.observeProperty(self._localizationTable, "SourceLocaleId"):Subscribe(function(localeId)
			self._sourceTranslator.Value = self._localizationTable:GetTranslator(localeId)
		end)
	)
end

function JSONTranslator.ObserveNumber(self: JSONTranslator, number: number): Observable.Observable<string>
	return Rx.combineLatest({
		localeId = self:ObserveLocaleId(),
		number = number,
	}):Pipe({
		Rx.map(function(state)
			return NumberLocalizationUtils.localize(state.number, state.localeId)
		end) :: any,
	}) :: any
end

function JSONTranslator.ObserveAbbreviatedNumber(
	self: JSONTranslator,
	number: number,
	roundingBehaviourType,
	numSignificantDigits: number?
)
	return Rx.combineLatest({
		localeId = self:ObserveLocaleId(),
		roundingBehaviourType = roundingBehaviourType,
		numSignificantDigits = numSignificantDigits,
		number = number,
	}):Pipe({
		Rx.map(function(state)
			return NumberLocalizationUtils.abbreviate(
				state.number,
				state.localeId,
				state.roundingBehaviourType,
				state.numSignificantDigits
			)
		end) :: any,
	})
end

--[=[
	Observes the translated value
	@param translationKey string
	@param translationArgs table? -- May have observables (or convertable to observables) in it.
	@return Observable<string>
]=]
function JSONTranslator.ObserveFormatByKey(
	self: JSONTranslator,
	translationKey: string,
	translationArgs
): Observable.Observable<string>
	assert((self :: any) ~= JSONTranslator, "Construct a new version of this class to use it")
	assert(type(translationKey) == "string", "Key must be a string")

	return Rx.combineLatest({
		cloudTranslator = self:ObserveTranslator(),
		translationKey = translationKey,
		translationArgs = self:_observeArgs(translationArgs),
	}):Pipe({
		Rx.switchMap(function(mainState): any
			if mainState.cloudTranslator then
				return self._translatorService:ObserveLocaleId():Pipe({
					Rx.map(function()
						return self:_doTranslation(
							mainState.cloudTranslator,
							mainState.translationKey,
							mainState.translationArgs
						)
					end) :: any,
				})
			end

			-- Fall back to local or source translator
			return Rx.combineLatest({
				localTranslator = self._localTranslator:Observe(),
				sourceTranslator = self._sourceTranslator:Observe(),
			}):Pipe({
				Rx.map(function(state): string?
					if state.localTranslator then
						return self:_doTranslation(
							state.localTranslator,
							mainState.translationKey,
							mainState.translationArgs
						)
					elseif state.sourceTranslator then
						return self:_doTranslation(
							state.sourceTranslator,
							mainState.translationKey,
							mainState.translationArgs
						)
					else
						return nil
					end
				end) :: any,
				Rx.where(function(value)
					return value ~= nil
				end) :: any,
			})
		end) :: any,
	}) :: any
end

--[=[
	Formats the resulting entry by args.

	:::tip
	You should use [JSONTranslator.ObserveFormatByKey] instead of this to respond
	to locale changing.
	:::

	@param translationKey string
	@param args table?
	@return Promise<string>
]=]
function JSONTranslator.PromiseFormatByKey(self: JSONTranslator, translationKey: string, args)
	assert((self :: any) ~= JSONTranslator, "Construct a new version of this class to use it")
	assert(type(translationKey) == "string", "Key must be a string")

	-- Always waits for full translator to be loaded since we only get one shot
	return self:PromiseTranslator():Then(function(translator)
		return self:_doTranslation(translator, translationKey, args)
	end)
end

--[=[
	Returns a promise that will resolve once the Roblox translator is loaded from the cloud.
	@return Promise<Translator>
]=]
function JSONTranslator.PromiseTranslator(self: JSONTranslator): Promise.Promise<Translator>
	return self._translatorService:PromiseTranslator()
end

--[=[
	Observes the current Roblox translator for this translator.

	@return Observable<Translator>
]=]
function JSONTranslator.ObserveTranslator(self: JSONTranslator): Observable.Observable<Translator>
	return self._translatorService:ObserveTranslator()
end

--[=[
	Observes the current locale id for this translator.

	@return Observable<string>
]=]
function JSONTranslator.ObserveLocaleId(self: JSONTranslator): Observable.Observable<string>
	return self._translatorService:ObserveLocaleId()
end

--[=[
	Adds an entry value to the localization table itself. This can be useful
	for ensuring pseudo localization and/or generating localization values
	from the game data itself.

	@param translationKey string
	@param source string
	@param context string
	@param localeId string
	@param text string
]=]
function JSONTranslator.SetEntryValue(
	self: JSONTranslator,
	translationKey: string,
	source: string,
	context: string,
	localeId: string,
	text: string
)
	assert(type(translationKey) == "string", "Bad translationKey")
	assert(type(source) == "string", "Bad source")
	assert(type(context) == "string", "Bad context")
	assert(type(localeId) == "string", "Bad localeId")
	assert(type(text) == "string", "Bad text")

	self._localizationTable:SetEntryValue(translationKey, source, context, localeId, text or source)

	if RunService:IsStudio() then
		self._localizationTable:SetEntryValue(
			translationKey,
			source,
			context,
			PseudoLocalize.getDefaultPseudoLocaleId(),
			PseudoLocalize.pseudoLocalize(text)
		)
	end
end

--[=[
	Observes a translation key and formats it with the given args.

	@param prefix string
	@param text string
	@param translationArgs table?
	@return Observable<string>
]=]
function JSONTranslator.ObserveTranslation(
	self: JSONTranslator,
	prefix: string,
	text: string,
	translationArgs
): Observable.Observable<string>
	assert(type(prefix) == "string", "Bad text")
	assert(type(text) == "string", "Bad text")

	return self:ObserveFormatByKey(self:ToTranslationKey(prefix, text), translationArgs)
end

--[=[
	Converts the given prefix and text into a translation key.

	@param prefix string
	@param text string
	@return string
]=]
function JSONTranslator.ToTranslationKey(self: JSONTranslator, prefix: string, text: string): string
	assert(type(prefix) == "string", "Bad text")
	assert(type(text) == "string", "Bad text")

	local translationKey = TranslationKeyUtils.getTranslationKey(prefix, text)
	local context = string.format("automatic.%s", translationKey)

	-- TODO: Only set if we don't need it
	self:SetEntryValue(translationKey, text, context, "en", text)

	return translationKey
end

--[=[
	Gets the current localeId of the translator if it's initialized, or a default if it is not.

	@return string
]=]
function JSONTranslator.GetLocaleId(self: JSONTranslator): string
	return self._translatorService:GetLocaleId()
end

--[=[
	Gets the localization table the translation is using.

	@return LocalizationTable
]=]
function JSONTranslator.GetLocalizationTable(self: JSONTranslator): LocalizationTable
	return self._localizationTable
end

--[=[
	Returns a promise that will resolve once the translator is loaded from the cloud.
	@return Promise
]=]
function JSONTranslator.PromiseLoaded(self: JSONTranslator): Promise.Promise<()>
	return self:PromiseTranslator()
end

--[=[
	Formats or errors if the cloud translations are not loaded.

	:::tip
	You should use [JSONTranslator.ObserveFormatByKey] instead of this to respond
	to locale changing.
	:::

	@param translationKey string
	@param args table?
	@return string
]=]
function JSONTranslator.FormatByKey(self: JSONTranslator, translationKey: string, args): string
	assert((self :: any) ~= JSONTranslator, "Construct a new version of this class to use it")
	assert(type(translationKey) == "string", "Key must be a string")

	local translator = self._translatorService:GetTranslator()
	if not translator then
		error("Translator is not yet acquired yet")
	end

	return self:_doTranslation(translator, translationKey, args)
end

function JSONTranslator._observeArgs(_self: JSONTranslator, translationArgs): Observable.Observable<any>
	if translationArgs == nil then
		return Rx.of(nil)
	end

	local args = {}
	for argKey, value in translationArgs do
		args[argKey] = Blend.toPropertyObservable(value) or Rx.of(value)
	end

	return Rx.combineLatest(args)
end

function JSONTranslator._doTranslation(
	self: JSONTranslator,
	translator: Translator,
	translationKey: string,
	args
): string
	assert(typeof(translator) == "Instance", "Bad translator")
	assert(type(translationKey) == "string", "Bad translationKey")

	local translation: string
	local ok, err = pcall(function()
		translation = translator:FormatByKey(translationKey, args)
	end)

	if translation then
		return translation
	end

	if err then
		warn(err)
	else
		warn("Failed to localize '" .. translationKey .. "'")
	end

	-- Try the local translator next (not from cloud)
	local localTranslator = self._localTranslator.Value
	if localTranslator then
		ok, err = pcall(function()
			translation = localTranslator:FormatByKey(translationKey, args)
		end)

		if translation then
			return translation
		end
	end

	-- Try the source translator next (we're missing the locale id)
	local sourceTranslator = self._sourceTranslator.Value
	if sourceTranslator then
		ok, err = pcall(function()
			translation = sourceTranslator:FormatByKey(translationKey, args)
		end)
	end

	if ok and not err and translation then
		return translation
	end

	return translationKey
end

--[=[
	Cleans up the translator and deletes the localization table if it exists.
	Should be called by [ServiceBag]
]=]
function JSONTranslator.Destroy(self: JSONTranslator)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return JSONTranslator
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="79">
                <Properties>
                  <string name="Name">Numbers</string>
                </Properties>
                <Item class="ModuleScript" referent="80">
                  <Properties>
                    <string name="Name">NumberLocalizationUtils</string>
                    <string name="Source"><![CDATA[--[=[
	NumberLocalizationUtils script from Roblox's player scripts in handling the leaderboard.

	Example locale-sensitive number formatting:
	https://docs.oracle.com/cd/E19455-01/806-0169/overview-9/index.html

	Locale specification:
	[DECIMAL_SEPARATOR] = string for decimal point, if needed
	[GROUP_DELIMITER] = string for groupings of numbers left of the decimal
	List section = abbreviations for language, in increasing order

	Missing features in this code:
	- No support for differences in number of digits per GROUP_DELIMITER.
	Some Chinese dialects group by 10000 instead of 1000.
	- No support for variable differences in number of digits per GROUP_DELIMITER.
	Indian natural language groups the first 3 to left of decimal, then every 2 after that.

	See https://en.wikipedia.org/wiki/Decimal_separator#Digit_grouping


	@class NumberLocalizationUtils
]=]

local require = require(script.Parent.loader).load(script)

local RoundingBehaviourTypes = require("RoundingBehaviourTypes")

local NumberLocalizationUtils = {}

local DEFAULT_LOCALE = "en-us"

-- Separator aliases to help avoid spelling errors
local DECIMAL_SEPARATOR = "decimalSeparator"
local GROUP_DELIMITER = "groupDelimiter"

local localeInfos = {}

localeInfos["en-us"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = ",",
	{ 1, "" },
	{ 1e3, "K" },
	{ 1e6, "M" },
	{ 1e9, "B" },
}

localeInfos["es-es"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = ".",
	{ 1, "" },
	{ 1e3, " mil" },
	{ 1e6, " M" },
}

localeInfos["fr-fr"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = " ",
	{ 1, "" },
	{ 1e3, " k" },
	{ 1e6, " M" },
	{ 1e9, " Md" },
}

localeInfos["de-de"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = " ",
	{ 1, "" },
	{ 1e3, " Tsd." },
	{ 1e6, " Mio." },
	{ 1e9, " Mrd." },
}

localeInfos["pt-br"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = ".",
	{ 1, "" },
	{ 1e3, " mil" },
	{ 1e6, " mi" },
	{ 1e9, " bi" },
}

localeInfos["zh-cn"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = ",", -- Chinese commonly uses 3 digit groupings, despite 10000s rule
	{ 1, "" },
	{ 1e3, "千" },
	{ 1e4, "万" },
	{ 1e8, "亿" },
}

localeInfos["zh-cjv"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = ",",
	{ 1, "" },
	{ 1e3, "千" },
	{ 1e4, "万" },
	{ 1e8, "亿" },
}

localeInfos["zh-tw"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = ",",
	{ 1, "" },
	{ 1e3, "千" },
	{ 1e4, "萬" },
	{ 1e8, "億" },
}

localeInfos["ko-kr"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = ",",
	{ 1, "" },
	{ 1e3, "천" },
	{ 1e4, "만" },
	{ 1e8, "억" },
}

localeInfos["ja-jp"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = ",",
	{ 1, "" },
	{ 1e3, "千" },
	{ 1e4, "万" },
	{ 1e8, "億" },
}

localeInfos["it-it"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = " ",
	{ 1, "" },
	{ 1e3, " mila" },
	{ 1e6, " Mln" },
	{ 1e9, " Mld" },
}

localeInfos["ru-ru"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = ".",
	{ 1, "" },
	{ 1e3, " тыс" },
	{ 1e6, " млн" },
	{ 1e9, " млрд" },
}

localeInfos["id-id"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = ".",
	{ 1, "" },
	{ 1e3, " rb" },
	{ 1e6, " jt" },
	{ 1e9, " M" },
}

localeInfos["vi-vn"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = " ",
	{ 1, "" },
	{ 1e3, " N" },
	{ 1e6, " Tr" },
	{ 1e9, " T" },
}

localeInfos["th-th"] = {
	[DECIMAL_SEPARATOR] = ".",
	[GROUP_DELIMITER] = ",",
	{ 1, "" },
	{ 1e3, " พ" },
	{ 1e4, " ม" },
	{ 1e5, " ส" },
	{ 1e6, " ล" },
}

localeInfos["tr-tr"] = {
	[DECIMAL_SEPARATOR] = ",",
	[GROUP_DELIMITER] = ".",
	{ 1, "" },
	{ 1e3, " B" },
	{ 1e6, " Mn" },
	{ 1e9, " Mr" },
}

-- Aliases for languages that use the same mappings.
localeInfos["en"] = localeInfos["en-us"]
localeInfos["en-gb"] = localeInfos["en-us"]
localeInfos["es-mx"] = localeInfos["es-es"]

local function findDecimalPointIndex(numberStr: string)
	return string.find(numberStr, "%.") or #numberStr + 1
end

-- Find the base 10 offset needed to make 0.1 <= abs(number) < 1
local function findDecimalOffset(number: number)
	if number == 0 then
		return 0
	end

	local offsetToOnesRange = math.floor(math.log10(math.abs(number)))
	return -(offsetToOnesRange + 1) -- Offset one more (or less) digit
end

local function roundToSignificantDigits(
	number: number,
	significantDigits: number,
	roundingBehaviourType: RoundingBehaviourTypes.RoundingBehaviourType
)
	local offset = findDecimalOffset(number)
	local multiplier = 10 ^ (significantDigits + offset)
	local significand
	if roundingBehaviourType == RoundingBehaviourTypes.TRUNCATE then
		significand = math.modf(number * multiplier)
	else
		significand = math.floor(number * multiplier + 0.5)
	end
	return significand / multiplier
end

local function addGroupDelimiters(numberStr, delimiter: string): string
	local formatted = numberStr
	local delimiterSubStr = string.format("%%1%s%%2", delimiter)
	while true do
		local lFormatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", delimiterSubStr)
		formatted = lFormatted
		if k == 0 then
			break
		end
	end
	return formatted
end

local function findDenominationEntry(
	localeInfo,
	number: number,
	roundingBehaviourType: RoundingBehaviourTypes.RoundingBehaviourType
)
	local denominationEntry = localeInfo[1] -- Default to base denominations
	local absOfNumber = math.abs(number)
	for i = #localeInfo, 2, -1 do
		local entry = localeInfo[i]
		local baseValue
		if roundingBehaviourType == RoundingBehaviourTypes.TRUNCATE then
			baseValue = entry[1]
		else
			baseValue = entry[1] - localeInfo[i - 1][1] / 2
		end
		if baseValue <= absOfNumber then
			denominationEntry = entry
			break
		end
	end
	return denominationEntry
end

function NumberLocalizationUtils.localize(number: number, locale: string): string
	if number == 0 then
		return "0"
	end

	local localeInfo = localeInfos[locale]
	if not localeInfo then
		localeInfo = localeInfos[DEFAULT_LOCALE]
		warn(
			string.format(
				"[NumberLocalizationUtils] - Locale not found: '%s', reverting to '%s' instead.",
				tostring(locale),
				DEFAULT_LOCALE
			)
		)
	end

	if localeInfo.groupDelimiter then
		return addGroupDelimiters(number, localeInfo.groupDelimiter)
	end

	return tostring(number)
end

--[=[
	Abbreviates the number to a truncated amount in a localized way.

	```lua
	print(NumberLocalizationUtils.abbreviate(2500, "en-us", RoundingBehaviourTypes.ROUND_TO_CLOSEST, 3)) --> 2.5k
	```

	@param number number
	@param locale string
	@param roundingBehaviourType RoundingBehaviourType?
	@param numSignificantDigits number?
	@return string
]=]
function NumberLocalizationUtils.abbreviate(
	number: number,
	locale: string,
	roundingBehaviourType: RoundingBehaviourTypes.RoundingBehaviourType?,
	numSignificantDigits: number?
): string
	assert(type(number) == "number", "Bad number")
	local roundingBehavior = roundingBehaviourType or RoundingBehaviourTypes.ROUND_TO_CLOSEST
	local significantDigits = numSignificantDigits or 3

	if roundingBehavior == RoundingBehaviourTypes.NONE then
		return NumberLocalizationUtils.localize(number, locale)
	end

	if number == 0 then
		return "0"
	end

	local localeInfo = localeInfos[locale]
	if not localeInfo then
		localeInfo = localeInfos[DEFAULT_LOCALE]
		warn(
			string.format(
				"[NumberLocalizationUtils] - Locale not found: '%s', reverting to '%s' instead.",
				tostring(locale),
				DEFAULT_LOCALE
			)
		)
	end

	-- select which denomination we are going to use
	local denominationEntry = findDenominationEntry(localeInfo, number, roundingBehavior)
	local baseValue = denominationEntry[1]
	local symbol = denominationEntry[2]

	-- Round to required significant digits
	local significantQuotient = roundToSignificantDigits(number / baseValue, significantDigits, roundingBehavior)

	-- trim decimal points
	local trimmedQuotientString
	local symbolsAboveDecimal = math.ceil(math.log10(significantQuotient))
	local maxDecimals = math.max(1, significantDigits - symbolsAboveDecimal)
	local trimmedQuotient
	local roundingFactor = 10 ^ maxDecimals
	if roundingBehavior == RoundingBehaviourTypes.TRUNCATE then
		trimmedQuotient = math.modf(significantQuotient * roundingFactor) / roundingFactor
	elseif roundingBehavior == RoundingBehaviourTypes.ROUND_TO_CLOSEST then
		trimmedQuotient = math.floor(significantQuotient * roundingFactor + 0.5) / roundingFactor
	else
		error(
			string.format(
				"[NumberLocalizationUtils.abbreviate] - Unknown roundingBehaviourType %q",
				tostring(roundingBehavior)
			)
		)
	end

	trimmedQuotientString = tostring(trimmedQuotient)

	-- Split the string into integer and fraction parts
	local decimalPointIndex = findDecimalPointIndex(trimmedQuotientString)
	local integerPart = string.sub(trimmedQuotientString, 1, decimalPointIndex - 1)
	local fractionPart = string.sub(trimmedQuotientString, decimalPointIndex + 1, #trimmedQuotientString)

	-- Add group delimiters to integer part
	if localeInfo.groupDelimiter then
		integerPart = addGroupDelimiters(integerPart, localeInfo.groupDelimiter)
	end

	if #fractionPart > 0 then
		return integerPart .. localeInfo.decimalSeparator .. fractionPart .. symbol
	else
		return integerPart .. symbol
	end
end

return NumberLocalizationUtils
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="81">
                  <Properties>
                    <string name="Name">NumberLocalizationUtils.spec</string>
                    <string name="Source"><![CDATA[local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local NumberLocalizationUtils = require("NumberLocalizationUtils")
local RoundingBehaviourTypes = require("RoundingBehaviourTypes")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

local function checkLocale(locale: string, responseMapping)
	for input, output in responseMapping do
		expect(NumberLocalizationUtils.localize(input, locale)).toBe(output)
	end
end

local function checkValid_en_zh(locale: string)
	checkLocale(locale, {
		[0] = "0",
		[1] = "1",
		[25] = "25",
		[364] = "364",
		[4120] = "4,120",
		[57860] = "57,860",
		[624390] = "624,390",
		[7857000] = "7,857,000",
		[-12345678] = "-12,345,678",
		[23987.45678] = "23,987.45678",
		[-12.3456] = "-12.3456",
		[-23987.45678] = "-23,987.45678",
	})
end

describe("NumberLocalizationUtils.localize", function()
	-- it("should default to en-us when locale is not recognized", function()
	-- 	local logs = Logging.capture(function()
	-- 		checkValid_en_zh("bad_locale")
	-- 	end)
	-- 	expect(string.match(logs.warnings[1], "^Warning: Locale not found:") ~= nil).toBe(true)
	-- end)

	-- it("should default to en-us when locale is nil", function()
	-- 	local logs = Logging.capture(function()
	-- 		checkValid_en_zh(nil)
	-- 	end)
	-- 	expect(string.match(logs.warnings[1], "^Warning: Locale not found:") ~= nil).toBe(true)
	-- end)

	-- it("should default to en-us when locale is empty", function()
	-- 	local logs = Logging.capture(function()
	-- 		checkValid_en_zh("")
	-- 	end)
	-- 	expect(string.match(logs.warnings[1], "^Warning: Locale not found:") ~= nil).toBe(true)
	-- end)

	it("should localize correctly. (en-us)", function()
		checkValid_en_zh("en-us")
	end)

	it("should localize correctly. (en-gb)", function()
		checkValid_en_zh("en-gb")
	end)

	it("should localize correctly. (zh-cn)", function()
		checkValid_en_zh("zh-cn")
	end)

	it("should localize correctly. (zh-tw)", function()
		checkValid_en_zh("zh-tw")
	end)
end)

describe("NumberLocalizationUtils.abbreviate", function()
	it("should round towards zero when using RoundingBehaviourTypes.Truncate", function()
		local roundToZeroMap = {
			[0] = "0",
			[1] = "1",
			[25] = "25",
			[364] = "364",
			[4120] = "4.12K",
			[57860] = "57.8K",
			[624390] = "624K",
			[999999] = "999K",
			[7857000] = "7.85M",
			[8e7] = "80M",
			[9e8] = "900M",
			[1e9] = "1B",
			[1e12] = "1,000B",
			[-0] = "0",
			[-1] = "-1",
			[-25] = "-25",
			[-364] = "-364",
			[-4120] = "-4.1K",
			[-57860] = "-57.8K",
			[-624390] = "-624K",
			[-999999] = "-999K",
			[-7857000] = "-7.8M",
			[-8e7] = "-80M",
			[-9e8] = "-900M",
			[-1e9] = "-1B",
			[-1e12] = "-1,000B",
			[1.1] = "1.1",
			[1499.99] = "1.49K",
			[-1.1] = "-1.1",
			[-1499.99] = "-1.4K",
		}

		for input, output in roundToZeroMap do
			expect(NumberLocalizationUtils.abbreviate(input, "en-us", RoundingBehaviourTypes.TRUNCATE)).toBe(output)
		end
	end)
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="82">
                  <Properties>
                    <string name="Name">RoundingBehaviourTypes</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	@class RoundingBehaviourTypes
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

export type RoundingBehaviourType = "roundToClosest" | "truncate" | "None"

export type RoundingBehaviourTypeMap = {
	ROUND_TO_CLOSEST: "roundToClosest",
	TRUNCATE: "truncate",
	NONE: "none",
}

return Table.readonly({
	ROUND_TO_CLOSEST = "roundToClosest",
	TRUNCATE = "truncate",
	NONE = "none",
} :: RoundingBehaviourTypeMap)
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="83">
                <Properties>
                  <string name="Name">TranslatorService</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Handles selecting the right locale/translator for Studio, and Roblox games.

	@class TranslatorService
]=]

local require = require(script.Parent.loader).load(script)

local LocalizationService = game:GetService("LocalizationService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalizationServiceUtils = require("LocalizationServiceUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local Promise = require("Promise")
local Rx = require("Rx")
local RxInstanceUtils = require("RxInstanceUtils")
local ServiceBag = require("ServiceBag")
local ValueObject = require("ValueObject")

local TranslatorService = {}
TranslatorService.ServiceName = "TranslatorService"

export type TranslatorService = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_serviceBag: ServiceBag.ServiceBag,
		_translator: ValueObject.ValueObject<Translator>,
		_localizationTable: LocalizationTable?,
		_pendingTranslatorPromise: Promise.Promise<Translator>?,
		_localeIdValue: ValueObject.ValueObject<string>?,
		_loadedPlayerObservable: Observable.Observable<Player>?,
		_loadedPlayer: Player?,
	},
	{} :: typeof({ __index = TranslatorService })
))

function TranslatorService.Init(self: TranslatorService, serviceBag: ServiceBag.ServiceBag)
	assert(not self._serviceBag, "Already initialized")
	self._serviceBag = assert(serviceBag, "No serviceBag")
	self._maid = Maid.new()

	self._translator = self._maid:Add(ValueObject.new(nil))
	self._translator:Mount(self:_observeTranslatorImpl())
end

function TranslatorService.GetLocalizationTable(self: TranslatorService): LocalizationTable
	if self._localizationTable then
		return self._localizationTable
	end

	local localizationTableName = self:_getLocalizationTableName()
	local localizationTable = LocalizationService:FindFirstChild(localizationTableName)

	if not localizationTable then
		localizationTable = Instance.new("LocalizationTable")
		localizationTable.Name = localizationTableName
		localizationTable.Parent = LocalizationService
	end

	self._localizationTable = localizationTable
	return localizationTable
end

function TranslatorService._getLocalizationTableName(_self: TranslatorService): string
	if RunService:IsServer() then
		return "GeneratedJSONTable_Server"
	else
		return "GeneratedJSONTable_Client"
	end
end

--[=[
	Observes Roblox translator

	@return Observable<Translator>
]=]
function TranslatorService.ObserveTranslator(self: TranslatorService): Observable.Observable<Translator>
	return self._translator:Observe()
end

--[=[
	Promises the Roblox translator

	@return Observable<Translator>
]=]
function TranslatorService.PromiseTranslator(self: TranslatorService): Promise.Promise<Translator>
	local found = self._translator.Value
	if found then
		return Promise.resolved(found)
	end

	if self._pendingTranslatorPromise then
		return self._pendingTranslatorPromise
	end

	local maid = Maid.new()
	local promise = maid:Add(Promise.new())

	self._maid._pendingTranslatorMaid = maid
	self._pendingTranslatorPromise = promise

	maid:GiveTask(function()
		if self._maid._pendingTranslatorMaid == maid then
			self._maid._pendingTranslatorMaid = nil
		end

		if self._pendingTranslatorPromise == promise then
			self._pendingTranslatorPromise = nil
		end
	end)

	maid:GiveTask(self._translator:Observe():Subscribe(function(translator: Translator)
		if translator then
			promise:Resolve(translator)
		end
	end))

	return promise
end

--[=[
	Gets the current translator to use

	@return Translator?
]=]
function TranslatorService.GetTranslator(self: TranslatorService): Translator?
	return self._translator.Value
end

--[=[
	Observes the current locale id for this translator.

	@return Observable<string>
]=]
function TranslatorService.ObserveLocaleId(self: TranslatorService): Observable.Observable<string>
	if self._localeIdValue then
		return self._localeIdValue:Observe()
	end

	local valueObject = self._maid:Add(ValueObject.new("en-us", "string"))

	valueObject:Mount(self._translator:Observe():Pipe({
		Rx.switchMap(function(translator: Translator): any
			if translator then
				return RxInstanceUtils.observeProperty(translator, "LocaleId")
			else
				-- Fallback
				return self:_observeLoadedPlayer():Pipe({
					Rx.switchMap(function(player: Player)
						if player then
							return RxInstanceUtils.observeProperty(player, "LocaleId")
						else
							return RxInstanceUtils.observeProperty(LocalizationService, "RobloxLocaleId")
						end
					end) :: any,
				})
			end
		end) :: any,
		Rx.distinct() :: any,
	}) :: any)
	self._localeIdValue = valueObject
	return valueObject:Observe()
end

--[=[
	Gets the localeId to use

	@return string
]=]
function TranslatorService.GetLocaleId(self: TranslatorService): string
	local found = self._translator.Value
	if found then
		return found.LocaleId
	end

	-- Fallback
	local player = Players.LocalPlayer
	if player and player.LocaleId ~= "" then
		return player.LocaleId
	else
		return LocalizationService.RobloxLocaleId
	end
end

function TranslatorService._observeTranslatorImpl(self: TranslatorService): Observable.Observable<Translator>
	return self:_observeLoadedPlayer():Pipe({
		Rx.switchMap(function(loadedPlayer: Player): any
			if loadedPlayer then
				return Rx.fromPromise(LocalizationServiceUtils.promisePlayerTranslator(loadedPlayer))
			end

			return RxInstanceUtils.observeProperty(LocalizationService, "RobloxLocaleId"):Pipe({
				Rx.switchMap(function(localeId: string): any
					-- This can actually take a while (20-30 seconds)
					return Rx.fromPromise(LocalizationServiceUtils.promiseTranslatorForLocale(localeId))
				end) :: any,
			})
		end) :: any,
	}) :: any
end

function TranslatorService._observeLoadedPlayer(self: TranslatorService): Observable.Observable<Player>
	if self._loadedPlayerObservable then
		return self._loadedPlayerObservable
	end

	local observable: any = RxInstanceUtils.observeProperty(Players, "LocalPlayer"):Pipe({
		Rx.switchMap(function(player: Player): any
			if not player then
				return Rx.of(nil)
			end

			return RxInstanceUtils.observeProperty(player, "LocaleId"):Pipe({
				Rx.map(function(localeId): Player?
					if localeId == "" then
						return nil
					else
						return player
					end
				end) :: any,
			})
		end) :: any,
		Rx.distinct() :: any,
		Rx.cache() :: any,
	})
	self._loadedPlayerObservable = observable

	return observable
end

function TranslatorService.Destroy(self: TranslatorService)
	self._maid:DoCleaning()
end

return TranslatorService
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="84">
                <Properties>
                  <string name="Name">Utils</string>
                </Properties>
                <Item class="ModuleScript" referent="85">
                  <Properties>
                    <string name="Name">LocalizationServiceUtils</string>
                    <string name="Source"><![CDATA[--[=[
	@class LocalizationServiceUtils
]=]

local require = require(script.Parent.loader).load(script)

local LocalizationService = game:GetService("LocalizationService")
local RunService = game:GetService("RunService")

local Promise = require("Promise")
local PromiseMaidUtils = require("PromiseMaidUtils")

local TIMEOUT = 20
if RunService:IsStudio() then
	TIMEOUT = 0.5
end

local ERROR_PUBLISH_REQUIRED = "Publishing the game is required to use GetTranslatorForPlayerAsync API."
local ERROR_TIMEOUT = string.format("GetTranslatorForPlayerAsync is still pending after %f, using local table", TIMEOUT)

local LocalizationServiceUtils = {}

function LocalizationServiceUtils.promiseTranslatorForLocale(localeId)
	return Promise.spawn(function(resolve, reject)
		local translator = nil
		local ok, err = pcall(function()
			translator = LocalizationService:GetTranslatorForLocaleAsync(localeId)
		end)

		if not ok then
			return reject(err or "Failed to GetTranslatorForLocaleAsync")
		end

		if typeof(translator) ~= "Instance" then
			return reject("Translator was not returned")
		end

		return resolve(translator)
	end)
end

function LocalizationServiceUtils.promisePlayerTranslator(player: Player)
	local promiseTranslator = Promise.spawn(function(resolve, reject)
		local translator = nil
		local ok, err = pcall(function()
			translator = LocalizationService:GetTranslatorForPlayerAsync(player)
		end)

		if not ok then
			return reject(err or "Failed to GetTranslatorForPlayerAsync")
		end

		if typeof(translator) ~= "Instance" then
			return reject("Translator was not returned")
		end

		return resolve(translator)
	end)

	PromiseMaidUtils.whilePromise(promiseTranslator, function(maid)
		maid:GiveTask(task.delay(TIMEOUT, function()
			promiseTranslator:Reject(ERROR_TIMEOUT)
		end))
	end)

	return promiseTranslator:Catch(function(err)
		if err ~= ERROR_PUBLISH_REQUIRED and error ~= ERROR_TIMEOUT then
			warn(string.format("[LocalizationServiceUtils.promisePlayerTranslator] - %s", tostring(err)))
		end

		-- Fallback to just local stuff
		local translator = LocalizationService:GetTranslatorForPlayer(player)
		return translator
	end)
end

return LocalizationServiceUtils
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="86">
                  <Properties>
                    <string name="Name">TranslationKeyUtils</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	@class TranslationKeyUtils
]=]

local require = require(script.Parent.loader).load(script)

local String = require("String")

local TranslationKeyUtils = {}

--[=[
	Converts a string to a translation key in a fixed format, with a maximum length

	@param prefix string
	@param text string
	@return string
]=]
function TranslationKeyUtils.getTranslationKey(prefix: string, text: string): string
	local firstWordsBeginning = string.sub(string.gsub(text, "%s", ""), 1, 20)
	local firstWords = String.toLowerCamelCase(firstWordsBeginning)

	return prefix .. "." .. firstWords
end

return TranslationKeyUtils
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="87">
            <Properties>
              <string name="Name">cmdrservice</string>
            </Properties>
            <Item class="Folder" referent="88">
              <Properties>
                <string name="Name">Client</string>
              </Properties>
              <Item class="ModuleScript" referent="89">
                <Properties>
                  <string name="Name">CmdrServiceClient</string>
                  <string name="Source"><![CDATA[--[=[
	Loads cmdr on the client. See [CmdrService] for the server equivalent.

	@client
	@class CmdrServiceClient
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Maid = require("Maid")
local PermissionServiceClient = require("PermissionServiceClient")
local Promise = require("Promise")
local PromiseUtils = require("PromiseUtils")
local ServiceBag = require("ServiceBag")
local String = require("String")
local promiseChild = require("promiseChild")

local CmdrServiceClient = {}
CmdrServiceClient.ServiceName = "CmdrServiceClient"

--[=[
	Starts the cmdr service on the client. Should be done via [ServiceBag].
	@param serviceBag ServiceBag
]=]
function CmdrServiceClient:Init(serviceBag: ServiceBag.ServiceBag)
	assert(not self._serviceBag, "Already initialized")
	self._serviceBag = assert(serviceBag, "No serviceBag")
	self._maid = Maid.new()

	self._permissionServiceClient = self._serviceBag:GetService(PermissionServiceClient)

	self:PromiseCmdr():Then(function(cmdr)
		cmdr.Registry:RegisterHook("BeforeRun", function(context)
			-- allow!
			if context.Executor == nil then
				return nil
			end

			local providerPromise = self._permissionServiceClient:PromisePermissionProvider()
			if providerPromise:IsPending() then
				return "Still loading permissions"
			end

			local ok, provider = providerPromise:Yield()
			if not ok then
				if type(provider) == "string" then
					return provider
				else
					return "Failed to load permission provider"
				end
			end

			local isAdmin
			ok, isAdmin = provider:PromiseIsAdmin(context.Executor):Yield()
			if not ok then
				if type(provider) == "string" then
					return provider
				else
					return "Failed to load permission provider"
				end
			end

			if not isAdmin then
				return "You don't have permission to run this command"
			else
				-- allow
				return nil
			end
		end)
	end)
end

--[=[
	Starts the service. Should be done via [ServiceBag].
]=]
function CmdrServiceClient:Start()
	assert(self._serviceBag, "Not initialized")

	self._maid
		:GivePromise(PromiseUtils.all({
			self:PromiseCmdr(),
			self._maid:GivePromise(self._permissionServiceClient:PromisePermissionProvider()):Then(function(provider)
				return provider:PromiseIsAdmin()
			end),
		}))
		:Then(function(cmdr, isAdmin)
			if isAdmin then
				self:_setBindings(cmdr)
			else
				cmdr:SetActivationKeys({})
			end
		end)
end

function CmdrServiceClient:_setBindings(cmdr)
	cmdr:SetActivationUnlocksMouse(true)
	cmdr:SetActivationKeys({ Enum.KeyCode.F2 })

	-- enable activation on mobile
	self._maid:GiveTask(Players.LocalPlayer.Chatted:Connect(function(chat)
		if String.startsWith(chat, "/cmdr") then
			cmdr:Show()
		end
	end))

	-- Race condition
	task.defer(function()
		-- Default blink for debugging purposes
		cmdr.Dispatcher:Run("bind", Enum.KeyCode.G.Name, "blink")
	end)
end

--[=[
	Retrieves the cmdr for the client.
	@return Promise<CmdrClient>
]=]
function CmdrServiceClient:PromiseCmdr()
	assert(self._serviceBag, "Not initialized")

	if self._cmdrPromise then
		return self._cmdrPromise
	end

	-- Suppress warning in test mode for hoarcekat
	local timeout = nil
	if not RunService:IsRunning() then
		timeout = 1e10
	end

	self._cmdrPromise = self._maid
		:GivePromise(promiseChild(ReplicatedStorage, "CmdrClient", timeout))
		:Then(function(cmdClient)
			return Promise.spawn(function(resolve, _reject)
				-- Requiring cmdr can yield
				return resolve(require(cmdClient))
			end)
		end)
	self._maid:GiveTask(self._cmdrPromise)

	return self._cmdrPromise
end

function CmdrServiceClient:Destroy()
	self._maid:DoCleaning()
end

return CmdrServiceClient
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="90">
              <Properties>
                <string name="Name">Server</string>
              </Properties>
              <Item class="ModuleScript" referent="91">
                <Properties>
                  <string name="Name">CmdrService</string>
                  <string name="Source"><![CDATA[--[=[
	Bridge to https://eryn.io/Cmdr/

	Uses [PermissionService] to provide permissions.
	@server
	@class CmdrService
]=]

local require = require(script.Parent.loader).load(script)

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local CmdrTemplateProviderServer = require("CmdrTemplateProviderServer")
local CmdrTypes = require("CmdrTypes")
local Maid = require("Maid")
local PermissionService = require("PermissionService")
local Promise = require("Promise")
local ServiceBag = require("ServiceBag")

local CmdrService = {}
CmdrService.ServiceName = "CmdrService"

export type CmdrService = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_serviceBag: ServiceBag.ServiceBag,
		_serviceId: string,
		_promiseCmdr: Promise.Promise<any>,
		_cmdrTemplateProviderServer: any,
		_permissionService: PermissionService.PermissionService,
		_definitionData: { [string]: CmdrTypes.CommandDefinition },
		_executeData: { [string]: (context: CmdrTypes.CommandContext, ...any) -> string? },
	},
	{} :: typeof({ __index = CmdrService })
))

local GLOBAL_REGISTRY = setmetatable({}, { __mode = "kv" })

--[=[
	Initializes the CmdrService. Should be done via [ServiceBag].
	@param serviceBag ServiceBag
]=]
function CmdrService.Init(self: CmdrService, serviceBag: ServiceBag.ServiceBag)
	assert(not (self :: any)._serviceBag, "Already initialized")
	self._maid = Maid.new()
	self._serviceBag = assert(serviceBag, "No serviceBag")

	-- External
	self._permissionService = self._serviceBag:GetService(PermissionService)

	-- Internal
	self._cmdrTemplateProviderServer = self._serviceBag:GetService(CmdrTemplateProviderServer)

	self._serviceId = HttpService:GenerateGUID(false)
	self._promiseCmdr = self._maid:GivePromise(Promise.spawn(function(resolve, reject)
		if not RunService:IsRunning() then
			reject() -- Avoid running when game isn't available
			return
		end

		local cmdr
		local ok, err = pcall(function()
			cmdr = require("Cmdr")
		end)
		if not ok then
			reject(err or "Failed to load cmdr")
			return
		end
		resolve(cmdr)
	end))

	self._definitionData = {}
	self._executeData = {}

	self._promiseCmdr:Then(function(cmdr)
		task.spawn(function()
			cmdr:RegisterDefaultCommands()
		end)

		cmdr.Registry:RegisterHook("BeforeRun", function(context)
			-- allow!
			if context.Executor == nil then
				return nil
			end

			local providerPromise = self._permissionService:PromisePermissionProvider()
			if providerPromise:IsPending() then
				return "Still loading permissions"
			end

			local ok, provider = providerPromise:Yield()
			if not ok then
				if type(provider) == "string" then
					return provider
				else
					return "Failed to load permission provider"
				end
			end

			if not provider:IsAdmin(context.Executor) then
				return "You don't have permission to run this command"
			else
				-- allow
				return nil
			end
		end)
	end)

	GLOBAL_REGISTRY[self._serviceId] = self
end

--[=[
	Returns cmdr
	@return Promise<Cmdr>
]=]
function CmdrService.PromiseCmdr(self: CmdrService)
	assert(self._promiseCmdr, "Not initialized")

	return self._promiseCmdr
end

--[=[
	Registers a command into cmdr.
	@param commandData table
	@param execute (context: table, ... T)
]=]
function CmdrService.RegisterCommand(
	self: CmdrService,
	commandData: CmdrTypes.CommandDefinition,
	execute: (context: CmdrTypes.CommandContext, ...any) -> string?
): ()
	assert((self :: any)._promiseCmdr, "Not initialized")
	assert(commandData, "No commandData")
	assert(commandData.Name, "No commandData.Name")
	assert(execute, "No execute")

	local commandId = string.format("%s_%s", commandData.Name, HttpService:GenerateGUID(false))

	self._definitionData[commandId] = commandData
	self._executeData[commandId] = execute

	local commandServerScript = self._cmdrTemplateProviderServer:Clone("CmdrExecutionTemplate")
	commandServerScript.Name = string.format("%sServer", commandId)

	local cmdrServiceTarget = Instance.new("ObjectValue")
	cmdrServiceTarget.Name = "CmdrServiceTarget"
	cmdrServiceTarget.Value = script
	cmdrServiceTarget.Parent = commandServerScript

	local cmdrServiceId = Instance.new("StringValue")
	cmdrServiceId.Name = "CmdrServiceId"
	cmdrServiceId.Value = self._serviceId
	cmdrServiceId.Parent = commandServerScript

	local cmdrCommandId = Instance.new("StringValue")
	cmdrCommandId.Name = "CmdrCommandId"
	cmdrCommandId.Value = commandId
	cmdrCommandId.Parent = commandServerScript

	local commandScript = self._cmdrTemplateProviderServer:Clone("CmdrCommandDefinitionTemplate")
	commandScript.Name = commandId

	local cmdrJsonCommandData = Instance.new("StringValue")
	cmdrJsonCommandData.Value = HttpService:JSONEncode(commandData)
	cmdrJsonCommandData.Name = "CmdrJsonCommandData"
	cmdrJsonCommandData.Parent = commandScript

	self._promiseCmdr:Then(function(cmdr)
		cmdr.Registry:RegisterCommand(commandScript, commandServerScript)
	end)
end

--[=[
	Private function used by the execution template to retrieve the execution function.
	@param cmdrCommandId string
	@param ... any
	@private
]=]
function CmdrService.__executeCommand(self: CmdrService, cmdrCommandId: string, ...): string?
	assert(type(cmdrCommandId) == "string", "Bad cmdrCommandId")
	assert(self._promiseCmdr, "CmdrService is not initialized yet")

	local execute = self._executeData[cmdrCommandId]
	if not execute then
		error(string.format("[CmdrService] - No command definition for cmdrCommandId %q", tostring(cmdrCommandId)))
	end

	return execute(...)
end

--[=[
	Global usage but only intended for internal use

	@param cmdrServiceId string
	@return CmdrService
	@private
]=]
function CmdrService.__getServiceFromId(_self: CmdrService, cmdrServiceId: string)
	assert(type(cmdrServiceId) == "string", "Bad cmdrServiceId")

	return GLOBAL_REGISTRY[cmdrServiceId]
end

function CmdrService.Destroy(self: CmdrService)
	self._maid:DoCleaning()
end

return CmdrService
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="92">
                <Properties>
                  <string name="Name">CmdrTemplateProviderServer</string>
                  <string name="Source"><![CDATA[--[=[
	Retrieves CmdrTemplateProviderServer
	@class CmdrTemplateProviderServer
]=]

local require = require(script.Parent.loader).load(script)

local TemplateProvider = require("TemplateProvider")

return TemplateProvider.new(script.Name, script)
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="93">
                  <Properties>
                    <string name="Name">CmdrCommandDefinitionTemplate</string>
                    <string name="Source"><![CDATA[--[=[
	Generic command definition template
	@class CmdrCommandDefinitionTemplate
]=]

local HttpService = game:GetService("HttpService")

local value = script:WaitForChild("CmdrJsonCommandData")
return HttpService:JSONDecode(value.Value)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="94">
                  <Properties>
                    <string name="Name">CmdrExecutionTemplate</string>
                    <string name="Source"><![CDATA[--[=[
	Generic command definition template which we can use to
	@class CmdrExecutionTemplate
]=]

local function waitForValue(objectValue)
	local value = objectValue.Value
	if value then
		return value
	end

	return objectValue.Changed:Wait()
end

local cmdrServiceId = waitForValue(script:WaitForChild("CmdrServiceId"))
local cmdrCommandId = waitForValue(script:WaitForChild("CmdrCommandId"))
local commandServiceDefinition = require(waitForValue(script:WaitForChild("CmdrServiceTarget")))
local cmdrService = commandServiceDefinition:__getServiceFromId(cmdrServiceId)

return function(...)
	return cmdrService:__executeCommand(cmdrCommandId, ...)
end
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="Folder" referent="95">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="96">
                <Properties>
                  <string name="Name">CmdrTypes</string>
                  <string name="Source"><![CDATA[--!strict

export type NamedObject = {
	Name: string,
}

export type TypeDefinition<T> = {
	DisplayName: string?,
	Prefixes: string?,
	Transform: ((string, Player) -> T)?,
	Validate: ((T) -> (boolean, string?) | boolean)?,
	ValidateOnce: ((T) -> (boolean, string?) | boolean)?,
	Autocomplete: ((T) -> ({ string }, { IsPartial: boolean? }?) | { string })?,
	Parse: (T) -> any,
	Default: ((Player) -> string)?,
	Listable: boolean?,
}

export type CommandArgument = {
	Type: string | TypeDefinition<any>,
	Name: string,
	Description: string,
	Optional: boolean?,
	Default: any?,
}

export type CommandContext = {
	GetData: (self: CommandContext) -> any,
	GetPlayer: (self: CommandContext) -> Player,
	GetArgs: (self: CommandContext) -> { any },
	GetCommandName: (self: CommandContext) -> string,
	GetCommandId: (self: CommandContext) -> string,
}

export type CommandDefinition = {
	Name: string,
	Aliases: { string }?,
	Description: string,
	Group: any?,
	Args: { CommandArgument | (CommandContext) -> CommandArgument },
	Data: ((CommandContext) -> any)?,
	ClientRun: ((CommandContext, ...any) -> string?)?,
	AutoExec: { string }?,
}

return {}
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="97">
            <Properties>
              <string name="Name">collectionserviceutils</string>
            </Properties>
            <Item class="Folder" referent="98">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="99">
                <Properties>
                  <string name="Name">CollectionServiceUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions for use with collection service tags
	@class CollectionServiceUtils
]=]

local CollectionService = game:GetService("CollectionService")

local CollectionServiceUtils = {}

--[=[
	Finds the first ancestor with the given tagName.
	@param tagName string
	@param child Instance
	@return Instance?
]=]
function CollectionServiceUtils.findFirstAncestor(tagName: string, child: Instance): Instance?
	assert(type(tagName) == "string", "Bad tagName")
	assert(typeof(child) == "Instance", "Bad child")

	local current = child.Parent
	while current do
		if CollectionService:HasTag(current, tagName) then
			return current
		end
		current = current.Parent
	end
	return nil
end

--[=[
	Finds the child with the tag name, or the first ancestor with the given tagName.

	@param tagName string
	@param child Instance
	@return Instance?
]=]
function CollectionServiceUtils.findInstanceOrFirstAncestor(tagName: string, child: Instance): Instance?
	assert(type(tagName) == "string", "Bad tagName")
	assert(typeof(child) == "Instance", "Bad child")

	if CollectionService:HasTag(child, tagName) then
		return child
	end

	return CollectionServiceUtils.findFirstAncestor(tagName, child)
end

--[=[
	Removes all tags from an instance.
	@param instance Instance
]=]
function CollectionServiceUtils.removeAllTags(instance: Instance)
	assert(typeof(instance) == "Instance", "Bad instance")

	for _, tag in CollectionService:GetTags(instance) do
		CollectionService:RemoveTag(instance, tag)
	end
end

return CollectionServiceUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="100">
                <Properties>
                  <string name="Name">RxCollectionServiceUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class RxCollectionServiceUtils
]=]

local require = require(script.Parent.loader).load(script)

local CollectionService = game:GetService("CollectionService")

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")

local RxCollectionServiceUtils = {}

--[=[
	Observes tagged instances

	@param tagName string
	@return Observable<Brio<Instance>>
]=]
function RxCollectionServiceUtils.observeTaggedBrio(tagName: string): Observable.Observable<Brio.Brio<Instance>>
	assert(type(tagName) == "string", "Bad tagName")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleItemAdded(inst)
			local brio = Brio.new(inst)
			maid[inst] = brio
			sub:Fire(brio)
		end

		maid:GiveTask(CollectionService:GetInstanceAddedSignal(tagName):Connect(handleItemAdded))
		maid:GiveTask(CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(inst)
			maid[inst] = nil
		end))

		for _, inst in CollectionService:GetTagged(tagName) do
			task.spawn(handleItemAdded, inst)
		end

		return maid
	end) :: any
end

--[=[
	Observes tagged instances without a brio (so just when the item is added or on-init

	@param tagName string
	@return Observable<Instance>
]=]
function RxCollectionServiceUtils.observeTagged(tagName: string): Observable.Observable<Instance>
	assert(type(tagName) == "string", "Bad tagName")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleItemAdded(inst: Instance)
			sub:Fire(inst)
		end

		maid:GiveTask(CollectionService:GetInstanceAddedSignal(tagName):Connect(handleItemAdded))

		for _, inst in CollectionService:GetTagged(tagName) do
			task.spawn(handleItemAdded, inst)
		end

		return maid
	end) :: any
end

return RxCollectionServiceUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="101">
            <Properties>
              <string name="Name">deferred</string>
            </Properties>
            <Item class="Folder" referent="102">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="103">
                <Properties>
                  <string name="Name">deferred</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	An expensive way to spawn a function. However, unlike spawn(), it executes on the same frame, and
	unlike coroutines, does not obscure errors

	@deprecated 2.0.1
	@class deferred
]=]

return task.defer
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="104">
            <Properties>
              <string name="Name">ducktype</string>
            </Properties>
            <Item class="Folder" referent="105">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="106">
                <Properties>
                  <string name="Name">DuckTypeUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility method to check interface is equivalent for two implementations

	@class DuckTypeUtils
]=]

local DuckTypeUtils = {}

--[=[
	Returns true if a template is similar to a target

	@param template table
	@param target any
	@return boolean
]=]
function DuckTypeUtils.isImplementation(template: any, target: any): boolean
	assert(type(template) == "table", "Bad template")

	return type(target) == "table"
		and (getmetatable(target) == template or DuckTypeUtils._checkInterface(template, target))
end

function DuckTypeUtils._checkInterface(template: any, target: any): boolean
	local targetMetatable = getmetatable(target)
	local templateMetatable = getmetatable(template)
	if targetMetatable and type(targetMetatable.__index) == "function" then
		-- Indexing into this target could cause an error. Treat it differently and fast-fail
		if templateMetatable then
			return templateMetatable.__index == targetMetatable.__index
		end

		return false
	end

	for key, value in template do
		if type(value) == "function" and type(target[key]) ~= "function" then
			return false
		end
	end

	-- TODO: Prevent infinite recursion potential
	if templateMetatable and type(templateMetatable.__index) == "table" then
		return DuckTypeUtils._checkInterface(templateMetatable.__index, target)
	end

	return true
end

return DuckTypeUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="107">
            <Properties>
              <string name="Name">grouputils</string>
            </Properties>
            <Item class="Folder" referent="108">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="109">
                <Properties>
                  <string name="Name">GroupUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Helpful functions involving Roblox groups.
	@class GroupUtils
]=]

local require = require(script.Parent.loader).load(script)

local GroupService = game:GetService("GroupService")

local Promise = require("Promise")

local GroupUtils = {}

--[=[
	Retrieves the rank of the player in the group.

	@param player Player
	@param groupId number
	@return Promise<number> -- Generally from 0 to 255
]=]
function GroupUtils.promiseRankInGroup(player: Player, groupId: number): Promise.Promise<number>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(type(groupId) == "number", "Bad groupId")

	return Promise.spawn(function(resolve, reject)
		local rank = nil
		local ok, err = pcall(function()
			rank = player:GetRankInGroup(groupId)
		end)

		if not ok then
			return reject(err)
		end

		if type(rank) ~= "number" then
			return reject("Rank is not a number")
		end

		return resolve(rank)
	end)
end

--[=[
	Retrieves the role of the player in the group.

	@param player Player
	@param groupId number
	@return Promise<string>
]=]
function GroupUtils.promiseRoleInGroup(player: Player, groupId: number): Promise.Promise<string>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(type(groupId) == "number", "Bad groupId")

	return Promise.spawn(function(resolve, reject)
		local role = nil
		local ok, err = pcall(function()
			role = player:GetRoleInGroup(groupId)
		end)

		if not ok then
			return reject(err)
		end

		if type(role) ~= "string" then
			return reject("Role is not a string")
		end

		return resolve(role)
	end)
end

export type GroupRoleInfo = {
	Name: string,
	Rank: number,
}

export type GroupInfo = {
	Name: string,
	Id: number,
	Owner: {
		Name: string,
		Id: number,
	},
	EmblemUrl: string,
	Description: string,
	Roles: { GroupRoleInfo },
}

--[=[
	Retrieves groupInfo about a group.

	@param groupId number
	@return Promise<table>
]=]
function GroupUtils.promiseGroupInfo(groupId: number): Promise.Promise<GroupInfo>
	assert(groupId, "Bad groupId")

	return Promise.spawn(function(resolve, reject)
		local groupInfo = nil
		local ok, err = pcall(function()
			groupInfo = GroupService:GetGroupInfoAsync(groupId)
		end)

		if not ok then
			return reject(err)
		end

		if type(groupInfo) ~= "table" then
			return reject("Rank is not a number")
		end

		return resolve(groupInfo)
	end)
end

--[=[
	Retrieves group role info for a given rankId

	@param groupId number
	@param rankId number
	@return Promise<table>
]=]
function GroupUtils.promiseGroupRoleInfo(groupId: number, rankId: number): Promise.Promise<GroupRoleInfo>
	assert(groupId, "Bad groupId")
	assert(rankId, "Bad rankId")

	return GroupUtils.promiseGroupInfo(groupId):Then(function(groupInfo)
		if type(groupInfo.Roles) ~= "table" then
			return Promise.rejected("No Roles table")
		end

		for _, rankInfo in groupInfo.Roles do
			if rankInfo.Rank == rankId then
				return rankInfo
			end
		end

		return Promise.rejected("No rank with given id")
	end)
end

return GroupUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="110">
            <Properties>
              <string name="Name">insertserviceutils</string>
            </Properties>
            <Item class="Folder" referent="111">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="112">
                <Properties>
                  <string name="Name">InsertServiceUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class InsertServiceUtils
]=]

local require = require(script.Parent.loader).load(script)

local InsertService = game:GetService("InsertService")

local Promise = require("Promise")

local InsertServiceUtils = {}

--[=[
	Promises the resulting asset is inserted from insert service, or a rejection

	@param assetId number
	@return Promise<Instance>
]=]
function InsertServiceUtils.promiseAsset(assetId: number): Promise.Promise<Instance>
	assert(type(assetId) == "number", "Bad assetId")

	if assetId == 0 then
		return Promise.rejected()
	end

	return Promise.spawn(function(resolve, reject)
		local result
		local ok, err = pcall(function()
			result = InsertService:LoadAsset(assetId)
		end)

		if not ok then
			return reject(err)
		end
		if typeof(result) ~= "Instance" then
			return reject("Result was not an instance")
		end

		return resolve(result)
	end)
end

return InsertServiceUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="113">
            <Properties>
              <string name="Name">instanceutils</string>
            </Properties>
            <Item class="Folder" referent="114">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="115">
                <Properties>
                  <string name="Name">RxInstanceUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions to observe the state of Roblox. This is a very powerful way to query
	Roblox's state.

	:::tip
	Use RxInstanceUtils to program streaming enabled games, and make it easy to debug. This API surface
	lets you use Roblox as a source-of-truth which is very valuable.
	:::

	@class RxInstanceUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")
local Symbol = require("Symbol")

local UNSET_VALUE = Symbol.named("unsetValue")

local RxInstanceUtils = {}

--[=[
	Observes an instance's property

	@param instance Instance
	@param propertyName string
	@return Observable<T>
]=]
function RxInstanceUtils.observeProperty(instance: Instance, propertyName: string): Observable.Observable<any>
	assert(typeof(instance) == "Instance", "'instance' should be of type Instance")
	assert(type(propertyName) == "string", "'propertyName' should be of type string")

	return Observable.new(function(sub)
		local connection = instance:GetPropertyChangedSignal(propertyName):Connect(function()
			sub:Fire((instance :: any)[propertyName], instance)
		end)
		sub:Fire((instance :: any)[propertyName], instance)

		return connection
	end)
end

--[=[
	Observes an instance's ancestry

	@param instance Instance
	@return Observable<Instance>
]=]
function RxInstanceUtils.observeAncestry(instance: Instance): Observable.Observable<Instance>
	local startWithParent = Rx.start(function()
		return instance, instance.Parent
	end)

	return startWithParent(Rx.fromSignal(instance.AncestryChanged)) :: any
end

--[=[
	Observes an instance's ancestry with a brio

	@param instance Instance
	@param className string
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeFirstAncestorBrio(
	instance: Instance,
	className: string
): Observable.Observable<Brio.Brio<Instance>>
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(className) == "string", "Bad className")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local lastFound: Instance? = nil
		local function handleAncestryChanged()
			local found = instance:FindFirstAncestorWhichIsA(className)

			if found then
				if found ~= lastFound then
					lastFound = found
					local brio = Brio.new(found)
					maid._current = brio
					sub:Fire(brio)
				end
			elseif lastFound then
				maid._current = nil
				lastFound = nil
			end
		end

		maid:GiveTask(instance.AncestryChanged:Connect(handleAncestryChanged))
		handleAncestryChanged()

		return maid
	end) :: any
end

--[=[
	Observes the parent of the instance as long as it exists. This is very common when
	initializing parent interfaces or other behaviors using binders.

	@param instance Instance
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeParentBrio(instance: Instance): Observable.Observable<Brio.Brio<Instance>>
	return RxInstanceUtils.observePropertyBrio(instance, "Parent", function(parent)
		return parent ~= nil
	end) :: any
end

--[=[
	Observes an instance's ancestry

	@param instance Instance
	@param className string
	@return Observable<Instance?>
]=]
function RxInstanceUtils.observeFirstAncestor(instance: Instance, className: string): Observable.Observable<Instance?>
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(className) == "string", "Bad className")

	return Observable.new(function(sub)
		local lastFound = UNSET_VALUE
		local function handleAncestryChanged()
			local found = instance:FindFirstAncestorWhichIsA(className)
			if found ~= lastFound then
				lastFound = found
				sub:Fire(found)
			end
		end

		local connection = instance.AncestryChanged:Connect(handleAncestryChanged)
		handleAncestryChanged()

		return connection
	end)
end

--[=[
	Returns a brio of the property value

	@param instance Instance
	@param propertyName string
	@param predicate ((value: T) -> boolean)? -- Optional filter
	@return Observable<Brio<T>>
]=]
function RxInstanceUtils.observePropertyBrio(
	instance: Instance,
	propertyName: string,
	predicate: Rx.Predicate<any>?
): Observable.Observable<Brio.Brio<any>>
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(propertyName) == "string", "Bad propertyName")
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()
		local lastValue = UNSET_VALUE

		local function handlePropertyChanged()
			local propertyValue = (instance :: any)[propertyName]

			-- Deferred events can cause multiple values to be queued at once
			-- but we operate at this post-deferred layer, so lets only output
			-- reflected values.
			if lastValue ~= propertyValue then
				lastValue = propertyValue

				if not predicate or predicate(propertyValue) then
					local brio = Brio.new((instance :: any)[propertyName])

					maid._lastBrio = brio

					-- The above line can cause us to be overwritten so make sure before firing.
					if maid._lastBrio == brio then
						sub:Fire(brio)
					end
				else
					maid._lastBrio = nil
				end
			end
		end

		maid:GiveTask(instance:GetPropertyChangedSignal(propertyName):Connect(handlePropertyChanged))
		handlePropertyChanged()

		return maid
	end) :: any
end

--[=[
	Observes the last child with a specific name.

	@param parent Instance
	@param className string
	@param name string
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeLastNamedChildBrio(
	parent: Instance,
	className: string,
	name: string
): Observable.Observable<Brio.Brio<Instance>>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")
	assert(type(name) == "string", "Bad name")

	return Observable.new(function(sub)
		local topMaid = Maid.new()

		local function handleChild(child: Instance)
			if not child:IsA(className) then
				return
			end

			local maid = Maid.new()

			local function handleNameChanged()
				if child.Name == name then
					local brio = Brio.new(child)
					maid._brio = brio
					topMaid._lastBrio = brio

					sub:Fire(brio)
				else
					maid._brio = nil
				end
			end

			maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(handleNameChanged))
			handleNameChanged()

			topMaid[child] = maid
		end

		topMaid:GiveTask(parent.ChildAdded:Connect(handleChild))
		topMaid:GiveTask(parent.ChildRemoved:Connect(function(child)
			topMaid[child] = nil
		end))

		for _, child in parent:GetChildren() do
			handleChild(child)
		end

		return topMaid
	end) :: any
end

--[=[
	Observes the children with a specific name.

	@param parent Instance
	@param className string
	@param name string
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeChildrenOfNameBrio(
	parent: Instance,
	className: string,
	name: string
): Observable.Observable<Brio.Brio<Instance>>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")
	assert(type(name) == "string", "Bad name")

	return Observable.new(function(sub)
		local topMaid = Maid.new()

		local function handleChild(child: Instance)
			if not child:IsA(className) then
				return
			end

			local maid = Maid.new()

			local function handleNameChanged()
				if child.Name == name then
					local brio = Brio.new(child)
					maid._brio = brio

					sub:Fire(brio)
				else
					maid._brio = nil
				end
			end

			topMaid[child] = maid

			maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(handleNameChanged))
			handleNameChanged()
		end

		topMaid:GiveTask(parent.ChildAdded:Connect(handleChild))
		topMaid:GiveTask(parent.ChildRemoved:Connect(function(child)
			topMaid[child] = nil
		end))

		for _, child in parent:GetChildren() do
			handleChild(child)
		end

		return topMaid
	end) :: any
end

--[=[
	Observes all children of a specific class

	@param parent Instance
	@param className string
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeChildrenOfClassBrio(
	parent: Instance,
	className: string
): Observable.Observable<Brio.Brio<Instance>>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")

	return RxInstanceUtils.observeChildrenBrio(parent, function(child)
		return child:IsA(className)
	end)
end

--[=[
	Observes all children

	@param parent Instance
	@param predicate ((value: Instance) -> boolean)? -- Optional filter
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeChildrenBrio(
	parent: Instance,
	predicate: Rx.Predicate<Instance>?
): Observable.Observable<Brio.Brio<Instance>>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleChild(child: Instance)
			if not predicate or predicate(child) then
				local value = Brio.new(child)
				maid[child] = value
				sub:Fire(value)
			end
		end

		maid:GiveTask(parent.ChildAdded:Connect(handleChild))
		maid:GiveTask(parent.ChildRemoved:Connect(function(child)
			maid[child] = nil
		end))

		for _, child in parent:GetChildren() do
			handleChild(child)
		end

		return maid
	end) :: any
end

--[=[
	Observes all descendants that match a predicate

	@param parent Instance
	@param predicate ((value: Instance) -> boolean)? -- Optional filter
	@return Observable<Instance, boolean>
]=]
function RxInstanceUtils.observeDescendants(
	parent: Instance,
	predicate: Rx.Predicate<Instance>?
): Observable.Observable<Instance, boolean>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()
		local added = {}

		local function handleDescendant(child)
			if not predicate or predicate(child) then
				added[child] = true
				sub:Fire(child, true)
			end
		end

		maid:GiveTask(parent.DescendantAdded:Connect(handleDescendant))
		maid:GiveTask(parent.DescendantRemoving:Connect(function(child)
			if added[child] then
				added[child] = nil
				sub:Fire(child, false)
			end
		end))

		for _, descendant in parent:GetDescendants() do
			handleDescendant(descendant)
		end

		return maid
	end) :: any
end

--[=[
	Observes all descendants that match a predicate as a brio

	@param parent Instance
	@param predicate ((value: Instance) -> boolean)? -- Optional filter
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeDescendantsBrio(
	parent: Instance,
	predicate: Rx.Predicate<Instance>?
): Observable.Observable<Brio.Brio<Instance>>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleDescendant(descendant)
			if not predicate or predicate(descendant) then
				local value = Brio.new(descendant)
				maid[descendant] = value
				sub:Fire(value)
			end
		end

		maid:GiveTask(parent.DescendantAdded:Connect(handleDescendant))
		maid:GiveTask(parent.DescendantRemoving:Connect(function(descendant)
			maid[descendant] = nil
		end))

		for _, descendant in parent:GetDescendants() do
			handleDescendant(descendant)
		end

		return maid
	end) :: any
end

--[=[
	Observes all descendants of a specific class

	@param parent Instance
	@param className string
	@return Observable<Instance>
]=]
function RxInstanceUtils.observeDescendantsOfClassBrio(
	parent: Instance,
	className: string
): Observable.Observable<Brio.Brio<Instance>>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")

	return RxInstanceUtils.observeDescendantsBrio(parent, function(child: Instance)
		return child:IsA(className)
	end)
end

return RxInstanceUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="116">
                <Properties>
                  <string name="Name">RxInstanceUtils.spec</string>
                  <string name="Source"><![CDATA[--[[
	@class RxInstanceUtils.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local RxInstanceUtils = require("RxInstanceUtils")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("RxInstanceUtils.observeChildrenBrio", function()
	local part = Instance.new("Part")
	local observe = RxInstanceUtils.observeChildrenBrio(part)
	local externalResult = nil

	it("should not emit anything", function()
		observe:Subscribe(function(result)
			externalResult = result
		end)

		expect(externalResult).toEqual(nil)
	end)
end)
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="117">
            <Properties>
              <string name="Name">linkutils</string>
            </Properties>
            <Item class="Folder" referent="118">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="119">
                <Properties>
                  <string name="Name">LinkUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions for links. Links are an [ObjectValue] pointing to something else!
	@class LinkUtils
]=]

local require = require(script.Parent.loader).load(script)

local promiseChild = require("promiseChild")
local promisePropertyValue = require("promisePropertyValue")

local LinkUtils = {}

--[=[
	Creates a new link with the given name.
	@param linkName string
	@param from Instance
	@param to Instance
	@return ObjectValue
]=]
function LinkUtils.createLink(linkName: string, from: Instance, to: Instance): ObjectValue
	assert(type(linkName) == "string", "Bad linkName")
	assert(typeof(from) == "Instance", "Bad from")
	assert(typeof(to) == "Instance", "Bad to")

	local objectValue = Instance.new("ObjectValue")
	objectValue.Name = linkName
	objectValue.Value = to
	objectValue.Archivable = false
	objectValue.Parent = from

	return objectValue
end

--[=[
	Gets all link values, as long as the values are not nil.
	@param linkName string
	@param from Instance
	@return { Instance }
]=]
function LinkUtils.getAllLinkValues(linkName: string, from: Instance): { Instance }
	assert(type(linkName) == "string", "Bad linkName")
	assert(typeof(from) == "Instance", "Bad from")

	local linkValues: { Instance } = {}

	for _, item in from:GetChildren() do
		if item:IsA("ObjectValue") and item.Name == linkName then
			local value = item.Value
			if value then
				table.insert(linkValues, value)
			end
		end
	end

	return linkValues
end

--[=[
	Ensures after operation a single link is pointed to the value, unless the value is "nil"
	in which case no link will be set

	@param linkName string
	@param from Instance
	@param to Instance
	@return Instance?
]=]
function LinkUtils.setSingleLinkValue(linkName: string, from: Instance, to: Instance): ObjectValue?
	assert(type(linkName) == "string", "Bad linkName")
	assert(typeof(from) == "Instance", "Bad from")
	assert(typeof(to) == "Instance" or to == nil, "Bad to")

	if to then
		local existingLink = nil
		for _, link in from:GetChildren() do
			if link:IsA("ObjectValue") and link.Name == linkName then
				if existingLink then
					link:Destroy()
				else
					existingLink = link
					link.Value = to
				end
			end
		end

		if existingLink then
			return existingLink
		end

		return LinkUtils.createLink(linkName, from, to)
	else
		for _, link in from:GetChildren() do
			if link:IsA("ObjectValue") and link.Name == linkName then
				link:Destroy()
			end
		end

		return nil
	end
end

--[=[
	Gets all links underneath an instance.
	@param linkName string
	@param from Instance
	@return { ObjectValue }
]=]
function LinkUtils.getAllLinks(linkName: string, from: Instance): { ObjectValue }
	assert(type(linkName) == "string", "Bad linkName")
	assert(typeof(from) == "Instance", "Bad from")

	local links = {}
	for _, item in from:GetChildren() do
		if item:IsA("ObjectValue") and item.Name == linkName then
			table.insert(links, item)
		end
	end

	return links
end

--[=[
	Gets the first links value
	@param linkName string
	@param from Instance
	@return Instance
]=]
function LinkUtils.getLinkValue(linkName: string, from: Instance): Instance?
	assert(type(linkName) == "string", "Bad linkName")
	assert(typeof(from) == "Instance", "Bad from")

	local objectValue = from:FindFirstChild(linkName)
	if not objectValue then
		return nil
	end

	if not objectValue:IsA("ObjectValue") then
		warn(
			string.format(
				"[LinkUtils.getLinkValue] - Bad link %q not an object value, from %q",
				objectValue:GetFullName(),
				from:GetFullName()
			)
		)
		return nil
	end

	return objectValue.Value
end

--[=[
	Promises the first link value that is truthy
	@param maid Maid
	@param linkName string
	@param from Instance
	@return Promise<Instance>
]=]
function LinkUtils.promiseLinkValue(maid, linkName: string, from: Instance)
	assert(maid, "Bad maid")
	assert(type(linkName) == "string", "Bad linkName")
	assert(typeof(from) == "Instance", "Bad from")

	local childPromise = promiseChild(from, linkName)
	maid:GiveTask(childPromise)

	return childPromise:Then(function(objectValue: ObjectValue)
		local promise = promisePropertyValue(objectValue, "Value")
		maid:GiveTask(promise)

		return promise
	end)
end

return LinkUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="120">
                <Properties>
                  <string name="Name">RxLinkUtils</string>
                  <string name="Source"><![CDATA[--[=[
	@class RxLinkUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local RxInstanceUtils = require("RxInstanceUtils")

local RxLinkUtils = {}

-- Emits valid links in format Brio.new(link, linkValue)
function RxLinkUtils.observeValidLinksBrio(linkName: string, parent: Instance)
	assert(type(linkName) == "string", "linkName should be 'string'")
	assert(typeof(parent) == "Instance", "parent should be 'Instance'")

	return RxInstanceUtils.observeChildrenBrio(parent):Pipe({
		Rx.flatMap(function(brio)
			local instance: Instance = brio:GetValue()
			if not instance:IsA("ObjectValue") then
				return Rx.EMPTY
			end

			return RxBrioUtils.completeOnDeath(brio, RxLinkUtils.observeValidityBrio(linkName, instance))
		end),
	})
end

--[=[
	Observes a link value that is not nil.

	@param linkName string
	@param parent Instance
	@return Brio<Instance>
]=]
function RxLinkUtils.observeLinkValueBrio(linkName: string, parent: Instance)
	assert(type(linkName) == "string", "linkName should be 'string'")
	assert(typeof(parent) == "Instance", "parent should be 'Instance'")

	return RxInstanceUtils.observeChildrenOfNameBrio(parent, "ObjectValue", linkName):Pipe({
		RxBrioUtils.flatMapBrio(function(instance)
			return RxInstanceUtils.observePropertyBrio(instance, "Value", function(value: Instance?)
				return value ~= nil
			end)
		end),
	})
end

-- Fires off everytime the link is reconfigured into a valid link
-- Fires with link, linkValue
function RxLinkUtils.observeValidityBrio(linkName: string, link: Instance)
	assert(typeof(link) == "Instance" and link:IsA("ObjectValue"), "Bad link")
	assert(type(linkName) == "string", "Bad linkName")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function updateValidity()
			if not ((link.Name == linkName) and link.Value) then
				maid._lastValid = nil
				return
			end

			local newValid = Brio.new(link, link.Value)
			maid._lastValid = newValid
			sub:Fire(newValid)
		end

		maid:GiveTask(link:GetPropertyChangedSignal("Value"):Connect(updateValidity))
		maid:GiveTask(link:GetPropertyChangedSignal("Name"):Connect(updateValidity))
		updateValidity()

		return maid
	end)
end

return RxLinkUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="121">
            <Properties>
              <string name="Name">loader</string>
              <string name="Source"><![CDATA[--[=[
	Primary loader which handles bootstrapping different scenarios quickly

	@class loader
]=]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local DependencyUtils = require(script.Dependencies.DependencyUtils)
local LoaderLinkCreator = require(script.LoaderLink.LoaderLinkCreator)
local LoaderLinkUtils = require(script.LoaderLink.LoaderLinkUtils)
local Maid = require(script.Maid)
local PackageTrackerProvider = require(script.Dependencies.PackageTrackerProvider)
local ReplicationType = require(script.Replication.ReplicationType)
local ReplicationTypeUtils = require(script.Replication.ReplicationTypeUtils)
local Replicator = require(script.Replication.Replicator)
local ReplicatorReferences = require(script.Replication.ReplicatorReferences)

local GLOBAL_PACKAGE_TRACKER = PackageTrackerProvider.new()
script.Destroying:Connect(function()
	GLOBAL_PACKAGE_TRACKER:Destroy()
end)

local Loader = {}
Loader.__index = Loader
Loader.ClassName = "Loader"

function Loader.new(packages, replicationType)
	assert(typeof(packages) == "Instance", "Bad packages")
	assert(ReplicationTypeUtils.isReplicationType(replicationType), "Bad replicationType")

	local self = setmetatable({}, Loader)

	self._maid = Maid.new()

	self._replicationType = assert(replicationType, "No replicationType")
	self._packages = assert(packages, "No packages")

	return self
end

function Loader.bootstrapGame(packages)
	assert(typeof(packages) == "Instance", "Bad packages")

	local self = Loader.new(packages, ReplicationTypeUtils.inferReplicationType())

	if self._replicationType == ReplicationType.SERVER then
		self:_setupLoaderPopulation(self._packages)

		-- Trade off security for performance
		if RunService:IsStudio() then
			packages.Parent = ReplicatedStorage
		else
			self:_setupClientReplication()
		end
	end

	GLOBAL_PACKAGE_TRACKER:AddPackageRoot(packages)

	return self
end

function Loader.bootstrapPlugin(packages)
	assert(typeof(packages) == "Instance", "Bad packages")

	local self = Loader.new(packages, ReplicationType.PLUGIN)

	self:_setupLoaderPopulation(self._packages)

	GLOBAL_PACKAGE_TRACKER:AddPackageRoot(packages)

	return self
end

function Loader.bootstrapStory(storyScript)
	assert(typeof(storyScript) == "Instance", "Bad storyScript")

	-- Prepopulate global package roots
	local topNodeModules = storyScript
	for node_modules in DependencyUtils.iterNodeModulesUp(storyScript) do
		topNodeModules = node_modules
	end

	local self = Loader.new(storyScript, ReplicationType.PLUGIN)

	local root = topNodeModules.Parent

	self:_setupLoaderPopulation(root)

	-- Track the package root
	GLOBAL_PACKAGE_TRACKER:AddPackageRoot(root)

	return self
end

function Loader.load(packagesOrModuleScript)
	assert(typeof(packagesOrModuleScript) == "Instance", "Bad packagesOrModuleScript")

	local self = Loader.new(packagesOrModuleScript, ReplicationTypeUtils.inferReplicationType())

	return self
end

function Loader:__index(request)
	if Loader[request] then
		return Loader[request]
	end

	return self:_findDependency(request)
end

function Loader:__call(request)
	if type(request) == "string" then
		local module = self:_findDependency(request)
		return require(module)
	else
		return require(request)
	end
end

function Loader:_findDependency(request: string)
	assert(type(request) == "string", "Bad request")

	local packageTracker = GLOBAL_PACKAGE_TRACKER:FindPackageTracker(self._packages)
	if packageTracker then
		local foundDependency = packageTracker:ResolveDependency(request, self._replicationType)
		if foundDependency then
			return foundDependency
		end

		-- Otherwise let's fail with an error acknowledging that the module exists
		if self._replicationType == ReplicationType.SERVER or self._replicationType == ReplicationType.SHARED then
			local foundClientDependency = packageTracker:ResolveDependency(request, ReplicationType.CLIENT)
			if foundClientDependency then
				error(string.format("[Loader] - %q is only available on the client", foundClientDependency.Name))
			end
		end

		if self._replicationType == ReplicationType.CLIENT or self._replicationType == ReplicationType.SHARED then
			local foundServerDependency = packageTracker:ResolveDependency(request, ReplicationType.SERVER)
			if foundServerDependency then
				error(string.format("[Loader] - %q is only available on the server", foundServerDependency.Name))
			end
		end
	end

	-- Just standard dependency search
	local foundBackup = DependencyUtils.findDependency(self._packages, request, self._replicationType)
	if foundBackup then
		if packageTracker then
			warn(
				string.format(
					"[Loader] - No package tracker for root %s (while loading %s)\n%s",
					self._packages:GetFullName(),
					request,
					debug.traceback()
				)
			)
		else
			warn(
				string.format(
					"[Loader] - Failed to find package %q in package tracker of root %s\n%s",
					request,
					self._packages:GetFullName(),
					debug.traceback()
				)
			)
		end

		-- Ensure hoarcekat story has a link to use
		-- TODO: Maybe add to global package cache instead...
		local parent = foundBackup.Parent
		if parent and not parent:FindFirstChild("loader") then
			local link = LoaderLinkUtils.create(script, "loader")
			link.Parent = parent
		end

		return foundBackup
	end

	-- TODO: Track location and provider install command
	error(
		string.format(
			"[Loader] - %q is not available. Please make this module or install it to the package requiring it.",
			request
		)
	)
	return nil
end

function Loader:_setupClientReplication()
	local copy = self._maid:Add(Instance.new("Folder"))
	copy.Name = self._packages.Name

	local references = ReplicatorReferences.new()

	local replicator = self._maid:Add(Replicator.new(references))
	replicator:SetTarget(copy)
	replicator:ReplicateFrom(self._packages)

	self._maid:Add(LoaderLinkCreator.new(copy, references, true))

	copy.Parent = ReplicatedStorage
end

function Loader:_setupLoaderPopulation(root)
	self._maid:Add(LoaderLinkCreator.new(root, nil, true))
end

function Loader:Destroy()
	self._maid:DoCleaning()
	setmetatable(self, nil)
end

return Loader
]]></string>
            </Properties>
            <Item class="Folder" referent="122">
              <Properties>
                <string name="Name">Dependencies</string>
              </Properties>
              <Item class="ModuleScript" referent="123">
                <Properties>
                  <string name="Name">DependencyUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Very inefficient search utility function to find dependencies
	organized in node_modules structure.

	@class DependencyUtils
]=]

local loader = script.Parent.Parent
local ReplicationType = require(loader.Replication.ReplicationType)
local ReplicationTypeUtils = require(loader.Replication.ReplicationTypeUtils)

local DependencyUtils = {}

--[=[
	Iteratively searches for a dependency based upon packages and current modules using the node_modules
	dependency resolution algorithm.

	@param requester Instance
	@param moduleName string
	@param requestedReplicationType ReplicationType
	@return ModuleScript?
]=]
function DependencyUtils.findDependency(
	requester,
	moduleName: string,
	requestedReplicationType: ReplicationType.ReplicationType
): ModuleScript?
	assert(typeof(requester) == "Instance", "Bad requester")
	assert(type(moduleName) == "string", "Bad moduleName")
	assert(ReplicationTypeUtils.isReplicationType(requestedReplicationType), "Bad requestedReplicationType")

	for packageInst in DependencyUtils.iterPackages(requester) do
		for module: ModuleScript, replicationType: ReplicationType.ReplicationType in
			DependencyUtils.iterModules(packageInst, ReplicationType.SHARED)
		do
			if module.Name == moduleName then
				if ReplicationTypeUtils.isAllowed(replicationType, requestedReplicationType) then
					return module
				else
					error(
						string.format(
							"[DependencyUtils] - %q is not allowed in %q",
							moduleName,
							requestedReplicationType
						)
					)
				end
			end
		end
	end

	return nil
end

function DependencyUtils.iterModules(
	packageInst: Instance,
	ancestorReplicationType: ReplicationType.ReplicationType
): () -> (ModuleScript, ReplicationType.ReplicationType)
	assert(typeof(packageInst) == "Instance", "Bad packageInst")
	assert(ReplicationTypeUtils.isReplicationType(ancestorReplicationType), "Bad ancestorReplicationType")

	return coroutine.wrap(function(): any
		if packageInst:IsA("ModuleScript") then
			coroutine.yield(packageInst, ancestorReplicationType)
			return
		end

		-- Iterate over the package contents
		for _, item in packageInst:GetChildren() do
			local itemName: string = item.Name
			local itemReplicationType: ReplicationType.ReplicationType =
				ReplicationTypeUtils.getFolderReplicationType(itemName, ancestorReplicationType)

			if itemName ~= "node_modules" then
				for result, resultReplicationType in DependencyUtils.iterModules(item, itemReplicationType) do
					coroutine.yield(result, resultReplicationType)
				end
			end
		end

		return
	end) :: any
end

function DependencyUtils.iterPackages(requester: Instance): () -> Instance
	assert(typeof(requester) == "Instance", "Bad requester")

	return coroutine.wrap(function(): any
		for nodeModules in DependencyUtils.iterNodeModulesUp(requester) do
			coroutine.yield(nodeModules.Parent)

			for packageInst in DependencyUtils.iterPackagesInModuleModules(nodeModules) do
				coroutine.yield(packageInst)
			end
		end

		return
	end)
end

function DependencyUtils.iterNodeModulesUp(module: Instance): () -> Instance
	assert(typeof(module) == "Instance", "Bad module")

	return coroutine.wrap(function(): any
		local found = module:FindFirstChild("node_modules")
		if found and found:IsA("Folder") then
			coroutine.yield(found)
		end

		local current: Instance? = module.Parent
		while current do
			found = current:FindFirstChild("node_modules")
			if found and found:IsA("Folder") then
				coroutine.yield(found)
			end
			current = current.Parent :: Instance?
		end

		return
	end)
end

function DependencyUtils.iterPackagesInModuleModules(nodeModules: Instance): () -> Instance
	return coroutine.wrap(function(): any
		for _, item in nodeModules:GetChildren() do
			if item:IsA("Folder") then
				if DependencyUtils.isPackageGroup(item.Name) then
					for _, child in item:GetChildren() do
						if child:IsA("ModuleScript") or child:IsA("Folder") then
							coroutine.yield(child)
						elseif child:IsA("ObjectValue") then
							local linked = child.Value
							if linked then
								if linked:IsA("ModuleScript") or linked:IsA("Folder") then
									coroutine.yield(linked)
								else
									warn("[DependencyUtils] - Bad link value type")
								end
							else
								warn(string.format("[DependencyUtils] - Nothing linked on %s", child:GetFullName()))
							end
						end
					end
				else
					coroutine.yield(item)
				end
			elseif item:IsA("ModuleScript") then
				coroutine.yield(item)
			elseif item:IsA("ObjectValue") then
				local linked = item.Value
				if linked then
					if linked:IsA("ModuleScript") or linked:IsA("Folder") then
						coroutine.yield(linked)
					else
						warn("[DependencyUtils] - Bad link value type")
					end
				else
					warn(string.format("[DependencyUtils] - Nothing linked on %s", item:GetFullName()))
				end
			end
		end

		return
	end)
end

function DependencyUtils.isPackageGroup(itemName: string): boolean
	return string.sub(itemName, 1, 1) == "@"
end

return DependencyUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="124">
                <Properties>
                  <string name="Name">PackageTracker</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	For each package, track subdependent packages and packages

	@class PackageTracker
]=]

local loader = script.Parent.Parent
local DependencyUtils = require(loader.Dependencies.DependencyUtils)
local Maid = require(loader.Maid)
local ReplicationType = require(loader.Replication.ReplicationType)
local ReplicationTypeUtils = require(loader.Replication.ReplicationTypeUtils)

local PackageTracker = {}
PackageTracker.ClassName = "PackageTracker"
PackageTracker.__index = PackageTracker

export type ModuleScriptInfo = {
	moduleScript: ModuleScript,
	replicationType: ReplicationType.ReplicationType,
}

export type PackageTrackerProvider = {
	FindPackageTracker: (self: PackageTrackerProvider, instance: Instance) -> PackageTracker?,
	AddPackageRoot: (self: PackageTrackerProvider, instance: Instance) -> PackageTracker,
}

export type PackageTracker = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_packageTrackerProvider: PackageTrackerProvider,
		_packageRoot: Instance,
		_subpackagesMap: { [string]: Instance },
		_subpackagesTrackerList: { PackageTracker },
		_packageModuleScriptMap: { [string]: ModuleScriptInfo },
	},
	{} :: typeof({ __index = PackageTracker })
))

function PackageTracker.new(packageTrackerProvider: PackageTrackerProvider, packageRoot: Instance): PackageTracker
	assert(packageTrackerProvider, "No packageTrackerProvider")
	assert(typeof(packageRoot) == "Instance", "Bad packageRoot")

	local self = setmetatable({}, PackageTracker)
	self._maid = Maid.new()

	self._packageTrackerProvider = assert(packageTrackerProvider, "No packageTrackerProvider")
	self._packageRoot = assert(packageRoot, "No packageRoot")

	self._subpackagesMap = {} :: { [string]: Instance }
	self._subpackagesTrackerList = {} :: { PackageTracker }
	self._packageModuleScriptMap = {} :: { [string]: ModuleScriptInfo }

	return self
end

function PackageTracker.StartTracking(self: PackageTracker)
	local moduleScript: ModuleScript? = nil
	if self._packageRoot:IsA("ModuleScript") then
		moduleScript = self._packageRoot
	end

	if moduleScript ~= nil then
		-- Module script children don't get to be observed
		self._maid:GiveTask(self:_trackModuleScript(moduleScript, ReplicationType.SHARED))
	else
		local root = self._packageRoot :: Instance
		self._maid:GiveTask(self:_trackChildren(root, ReplicationType.SHARED))
	end
end

function PackageTracker.ResolveDependency(
	self: PackageTracker,
	request: string,
	replicationType: ReplicationType.ReplicationType
): ModuleScript?
	local packageModuleScript = self:FindPackageModuleScript(request, replicationType)
	if packageModuleScript then
		return packageModuleScript
	end

	local subpackageModuleScript = self:FindSubpackageModuleScript(request, replicationType)
	if subpackageModuleScript then
		return subpackageModuleScript
	end

	local parentModuleScript = self:FindImplicitParentModuleScript(request, replicationType)
	if parentModuleScript then
		return parentModuleScript
	end

	return nil
end

function PackageTracker.FindImplicitParentModuleScript(
	self: PackageTracker,
	request: string,
	replicationType: ReplicationType.ReplicationType
): ModuleScript?
	assert(type(request) == "string", "Bad request")
	assert(ReplicationTypeUtils.isReplicationType(replicationType), "Bad replicationType")

	-- Implicit dependencies
	local packageRootParent = self._packageRoot.Parent
	if not packageRootParent then
		return nil
	end

	local parentProvider = self._packageTrackerProvider:FindPackageTracker(packageRootParent)
	if not parentProvider then
		return nil
	end

	-- Check parent provider for implicit dependency
	local subpackageModuleScript = parentProvider:FindSubpackageModuleScript(request, replicationType)
	if subpackageModuleScript then
		return subpackageModuleScript
	end

	return parentProvider:FindImplicitParentModuleScript(request, replicationType) :: ModuleScript?
end

function PackageTracker.FindPackageModuleScript(
	self: PackageTracker,
	moduleScriptName: string,
	replicationType: ReplicationType.ReplicationType
): ModuleScript?
	assert(type(moduleScriptName) == "string", "Bad moduleScriptName")
	assert(ReplicationTypeUtils.isReplicationType(replicationType), "Bad replicationType")

	local found = self._packageModuleScriptMap[moduleScriptName]

	if found then
		if ReplicationTypeUtils.isAllowed(found.replicationType, replicationType) then
			return found.moduleScript
		else
			return nil
		end
	else
		return nil
	end
end

function PackageTracker.FindSubpackageModuleScript(
	self: PackageTracker,
	moduleScriptName: string,
	replicationType: ReplicationType.ReplicationType
): ModuleScript?
	assert(type(moduleScriptName) == "string", "Bad moduleScriptName")
	assert(ReplicationTypeUtils.isReplicationType(replicationType), "Bad replicationType")

	for _, packageTracker in self._subpackagesTrackerList do
		local found = packageTracker._packageModuleScriptMap[moduleScriptName]
		if found then
			if ReplicationTypeUtils.isAllowed(found.replicationType, replicationType) then
				return found.moduleScript
			else
				return nil
			end
		end
	end

	return nil
end

function PackageTracker._trackChildrenAndReplicationType(
	self: PackageTracker,
	parent: Instance,
	ancestorReplicationType: ReplicationType.ReplicationType
)
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(ReplicationTypeUtils.isReplicationType(ancestorReplicationType), "Bad ancestorReplicationType")

	local maid = Maid.new()

	local lastReplicationType: ReplicationType.ReplicationType =
		ReplicationTypeUtils.getFolderReplicationType(parent.Name, ancestorReplicationType)

	maid:GiveTask(parent:GetPropertyChangedSignal("Name"):Connect(function()
		local newReplicationType: ReplicationType.ReplicationType =
			ReplicationTypeUtils.getFolderReplicationType(parent.Name, ancestorReplicationType)
		if newReplicationType ~= lastReplicationType then
			maid._current = self:_trackChildren(parent, newReplicationType)
			lastReplicationType = newReplicationType
		end
	end))

	maid._current = self:_trackChildren(parent, lastReplicationType)

	return maid
end

function PackageTracker._trackChildren(
	self: PackageTracker,
	parent: Instance,
	ancestorReplicationType: ReplicationType.ReplicationType
): Maid.Maid
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(ReplicationTypeUtils.isReplicationType(ancestorReplicationType), "Bad ancestorReplicationType")

	local maid = Maid.new()

	maid:GiveTask(parent.ChildAdded:Connect(function(child)
		self:_handleChildAdded(maid, child, ancestorReplicationType)
	end))
	maid:GiveTask(parent.ChildRemoved:Connect(function(child)
		self:_handleChildRemoved(maid, child)
	end))
	for _, child in parent:GetChildren() do
		self:_handleChildAdded(maid, child, ancestorReplicationType)
	end

	return maid
end

function PackageTracker._handleChildAdded(
	self: PackageTracker,
	parentMaid: Maid.Maid,
	child: Instance,
	ancestorReplicationType: ReplicationType.ReplicationType
)
	assert(Maid.isMaid(parentMaid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")
	assert(ReplicationTypeUtils.isReplicationType(ancestorReplicationType), "Bad ancestorReplicationType")

	if child:IsA("ModuleScript") then
		parentMaid[child] = self:_trackModuleScript(child, ancestorReplicationType)
	elseif child:IsA("Folder") then
		parentMaid[child] = self:_trackFolder(child, ancestorReplicationType)
	end
end

function PackageTracker._handleChildRemoved(_self: PackageTracker, parentMaid: Maid.Maid, child: Instance)
	assert(Maid.isMaid(parentMaid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")

	parentMaid[child] = nil
end

function PackageTracker._trackFolder(
	self: PackageTracker,
	child: Instance,
	ancestorReplicationType: ReplicationType.ReplicationType
)
	assert(typeof(child) == "Instance", "Bad child")
	assert(ReplicationTypeUtils.isReplicationType(ancestorReplicationType), "Bad ancestorReplicationType")

	local maid = Maid.new()

	maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(function()
		if child.Name == "node_modules" then
			maid._current = self:_trackMainNodeModuleFolder(child)
		else
			maid._current = self:_trackChildrenAndReplicationType(child, ancestorReplicationType)
		end
	end))

	if child.Name == "node_modules" then
		maid._current = self:_trackMainNodeModuleFolder(child)
	else
		maid._current = self:_trackChildrenAndReplicationType(child, ancestorReplicationType)
	end

	return maid
end

function PackageTracker._trackModuleScript(
	self: PackageTracker,
	child: ModuleScript,
	ancestorReplicationType: ReplicationType.ReplicationType
): Maid.Maid
	assert(typeof(child) == "Instance", "Bad child")
	assert(ReplicationTypeUtils.isReplicationType(ancestorReplicationType), "Bad ancestorReplicationType")

	local maid = Maid.new()

	local function update()
		if child.Archivable then
			maid._current = self:_storeModuleScript(child.Name, child, ancestorReplicationType)
		else
			maid._current = nil
		end
	end

	maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(update))
	maid:GiveTask(child:GetPropertyChangedSignal("Archivable"):Connect(update))

	update()

	return maid
end

function PackageTracker._storeModuleScript(
	self: PackageTracker,
	moduleScriptName: string,
	child: ModuleScript,
	ancestorReplicationType: ReplicationType.ReplicationType
): () -> ()
	assert(type(moduleScriptName) == "string", "Bad moduleScriptName")
	assert(typeof(child) == "Instance", "Bad child")
	assert(ReplicationTypeUtils.isReplicationType(ancestorReplicationType), "Bad ancestorReplicationType")

	if self._packageModuleScriptMap[moduleScriptName] then
		warn(string.format("[PackageTracker] - Overwriting moduleScript with name %q", moduleScriptName))
	end

	local data: ModuleScriptInfo = {
		moduleScript = child,
		replicationType = ancestorReplicationType,
	}
	self._packageModuleScriptMap[moduleScriptName] = data

	return function()
		if self._packageModuleScriptMap[moduleScriptName] == data then
			self._packageModuleScriptMap[moduleScriptName] = nil
		end
	end
end

function PackageTracker._trackMainNodeModuleFolder(self: PackageTracker, parent: Instance): Maid.Maid
	local maid = Maid.new()

	maid:GiveTask(parent.ChildAdded:Connect(function(child)
		self:_handleNodeModulesChildAdded(maid, child)
	end))
	maid:GiveTask(parent.ChildRemoved:Connect(function(child)
		self:_handleNodeModulesChildRemoved(maid, child)
	end))
	for _, child in parent:GetChildren() do
		self:_handleNodeModulesChildAdded(maid, child)
	end

	return maid
end

function PackageTracker._handleNodeModulesChildAdded(self: PackageTracker, parentMaid: Maid.Maid, child: Instance)
	assert(Maid.isMaid(parentMaid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")

	if child:IsA("ObjectValue") then
		-- Assume symlinked package
		parentMaid[child] = self:_trackNodeModulesObjectValue(child)
	elseif child:IsA("Folder") then
		parentMaid[child] = self:_trackNodeModulesChildFolder(child)
	elseif child:IsA("ModuleScript") then
		parentMaid[child] = self:_trackAddPackage(child)
	end
end

function PackageTracker._handleNodeModulesChildRemoved(_self: PackageTracker, parentMaid: Maid.Maid, child: Instance)
	assert(Maid.isMaid(parentMaid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")

	parentMaid[child] = nil
end

function PackageTracker._trackNodeModulesChildFolder(self: PackageTracker, child: Instance): Maid.Maid
	assert(typeof(child) == "Instance", "Bad child")

	local maid = Maid.new()

	local function update(): Maid.MaidTask
		local childName = child.Name

		-- like @quenty
		if DependencyUtils.isPackageGroup(childName) then
			return self:_trackScopedChildFolder(childName, child)
		else
			return self:_tryStorePackage(childName, child)
		end
	end

	maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(function()
		maid._current = update()
	end))

	maid._current = update()

	return maid
end

function PackageTracker._trackNodeModulesObjectValue(self: PackageTracker, objectValue: ObjectValue): Maid.Maid
	assert(typeof(objectValue) == "Instance", "Bad objectValue")

	local maid = Maid.new()

	maid:GiveTask(objectValue:GetPropertyChangedSignal("Name"):Connect(function()
		maid._current = self:_tryStorePackage(objectValue.Name, objectValue.Value)
	end))
	maid:GiveTask(objectValue:GetPropertyChangedSignal("Value"):Connect(function()
		maid._current = self:_tryStorePackage(objectValue.Name, objectValue.Value)
	end))

	maid._current = self:_tryStorePackage(objectValue.Name, objectValue.Value)

	return maid
end

function PackageTracker._trackScopedChildFolder(self: PackageTracker, scopeName: string, parent: Instance): Maid.Maid
	assert(type(scopeName) == "string", "Bad scopeName")
	assert(typeof(parent) == "Instance", "Bad parent")

	local maid = Maid.new()

	maid:GiveTask(parent.ChildAdded:Connect(function(child)
		self:_handleScopedModulesChildAdded(scopeName, maid, child)
	end))
	maid:GiveTask(parent.ChildRemoved:Connect(function(child)
		self:_handleScopedModulesChildRemoved(maid, child)
	end))
	for _, child in parent:GetChildren() do
		self:_handleScopedModulesChildAdded(scopeName, maid, child)
	end

	return maid
end

function PackageTracker._handleScopedModulesChildAdded(
	self: PackageTracker,
	scopeName: string,
	parentMaid: Maid.Maid,
	child: Instance
)
	assert(type(scopeName) == "string", "Bad scopeName")
	assert(Maid.isMaid(parentMaid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")

	if child:IsA("ObjectValue") then
		parentMaid[child] = self:_trackScopedNodeModulesObjectValue(scopeName, child)
	elseif child:IsA("Folder") or child:IsA("ModuleScript") then
		parentMaid[child] = self:_trackAddScopedPackage(scopeName, child)
	end
end

function PackageTracker._trackScopedNodeModulesObjectValue(
	self: PackageTracker,
	scopeName: string,
	objectValue: ObjectValue
)
	assert(type(scopeName) == "string", "Bad scopeName")
	assert(typeof(objectValue) == "Instance", "Bad objectValue")

	local maid = Maid.new()

	maid:GiveTask(objectValue:GetPropertyChangedSignal("Name"):Connect(function()
		maid._current = self:_tryStorePackage(scopeName .. "/" .. objectValue.Name, objectValue.Value)
	end))
	maid:GiveTask(objectValue:GetPropertyChangedSignal("Value"):Connect(function()
		maid._current = self:_tryStorePackage(scopeName .. "/" .. objectValue.Name, objectValue.Value)
	end))

	maid._current = self:_tryStorePackage(scopeName .. "/" .. objectValue.Name, objectValue.Value)

	return maid
end

function PackageTracker._handleScopedModulesChildRemoved(_self: PackageTracker, parentMaid: Maid.Maid, child: Instance)
	assert(Maid.isMaid(parentMaid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")

	parentMaid[child] = nil
end

function PackageTracker._trackAddScopedPackage(self: PackageTracker, scopeName: string, child: Instance)
	assert(type(scopeName) == "string", "Bad scopeName")
	assert(typeof(child) == "Instance", "Bad child")

	local maid = Maid.new()

	maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(function()
		maid._current = self:_tryStorePackage(scopeName .. "/" .. child.Name, child)
	end))

	maid._current = self:_tryStorePackage(scopeName .. "/" .. child.Name, child)

	return maid
end

function PackageTracker._trackAddPackage(self: PackageTracker, child: Instance)
	assert(typeof(child) == "Instance", "Bad child")

	local maid = Maid.new()

	maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(function()
		maid._current = self:_tryStorePackage(child.Name, child)
	end))

	maid._current = self:_tryStorePackage(child.Name, child)

	return maid
end

function PackageTracker._tryStorePackage(
	self: PackageTracker,
	fullPackageName: string,
	packageInst: Instance?
): (() -> ())?
	assert(type(fullPackageName) == "string", "Bad fullPackageName")

	if not packageInst then
		return nil
	end

	self._subpackagesMap[fullPackageName] = packageInst

	local packageTracker = self._packageTrackerProvider:AddPackageRoot(packageInst)
	table.insert(self._subpackagesTrackerList, packageTracker)

	return function()
		local index = table.find(self._subpackagesTrackerList, packageTracker)
		if index then
			table.remove(self._subpackagesTrackerList, index)
		end

		if self._subpackagesMap[fullPackageName] == packageInst then
			self._subpackagesMap[fullPackageName] = nil
		end
	end
end

function PackageTracker.Destroy(self: PackageTracker)
	self._maid:DoCleaning()
end

return PackageTracker
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="125">
                <Properties>
                  <string name="Name">PackageTrackerProvider</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class PackageTrackerProvider
]=]

local loader = script.Parent.Parent

local Maid = require(loader.Maid)
local PackageTracker = require(loader.Dependencies.PackageTracker)

local PackageTrackerProvider = {}
PackageTrackerProvider.ClassName = "PackageTrackerProvider"
PackageTrackerProvider.__index = PackageTrackerProvider

export type PackageTrackerProvider = typeof(setmetatable(
	{} :: {
		_packageTrackersRoots: { [Instance]: PackageTracker.PackageTracker },
		_maid: Maid.Maid,
		_trackCount: number,
	},
	{} :: typeof({ __index = PackageTrackerProvider })
))

function PackageTrackerProvider.new(): PackageTrackerProvider
	local self = setmetatable({}, PackageTrackerProvider)

	self._maid = Maid.new()
	self._packageTrackersRoots = {}
	self._trackCount = 0

	return self
end

function PackageTrackerProvider.AddPackageRoot(
	self: PackageTrackerProvider,
	instance: Instance
): PackageTracker.PackageTracker
	assert(typeof(instance) == "Instance", "Bad instance")

	if self._packageTrackersRoots[instance] then
		return self._packageTrackersRoots[instance]
	end

	self._trackCount += 1

	local maid = Maid.new()

	local packageTracker = PackageTracker.new(self :: any, instance)
	maid:GiveTask(packageTracker)

	self._packageTrackersRoots[instance] = packageTracker
	self._maid[instance] = maid

	packageTracker:StartTracking()

	-- TODO: Provide cleanup mechanism

	return self._packageTrackersRoots[instance]
end

function PackageTrackerProvider.FindPackageTracker(
	self: PackageTrackerProvider,
	instance: Instance
): PackageTracker.PackageTracker?
	assert(typeof(instance) == "Instance", "Bad instance")

	local current = instance
	while current do
		if self._packageTrackersRoots[current] then
			return self._packageTrackersRoots[current]
		end

		current = current.Parent :: Instance
	end

	return nil
end

function PackageTrackerProvider.Destroy(self: PackageTrackerProvider)
	self._maid:DoCleaning()
end

return PackageTrackerProvider
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="126">
              <Properties>
                <string name="Name">LoaderLink</string>
              </Properties>
              <Item class="ModuleScript" referent="127">
                <Properties>
                  <string name="Name">LoaderLink</string>
                  <string name="Source"><![CDATA[--!nocheck
--[=[
	This class is linking to the Nevermore loader.

	## Usage
	You can refer to script.Parent.loader and it will exist if the code has been setup properly
	with the Nevermore loader.

	```lua
	local require = require(script.Parent.loader).load(script)
	```

	@private
	@class LoaderLink
]=]

local function waitForValue(objectValue: ObjectValue): Instance
	local value = objectValue.Value
	if value then
		return value
	end

	return objectValue.Changed:Wait()
end

local loader = waitForValue(script:WaitForChild("LoaderLink"))
if not (loader:IsDescendantOf(game) or loader:FindFirstAncestorWhichIsA("Plugin")) then
	error("[LoaderLink] - Cannot load loader that is unparented from game or plugin")
end

return require(loader)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="128">
                <Properties>
                  <string name="Name">LoaderLinkCreator</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Adds the loader instance so script.Parent.loader works.

	@class LoaderLinkCreator
]=]

local loader = script.Parent.Parent
local LoaderLinkUtils = require(loader.LoaderLink.LoaderLinkUtils)
local Maid = require(loader.Maid)
local ReplicatorReferences = require(loader.Replication.ReplicatorReferences)

local LoaderLinkCreator = {}
LoaderLinkCreator.ClassName = "LoaderLinkCreator"
LoaderLinkCreator.__index = LoaderLinkCreator

export type LoaderLinkCreator = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_root: Instance,
		_references: ReplicatorReferences.ReplicatorReferences?,
		_hasLoaderCount: IntValue,
		_childRequiresLoaderCount: IntValue,
		_provideLoader: BoolValue,
		_lastProvidedLoader: Instance?,
	},
	{} :: typeof({ __index = LoaderLinkCreator })
))

function LoaderLinkCreator.new(
	root: Instance,
	references: ReplicatorReferences.ReplicatorReferences?,
	isRoot: boolean?
): LoaderLinkCreator
	assert(typeof(root) == "Instance", "Bad root")
	assert(ReplicatorReferences.isReplicatorReferences(references) or references == nil, "Bad references")

	local self = setmetatable({}, LoaderLinkCreator)
	self._maid = Maid.new()

	self._root = root
	self._references = references

	self._childRequiresLoaderCount = self._maid:Add(Instance.new("IntValue"))
	self._childRequiresLoaderCount.Value = isRoot and 1 or 0

	self._hasLoaderCount = self._maid:Add(Instance.new("IntValue"))
	self._hasLoaderCount.Value = 0

	self._provideLoader = self._maid:Add(Instance.new("BoolValue"))
	self._provideLoader.Value = false

	-- prevent frame delay
	self:_setupEventTracking()
	self:_setupRendering()

	return self :: LoaderLinkCreator
end

function LoaderLinkCreator._setupEventTracking(self: LoaderLinkCreator)
	self._maid:GiveTask(self._root.ChildAdded:Connect(function(child)
		self:_handleChildAdded(child)
	end))
	self._maid:GiveTask(self._root.ChildRemoved:Connect(function(child)
		self:_handleChildRemoved(child)
	end))

	for _, child in self._root:GetChildren() do
		self:_handleChildAdded(child)
	end

	-- Need to do this AFTER child added loop
	if self._references then
		self._maid:GiveTask(self._references:ObserveReferenceChanged(loader, function(replicatedLoader: Instance?)
			if replicatedLoader and replicatedLoader ~= loader then
				self._maid._trackFakeLoader = (self :: any):_countLoaderReferences(replicatedLoader)
			else
				self._maid._trackFakeLoader = nil
			end
		end))
	else
		self._maid:GiveTask((self :: any):_countLoaderReferences(loader))
	end

	-- Update state
	self._maid:GiveTask(self._childRequiresLoaderCount.Changed:Connect(function()
		self:_updateProviderLoader()
	end))
	self._maid:GiveTask(self._hasLoaderCount.Changed:Connect(function()
		self:_updateProviderLoader()
	end))
	self:_updateProviderLoader()
end

function LoaderLinkCreator._setupRendering(self: LoaderLinkCreator)
	if self._references then
		local function renderLoader()
			if self._provideLoader.Value then
				self._maid._loader = self:_renderLoaderWithReferences(self._references)
			else
				self._maid._loader = nil
			end
		end

		self._maid:GiveTask(self._provideLoader.Changed:Connect(renderLoader))
		renderLoader()
	else
		local function renderLoader()
			if self._provideLoader.Value then
				self._maid._loader = self:_doLoaderRender(loader)
			else
				self._maid._loader = nil
			end
		end

		-- No references, just render as needed
		self._maid:GiveTask(self._provideLoader.Changed:Connect(renderLoader))
		renderLoader()
	end
end

function LoaderLinkCreator._updateProviderLoader(self: LoaderLinkCreator)
	self._provideLoader.Value = (self._childRequiresLoaderCount.Value > 0) and self._hasLoaderCount.Value <= 0
end

function LoaderLinkCreator._handleChildRemoved(self: LoaderLinkCreator, child: Instance)
	self._maid[child] = nil
end

function LoaderLinkCreator._handleChildAdded(self: LoaderLinkCreator, child: Instance)
	assert(typeof(child) == "Instance", "Bad child")

	if child:IsA("ModuleScript") then
		if child.Name == "loader" then
			if child ~= self._lastProvidedLoader then
				self._maid[child] = self:_addToHasLoaderCount(1)
			end
		else
			self._maid[child] = self:_incrementNeededLoader(1)
		end
	elseif child:IsA("Folder") then
		-- TODO: Maybe add to children with node_modules explicitly in its list.
		self._maid[child] = LoaderLinkCreator.new(child, self._references)
	end
end

function LoaderLinkCreator._renderLoaderWithReferences(
	self: LoaderLinkCreator,
	references: ReplicatorReferences.ReplicatorReferences
): Maid.Maid
	local maid = Maid.new()

	maid:GiveTask(references:ObserveReferenceChanged(loader, function(value: Instance?)
		if value then
			maid._current = self:_doLoaderRender(value)
		else
			maid._current = nil
		end
	end))

	return maid
end

function LoaderLinkCreator._doLoaderRender(self: LoaderLinkCreator, value: Instance)
	local loaderLink = LoaderLinkUtils.create(value, loader.Name)
	self._lastProvidedLoader = loaderLink

	loaderLink.Parent = self._root

	return loaderLink
end

function LoaderLinkCreator._incrementNeededLoader(self: LoaderLinkCreator, amount: number): () -> ()
	assert(type(amount) == "number", "Bad amount")

	self._childRequiresLoaderCount.Value = self._childRequiresLoaderCount.Value + amount
	return function()
		self._childRequiresLoaderCount.Value = self._childRequiresLoaderCount.Value - amount
	end
end

function LoaderLinkCreator._addToHasLoaderCount(self: LoaderLinkCreator, amount: number): () -> ()
	assert(type(amount) == "number", "Bad amount")

	self._hasLoaderCount.Value = self._hasLoaderCount.Value + amount
	return function()
		self._hasLoaderCount.Value = self._hasLoaderCount.Value - amount
	end
end

function LoaderLinkCreator._countLoaderReferences(self: LoaderLinkCreator, robloxInst: Instance): Maid.Maid
	assert(typeof(robloxInst) == "Instance", "Bad robloxInst")

	local maid = Maid.new()

	-- TODO: Maybe handle loader reparenting more elegantly? this seems deeply unlikely.
	if robloxInst.Parent == self._root then
		maid._current = self:_addToHasLoaderCount(1)
	end

	maid:GiveTask(robloxInst:GetPropertyChangedSignal("Parent"):Connect(function()
		if robloxInst.Parent == self._root then
			maid._current = self:_addToHasLoaderCount(1)
		else
			maid._current = nil
		end
	end))

	return maid
end

--[=[
	Cleans up the replicator disconnecting all events and cleaning up
	created instances.
]=]
function LoaderLinkCreator.Destroy(self: LoaderLinkCreator)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return LoaderLinkCreator
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="129">
                <Properties>
                  <string name="Name">LoaderLinkUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class LoaderLinkUtils
	@private
]=]

local LoaderLink = script.Parent.LoaderLink

local LoaderLinkUtils = {}

function LoaderLinkUtils.create(loader: Instance, linkName: string): ModuleScript
	assert(typeof(loader) == "Instance", "Bad loader")
	assert(type(linkName) == "string", "Bad linkName")

	local copy = LoaderLink:Clone()
	copy.Name = linkName
	copy.Archivable = false

	local objectValue = Instance.new("ObjectValue")
	objectValue.Name = "LoaderLink"
	objectValue.Value = loader
	objectValue.Parent = copy
	objectValue.Archivable = false

	return copy
end

return LoaderLinkUtils
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="130">
              <Properties>
                <string name="Name">LoaderUtils</string>
                <string name="Source"><![CDATA[--!strict
-- Literally here just so old loading code works

error("Not implemented! Please require LoaderUtils.Parent. This file acts as a marker for old loader versions.")
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="131">
              <Properties>
                <string name="Name">Maid</string>
                <string name="Source"><![CDATA[--!strict
--[[
	Manages the cleaning of events and other things. Useful for
	encapsulating state and make deconstructors easy.

	See the [Five Powerful Code Patterns talk](https://developer.roblox.com/en-us/videos/5-powerful-code-patterns-behind-top-roblox-games)
	for a more in-depth look at Maids in top games.

	```lua
	local maid = Maid.new()

	maid:GiveTask(function()
		print("Cleaning up")
	end)

	maid:GiveTask(workspace.ChildAdded:Connect(print))

	-- Disconnects all events, and executes all functions
	maid:DoCleaning()
	```

	@ignore
	@class Maid
]]
-- luacheck: pop

local Maid = {}
Maid.ClassName = "Maid"

export type MaidTask = (() -> ()) | Instance | thread | any | RBXScriptConnection | nil

export type Maid = typeof(setmetatable(
	{} :: {
		Add: <T>(self: Maid, task: T) -> T,
		GiveTask: (self: Maid, task: MaidTask) -> number,
		GivePromise: <T>(self: Maid, promise: T) -> T,
		DoCleaning: (self: Maid) -> (),
		Destroy: (self: Maid) -> (),
		_tasks: { [any]: MaidTask },
		[string | number | MaidTask]: any,
	},
	{} :: typeof({ __index = Maid })
))

--[[
	Constructs a new Maid object

	```lua
	local maid = Maid.new()
	```

	@ignore
	@return Maid
]]
function Maid.new(): Maid
	return setmetatable(
		{
			_tasks = {},
		} :: any,
		Maid
	) :: Maid
end

--[[
	Returns true if the class is a maid, and false otherwise.

	```lua
	print(Maid.isMaid(Maid.new())) --> true
	print(Maid.isMaid(nil)) --> false
	```

	@ignore
	@param value any
	@return boolean
]]
function Maid.isMaid(value: any): boolean
	return type(value) == "table" and value.ClassName == "Maid"
end

--[[
	Returns Maid[key] if not part of Maid metatable

	```lua
	local maid = Maid.new()
	maid._current = Instance.new("Part")
	print(maid._current) --> Part

	maid._current = nil
	print(maid._current) --> nil
	```

	@ignore
	@param index any
	@return MaidTask
]]
function Maid.__index(self: Maid, index: any)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--[[
	Add a task to clean up. Tasks given to a maid will be cleaned when
	maid[index] is set to a different value.

	Task cleanup is such that if the task is an event, it is disconnected.
	If it is an object, it is destroyed.

	```
	Maid[key] = (function)         Adds a task to perform
	Maid[key] = (event connection) Manages an event connection
	Maid[key] = (thread)           Manages a thread
	Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
	Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
	Maid[key] = nil                Removes a named task.
	```

	@ignore
	@param index any
	@param newTask MaidTask
]]
function Maid.__newindex(self: Maid, index: any, newTask: MaidTask)
	if Maid[index] ~= nil then
		error(string.format("Cannot use '%s' as a Maid key", tostring(index)), 2)
	end

	local tasks = self._tasks
	local job = tasks[index]

	if job == newTask then
		return
	end

	tasks[index] = newTask

	if job then
		if typeof(job) == "function" then
			(job :: any)()
		elseif typeof(job) == "table" then
			local destructable: any = job
			if type(destructable.Destroy) == "function" then
				destructable:Destroy()
			end
		elseif typeof(job) == "Instance" then
			job:Destroy()
		elseif typeof(job) == "thread" then
			local cancelled
			if coroutine.running() ~= job then
				cancelled = pcall(function()
					task.cancel(job)
				end)
			end

			if not cancelled then
				task.defer(function()
					task.cancel(job)
				end)
			end
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		end
	end
end

--[[
	Gives a task to the maid for cleanup and returns the resulting value

	@ignore
	@param task MaidTask -- An item to clean
	@return MaidTask
]]
function Maid.Add<T>(self: Maid, task: T): T
	if not task then
		error("Task cannot be false or nil", 2)
	end

	self[#(self._tasks :: any) + 1] = task :: any

	if type(task) == "table" and not task.Destroy then
		warn("[Maid.Add] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return task
end

--[[
	Gives a task to the maid for cleanup, but uses an incremented number as a key.

	@ignore
	@param task MaidTask -- An item to clean
	@return number -- taskId
]]
function Maid.GiveTask(self: Maid, task: MaidTask): number
	if not task then
		error("Task cannot be false or nil", 2)
	end

	local taskId = #(self._tasks :: any) + 1
	self[taskId] = task

	if type(task) == "table" and not (task :: any).Destroy then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

--[[
	Gives a promise to the maid for clean.

	@ignore
	@param promise Promise<T>
	@return Promise<T>
]]
function Maid.GivePromise(self: Maid, promise: any): any
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--[[
	Cleans up all tasks and removes them as entries from the Maid.

	:::note
	Signals that are already connected are always disconnected first. After that
	any signals added during a cleaning phase will be disconnected at random times.
	:::

	:::tip
	DoCleaning() may be recursively invoked. This allows the you to ensure that
	tasks or other tasks. Each task will be executed once.

	However, adding tasks while cleaning is not generally a good idea, as if you add a
	function that adds itself, this will loop indefinitely.
	:::

	@ignore
]]
function Maid.DoCleaning(self: Maid)
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in tasks do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if typeof(job) == "function" then
			(job :: any)()
		elseif typeof(job) == "table" and type((job :: any).Destroy) == "function" then
			(job :: any):Destroy()
		elseif typeof(job) == "Instance" then
			job:Destroy()
		elseif typeof(job) == "thread" then
			local cancelled
			if coroutine.running() ~= job then
				cancelled = pcall(function()
					task.cancel(job)
				end)
			end

			if not cancelled then
				local toCancel = job
				task.defer(function()
					task.cancel(toCancel)
				end)
			end
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		end
		index, job = next(tasks)
	end
end

--[[
	Alias for [Maid.DoCleaning()](/api/Maid#DoCleaning)

	@ignore
	@function Destroy
	@within Maid
]]
Maid.Destroy = Maid.DoCleaning

return Maid
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="132">
              <Properties>
                <string name="Name">Replication</string>
              </Properties>
              <Item class="ModuleScript" referent="133">
                <Properties>
                  <string name="Name">ReplicationType</string>
                  <string name="Source"><![CDATA[--!strict
--[=[

	Different replication types we can be in.

	@class ReplicationType
]=]

local Utils = require(script.Parent.Parent.Utils)

export type ReplicationTypeMap = {
	CLIENT: "client",
	SERVER: "server",
	SHARED: "shared",
	PLUGIN: "plugin",
}

export type ReplicationType = "client" | "server" | "shared" | "plugin"

return Utils.readonly({
	CLIENT = "client",
	SERVER = "server",
	SHARED = "shared",
	PLUGIN = "plugin",
} :: ReplicationTypeMap)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="134">
                <Properties>
                  <string name="Name">ReplicationTypeUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions involving [ReplicationType]
	@class ReplicationTypeUtils
]=]

local RunService = game:GetService("RunService")

local ReplicationType = require(script.Parent.ReplicationType)

local ReplicationTypeUtils = {}

--[=[
	Returns true if the data is a replicationType
	@param replicationType any
	@return boolean
]=]
function ReplicationTypeUtils.isReplicationType(replicationType: any): boolean
	return replicationType == ReplicationType.SHARED
		or replicationType == ReplicationType.CLIENT
		or replicationType == ReplicationType.SERVER
		or replicationType == ReplicationType.PLUGIN
end

function ReplicationTypeUtils.getFolderReplicationType(
	folderName: string,
	ancestorReplicationType: ReplicationType.ReplicationType
): ReplicationType.ReplicationType
	assert(type(folderName) == "string", "Bad folderName")
	assert(type(ancestorReplicationType) == "string", "Bad ancestorReplicationType")

	if folderName == "Shared" then
		return ReplicationType.SHARED
	elseif folderName == "Client" then
		return ReplicationType.CLIENT
	elseif folderName == "Server" then
		return ReplicationType.SERVER
	else
		return ancestorReplicationType
	end
end

function ReplicationTypeUtils.inferReplicationType(): ReplicationType.ReplicationType
	if (not RunService:IsRunning()) and RunService:IsStudio() then
		return ReplicationType.PLUGIN
	elseif RunService:IsServer() then
		return ReplicationType.SERVER
	elseif RunService:IsClient() then
		return ReplicationType.CLIENT
	else
		error("Unknown ReplicationType state")
	end
end

function ReplicationTypeUtils.isAllowed(
	replicationType: ReplicationType.ReplicationType,
	requestedReplicationType: ReplicationType.ReplicationType
): boolean
	assert(ReplicationTypeUtils.isReplicationType(replicationType), "Bad replicationType")
	assert(ReplicationTypeUtils.isReplicationType(requestedReplicationType), "Bad requestedReplicationType")

	if requestedReplicationType == ReplicationType.PLUGIN then
		return true
	elseif requestedReplicationType == ReplicationType.SHARED then
		-- NOTE: We could allow replication from shared in either direction...

		return replicationType == ReplicationType.SHARED
	elseif requestedReplicationType == ReplicationType.CLIENT then
		if replicationType == ReplicationType.SERVER then
			return false
		end

		return true
	elseif requestedReplicationType == ReplicationType.SERVER then
		if replicationType == ReplicationType.CLIENT then
			return false
		end

		return true
	else
		error("Unknown requestedReplicationType")
	end
end

return ReplicationTypeUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="135">
                <Properties>
                  <string name="Name">Replicator</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Monitors dependencies primarily for replication. Handles the following scenarios.

	This system dynamically replicates whatever state exists in the tree except we
	filter out server-specific assets while any client-side assets are still replicated
	even if deeper in the tree.

	By separating out the replication component of the loader from the loading logic
	we can more easily support hot reloading and future loading scenarios.

	Repliation rules:
	1. Replicate the whole tree, including any changes
	2. Module scripts named Server are replaced with a folder
	3. Module scripts that are in server mode won't replicate unless a client dependency is needed or found.
	4. Once we hit a "Template" object we stop trying to be smart since Mesh parts are not API accessible.
	5. References are preserved for ObjectValues.

	This system is designed to minimize changes such that hot reloading can be easily
	implemented.

	Right now it fails to be performance friendly with module scripts under another
	module script.

	@class Replicator
]=]

local loader = script.Parent.Parent

local Maid = require(loader.Maid)
local ReplicationType = require(loader.Replication.ReplicationType)
local ReplicationTypeUtils = require(loader.Replication.ReplicationTypeUtils)
local ReplicatorReferences = require(loader.Replication.ReplicatorReferences)

local Replicator = {}
Replicator.ClassName = "Replicator"
Replicator.__index = Replicator

export type Replicator = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_replicationStarted: boolean,
		_references: ReplicatorReferences.ReplicatorReferences,
		_target: ObjectValue,
		_replicatedDescendantCount: IntValue,
		_hasReplicatedDescendants: BoolValue,
		_replicationType: StringValue,
	},
	{} :: typeof({ __index = Replicator })
))

--[=[
	Constructs a new Replicator which will do the syncing.

	@param references ReplicatorReferences
	@return Replicator
]=]
function Replicator.new(references: ReplicatorReferences.ReplicatorReferences): Replicator
	local self = setmetatable({}, Replicator)

	assert(ReplicatorReferences.isReplicatorReferences(references), "Bad references")

	self._maid = Maid.new()
	self._references = references
	self._replicationStarted = false

	self._target = self._maid:Add(Instance.new("ObjectValue"))
	self._target.Value = nil

	self._replicatedDescendantCount = self._maid:Add(Instance.new("IntValue"))
	self._replicatedDescendantCount.Name = "Replicator_ReplicatedDescendantCount"
	self._replicatedDescendantCount.Value = 0

	self._hasReplicatedDescendants = self._maid:Add(Instance.new("BoolValue"))
	self._hasReplicatedDescendants.Name = "Replicator_HasReplicatedDescendants"
	self._hasReplicatedDescendants.Value = false

	self._replicationType = self._maid:Add(Instance.new("StringValue"))
	self._replicationType.Name = "Replicator_ReplicationType"
	self._replicationType.Value = ReplicationType.SHARED

	self._maid:GiveTask(self._replicatedDescendantCount.Changed:Connect(function()
		self._hasReplicatedDescendants.Value = self._replicatedDescendantCount.Value > 0
	end))

	return self
end

--[=[
	Replicates children from the given root

	@param root Instance
]=]
function Replicator.ReplicateFrom(self: Replicator, root: Instance)
	assert(typeof(root) == "Instance", "Bad root")
	if self._replicationStarted then
		(error :: any)("[Replicator] - Replication already started")
	end

	self._replicationStarted = true

	self._maid:GiveTask(root.ChildAdded:Connect(function(child)
		self:_handleChildAdded(child)
	end))
	self._maid:GiveTask(root.ChildRemoved:Connect(function(child)
		self:_handleChildRemoved(child)
	end))
	for _, child in root:GetChildren() do
		self:_handleChildAdded(child)
	end
end

--[=[
	Returns true if the argument is a replicator

	@param replicator any?
	@return boolean
]=]
function Replicator.isReplicator(replicator: any): boolean
	return type(replicator) == "table" and getmetatable(replicator :: any) == Replicator
end

--[=[
	Returns the replicated descendant count value.
	@return IntValue
]=]
function Replicator.GetReplicatedDescendantCountValue(self: Replicator): IntValue
	return self._replicatedDescendantCount
end

--[=[
	Sets the replication type for this replicator

	@param replicationType ReplicationType
]=]
function Replicator.SetReplicationType(self: Replicator, replicationType: ReplicationType.ReplicationType)
	assert(ReplicationTypeUtils.isReplicationType(replicationType), "Bad replicationType")

	self._replicationType.Value = replicationType
end

--[=[
	Sets the target for the replicator where the results will be parented.

	@param target Instance?
]=]
function Replicator.SetTarget(self: Replicator, target: Instance?)
	assert(typeof(target) == "Instance" or target == nil, "Bad target")

	self._target.Value = target
end

--[=[
	Gets the current target for the replicator.

	@return Instance?
]=]
function Replicator.GetTarget(self: Replicator): Instance?
	return self._target.Value
end

--[=[
	Gets a value representing if there's any replicated children. Used to
	avoid leaking more server-side information than needed for the user.

	@return BoolValue
]=]
function Replicator.GetHasReplicatedChildrenValue(self: Replicator): BoolValue
	return self._hasReplicatedDescendants
end

function Replicator.GetReplicationTypeValue(self: Replicator): StringValue
	return self._replicationType
end

function Replicator._handleChildRemoved(self: Replicator, child: Instance)
	self._maid[child] = nil
end

function Replicator._handleChildAdded(self: Replicator, child: Instance)
	assert(typeof(child) == "Instance", "Bad child")

	local maid = Maid.new()

	if child.Archivable then
		maid._current = self:_renderChild(child)
	end

	maid:GiveTask(child:GetPropertyChangedSignal("Archivable"):Connect(function()
		if child.Archivable then
			maid._current = self:_renderChild(child)
		else
			maid._current = nil
		end
	end))

	self._maid[child] = maid
end

function Replicator._renderChild(self: Replicator, child: Instance)
	local maid = Maid.new()

	local replicator = Replicator.new(self._references)
	self:_setupReplicatorDescendantCount(maid, replicator)
	maid:GiveTask(replicator)

	if child:IsA("Folder") then
		self:_setupReplicatorTypeFromFolderName(maid, replicator, child)
	else
		self:_setupReplicatorType(maid, replicator)
	end

	local replicationTypeValue = replicator:GetReplicationTypeValue()
	maid._current =
		self:_replicateBasedUponMode(replicator, replicationTypeValue.Value :: ReplicationType.ReplicationType, child)
	maid:GiveTask(replicationTypeValue.Changed:Connect(function()
		maid._current = nil
		maid._current = self:_replicateBasedUponMode(
			replicator,
			replicationTypeValue.Value :: ReplicationType.ReplicationType,
			child
		)
	end))

	replicator:ReplicateFrom(child)

	return maid
end

function Replicator._replicateBasedUponMode(
	self: Replicator,
	replicator: Replicator,
	replicationType: ReplicationType.ReplicationType,
	child: Instance
)
	assert(Replicator.isReplicator(replicator), "Bad replicator")
	assert(ReplicationTypeUtils.isReplicationType(replicationType), "Bad replicationType")
	assert(typeof(child) == "Instance", "Bad child")

	if replicationType == ReplicationType.SERVER then
		return self:_doReplicationServer(replicator, child)
	elseif replicationType == ReplicationType.SHARED or replicationType == ReplicationType.CLIENT then
		return self:_doReplicationClient(replicator, child)
	else
		error("[Replicator] - Unknown replicationType")
	end
end

function Replicator._doReplicationServer(self: Replicator, replicator: Replicator, child: Instance)
	local maid = Maid.new()

	local hasReplicatedChildren = replicator:GetHasReplicatedChildrenValue()
	maid:GiveTask(hasReplicatedChildren.Changed:Connect(function()
		if hasReplicatedChildren.Value then
			maid._current = nil
			maid._current = self:_doServerClone(replicator, child)
		else
			maid._current = nil
		end
	end))

	if hasReplicatedChildren.Value then
		maid._current = self:_doServerClone(replicator, child)
	end
end

function Replicator._doServerClone(self: Replicator, replicator: Replicator, child: Instance): Maid.Maid
	-- Always a folder to prevent information from leaking...
	local maid = Maid.new()
	local copy = maid:Add(Instance.new("Folder"))

	self:_setupNameReplication(maid, child, copy)
	self:_setupParentReplication(maid, copy)
	self:_setupReference(maid, child, copy)

	-- Setup replication for this specific instance.
	self:_setupReplicatorTarget(maid, replicator, copy)

	return maid
end

function Replicator._doReplicationClient(self: Replicator, replicator: Replicator, child: Instance): Maid.Maid
	local maid = Maid.new()

	if child:IsA("ModuleScript") then
		self:_setupReplicatedDescendantCountAdd(maid, 1)

		maid._current = self:_doModuleScriptCloneClient(replicator, child)
		maid:GiveTask(child.Changed:Connect(function(property)
			if property == "Source" then
				maid._current = nil
				maid._current = self:_doModuleScriptCloneClient(replicator, child)
			end
		end))
	elseif child:IsA("Folder") then
		local copy = maid:Add(Instance.new("Folder"))

		self:_doStandardReplication(maid, replicator, child, copy)
	elseif child:IsA("ObjectValue") then
		local copy = maid:Add(Instance.new("ObjectValue"))

		self:_setupObjectValueReplication(maid, child, copy)
		self:_doStandardReplication(maid, replicator, child, copy)
	else
		-- selene: allow(incorrect_standard_library_use)
		local copy = maid:Add(Instance.fromExisting(child))

		-- TODO: Maybe do better
		self:_setupReplicatedDescendantCountAdd(maid, 1)
		self:_doStandardReplication(maid, replicator, child, copy)
	end

	return maid
end

function Replicator._doModuleScriptCloneClient(self: Replicator, replicator: Replicator, child: Instance): Maid.Maid
	assert(Replicator.isReplicator(replicator), "Bad replicator")
	assert(typeof(child) == "Instance", "Bad child")

	local maid = Maid.new()

	-- selene: allow(incorrect_standard_library_use)
	local copy = maid:Add(Instance.fromExisting(child))

	self:_doStandardReplication(maid, replicator, child, copy)

	return maid
end

function Replicator._doStandardReplication(
	self: Replicator,
	maid: Maid.Maid,
	replicator: Replicator,
	child: Instance,
	copy: Instance
)
	assert(Replicator.isReplicator(replicator), "Bad replicator")
	assert(typeof(copy) == "Instance", "Bad copy")
	assert(typeof(child) == "Instance", "Bad child")

	self:_setupAttributeReplication(maid, child, copy)
	self:_setupTagReplication(maid, child, copy)
	self:_setupNameReplication(maid, child, copy)
	self:_setupParentReplication(maid, copy)
	self:_setupReference(maid, child, copy)

	-- Setup replication for this specific instance.
	self:_setupReplicatorTarget(maid, replicator, copy)
end

function Replicator._setupReplicatedDescendantCountAdd(self: Replicator, maid: Maid.Maid, amount: number)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(type(amount) == "number", "Bad amount")

	-- Do this replication count here so when the source changes we don't
	-- have any flickering.
	self._replicatedDescendantCount.Value += amount
	maid:GiveTask(function()
		self._replicatedDescendantCount.Value -= amount
	end)
end

--[[
	Sets up the replicator target so children can be parented into the
	instance.

	Sets the target to the copy

	@param maid Maid
	@param replicator Replicator
	@param copy Instance
]]
function Replicator._setupReplicatorTarget(_self: Replicator, maid: Maid.Maid, replicator: Replicator, copy: Instance)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(Replicator.isReplicator(replicator), "Bad replicator")
	assert(typeof(copy) == "Instance", "Bad copy")

	replicator:SetTarget(copy)

	maid:GiveTask(function()
		if not replicator.Destroy then
			return
		end

		if (replicator :: any):GetTarget() == copy then
			replicator:SetTarget(nil)
		end
	end)
end

--[[
	Adds the children count of a child replicator to this replicators
	count.

	We use this to determine if we need to build the whole tree or not.

	@param maid Maid
	@param replicator Replicator
]]
function Replicator._setupReplicatorDescendantCount(self: Replicator, maid: Maid.Maid, replicator: Replicator)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(Replicator.isReplicator(replicator), "Bad replicator")

	local replicatedChildrenCount = replicator:GetReplicatedDescendantCountValue()
	local lastValue = replicatedChildrenCount.Value
	self._replicatedDescendantCount.Value += lastValue

	maid:GiveTask(replicatedChildrenCount.Changed:Connect(function()
		local value = replicatedChildrenCount.Value
		local delta = value - lastValue
		lastValue = value
		self._replicatedDescendantCount.Value += delta
	end))

	maid:GiveTask(function()
		local value = lastValue
		lastValue = 0
		self._replicatedDescendantCount.Value -= value
	end)
end

--[[
	Sets up references from original to the copy. This allows

	@param maid Maid
	@param child Instance
	@param copy Instance
]]
function Replicator._setupReference(self: Replicator, maid, child: Instance, copy: Instance)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")
	assert(typeof(copy) == "Instance", "Bad copy")

	-- Setup references
	self._references:SetReference(child, copy)
	maid:GiveTask(function()
		self._references:UnsetReference(child, copy)
	end)
end

--[[
	Sets up replication type from the folder name. This sort of thing controls
	replication hierarchy for instances we want to have.

	@param maid Maid
	@param replicator
	@param child Instance
]]
function Replicator._setupReplicatorTypeFromFolderName(
	self: Replicator,
	maid: Maid.Maid,
	replicator: Replicator,
	child: Instance
)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(Replicator.isReplicator(replicator), "Bad replicator")
	assert(typeof(child) == "Instance", "Bad child")

	maid:GiveTask(self._replicationType.Changed:Connect(function()
		replicator:SetReplicationType(self:_getFolderReplicationType(child.Name))
	end))
	maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(function()
		replicator:SetReplicationType(self:_getFolderReplicationType(child.Name))
	end))
	replicator:SetReplicationType(self:_getFolderReplicationType(child.Name))
end

function Replicator._setupReplicatorType(self: Replicator, maid, replicator)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(Replicator.isReplicator(replicator), "Bad replicator")

	replicator:SetReplicationType(self._replicationType.Value)
	maid:GiveTask(self._replicationType.Changed:Connect(function()
		replicator:SetReplicationType(self._replicationType.Value)
	end))
end

--[[
	Sets up name replication explicitly.

	@param maid Maid
	@param child Instance
	@param copy Instance
]]
function Replicator._setupNameReplication(_self: Replicator, maid: Maid.Maid, child: Instance, copy: Instance)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")
	assert(typeof(copy) == "Instance", "Bad copy")

	copy.Name = child.Name
	maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(function()
		copy.Name = child.Name
	end))
end

--[[
	Sets up the parent replication.

	@param maid Maid
	@param copy Instance
]]
function Replicator._setupParentReplication(self: Replicator, maid: Maid.Maid, copy: Instance)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(typeof(copy) == "Instance", "Bad copy")

	maid:GiveTask(self._target.Changed:Connect(function()
		copy.Parent = self._target.Value
	end))
	copy.Parent = self._target.Value
end

--[[
	Sets up tag replication explicitly.

	@param maid Maid
	@param child Instance
	@param copy Instance
]]
function Replicator._setupTagReplication(_self: Replicator, maid: Maid.Maid, child: Instance, copy: Instance)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")
	assert(typeof(copy) == "Instance", "Bad copy")

	for _, tag in child:GetTags() do
		copy:AddTag(tag)
	end

	maid:GiveTask(child.Changed:Connect(function(property)
		if property == "Tags" then
			local ourTagSet: { [string]: true } = {}
			for _, tag in copy:GetTags() do
				ourTagSet[tag] = true
			end

			for _, tag in child:GetTags() do
				if not ourTagSet[tag] then
					copy:AddTag(tag)
				end

				ourTagSet[tag] = nil
			end

			for tag, _ in ourTagSet do
				copy:RemoveTag(tag)
			end
		end
	end))
end

--[[
	Sets up the object value replication to point towards new values.

	@param maid Maid
	@param child Instance
	@param copy Instance
]]
function Replicator._setupObjectValueReplication(self: Replicator, maid: Maid.Maid, child: ObjectValue, copy: Instance)
	assert(Maid.isMaid(maid), "Bad maid")
	assert(typeof(child) == "Instance", "Bad child")
	assert(typeof(copy) == "Instance", "Bad copy")

	local symbol = newproxy(true)

	maid:GiveTask(child:GetPropertyChangedSignal("Value"):Connect(function()
		maid[symbol] = self:_doObjectValueReplication(child, copy)
	end))
	maid[symbol] = self:_doObjectValueReplication(child, copy)
end

function Replicator._doObjectValueReplication(self: Replicator, child: ValueBase, copy: Instance): Maid.Maid?
	assert(typeof(child) == "Instance", "Bad child")
	assert(typeof(copy) == "Instance", "Bad copy")

	local childValue: Instance? = (child :: any).Value
	if childValue then
		local maid = Maid.new()

		maid:GiveTask(self._references:ObserveReferenceChanged(childValue, function(newValue)
			if newValue then
				(copy :: any).Value = newValue
			else
				-- Fall back to original value (pointing outside of tree)
				newValue = childValue
			end
		end))

		return maid
	else
		(copy :: any).Value = nil

		return nil
	end
end

--[[
	Computes folder replication type based upon the folder name
	and inherited folder replication type.

	@param childName string
]]
function Replicator._getFolderReplicationType(self: Replicator, childName: string): ReplicationType.ReplicationType
	assert(type(childName) == "string", "Bad childName")

	local replicationType: ReplicationType.ReplicationType =
		self._replicationType.Value :: ReplicationType.ReplicationType

	return ReplicationTypeUtils.getFolderReplicationType(childName, replicationType)
end

function Replicator._setupAttributeReplication(_self: Replicator, maid: Maid.Maid, child: Instance, copy: Instance)
	for key, value in child:GetAttributes() do
		copy:SetAttribute(key, value)
	end

	maid:GiveTask(child.AttributeChanged:Connect(function(attribute)
		copy:SetAttribute(attribute, child:GetAttribute(attribute))
	end))
end

--[=[
	Cleans up the replicator disconnecting all events and cleaning up
	created instances.
]=]
function Replicator.Destroy(self: Replicator)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return Replicator
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="136">
                <Properties>
                  <string name="Name">ReplicatorReferences</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Handles mapping of references to the new value.

	@class ReplicatorReferences
]=]

local ReplicatorReferences = {}
ReplicatorReferences.ClassName = "ReplicatorReferences"
ReplicatorReferences.__index = ReplicatorReferences

export type ListenerCallback = (Instance?) -> ()

export type ReplicatorReferences = typeof(setmetatable(
	{} :: {
		_lookup: { [Instance]: Instance },
		_listeners: { [Instance]: { ListenerCallback } },
	},
	{} :: typeof({ __index = ReplicatorReferences })
))

function ReplicatorReferences.new(): ReplicatorReferences
	local self = setmetatable({}, ReplicatorReferences)

	self._lookup = {}
	self._listeners = {} --[orig] = { callback }

	return self
end

--[=[
	Returns true if the argument is a replicator references

	@param replicatorReferences any?
	@return boolean
]=]
function ReplicatorReferences.isReplicatorReferences(replicatorReferences: any): boolean
	return type(replicatorReferences) == "table" and getmetatable(replicatorReferences :: any) == ReplicatorReferences
end

function ReplicatorReferences.SetReference(self: ReplicatorReferences, orig: Instance, replicated: Instance)
	assert(typeof(orig) == "Instance", "Bad orig")
	assert(typeof(replicated) == "Instance", "Bad replicated")

	if self._lookup[orig] ~= replicated then
		self._lookup[orig] = replicated
		self:_fireSubs(orig, replicated)
	end
end

function ReplicatorReferences.UnsetReference(self: ReplicatorReferences, orig: Instance, replicated: Instance)
	assert(typeof(orig) == "Instance", "Bad orig")
	assert(typeof(replicated) == "Instance", "Bad replicated")

	if self._lookup[orig] == replicated then
		self._lookup[orig] = nil
		self:_fireSubs(orig, nil)
	end
end

function ReplicatorReferences.GetReference(self: ReplicatorReferences, orig: Instance): Instance?
	return self._lookup[orig]
end

function ReplicatorReferences._fireSubs(self: ReplicatorReferences, orig: Instance, newValue: Instance?)
	assert(typeof(orig) == "Instance", "Bad orig")

	local listeners = self._listeners[orig]
	if not listeners then
		return
	end

	for _, callback in listeners do
		task.spawn(callback, newValue)
	end
end

--[=[
	Observes when a reference changes. Discount Rx observable since we're
	the loader and don't want a whole copy of Rx.

	@param orig Instance
	@param callback function
	@return () -> () -- Call to disconnect
]=]
function ReplicatorReferences.ObserveReferenceChanged(
	self: ReplicatorReferences,
	orig: Instance,
	callback: ListenerCallback
): () -> ()
	assert(typeof(orig) == "Instance", "Bad orig")
	assert(type(callback) == "function", "Bad callback")

	-- register
	do
		local listeners = self._listeners[orig]
		if not listeners then
			listeners = {} :: { ListenerCallback }
			self._listeners[orig] = listeners
		end

		table.insert(listeners, callback)
	end

	task.spawn(callback, self._lookup[orig])

	-- Unregister
	return function()
		local listeners = self._listeners[orig]
		if not listeners then
			return
		end

		local index = table.find(listeners, callback)
		if index then
			table.remove(listeners, index)
		end
	end
end

return ReplicatorReferences
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="137">
              <Properties>
                <string name="Name">Utils</string>
                <string name="Source"><![CDATA[--!strict
--[=[
	Utility methods to help with loader functionality.

	@private
	@class Utils
]=]

local Utils = {}

local function errorOnIndex(_, index)
	error(string.format("Bad index %q", tostring(index)), 2)
end

local READ_ONLY_METATABLE = {
	__index = errorOnIndex,
	__newindex = errorOnIndex,
}

function Utils.readonly<T>(_table: T): T
	return setmetatable(_table :: any, READ_ONLY_METATABLE)
end

function Utils.count(_table): number
	local count = 0
	for _, _ in _table do
		count = count + 1
	end
	return count
end

function Utils.getOrCreateValue(parent: Instance, instanceType: string, name: string, defaultValue: any)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(
				string.format(
					"[Utils.getOrCreateValue] - Value of type %q of name %q is of type %q in %s instead",
					instanceType,
					name,
					foundChild.ClassName,
					foundChild:GetFullName()
				)
			)
		end

		return foundChild
	else
		local newChild: any = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = defaultValue
		newChild.Parent = parent

		return newChild
	end
end

function Utils.getValue(parent: Instance, instanceType: string, name: string, default: any)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if foundChild:IsA(instanceType) then
			return (foundChild :: any).Value
		else
			warn(
				string.format(
					"[Utils.getValue] - Value of type %q of name %q is of type %q in %s instead",
					instanceType,
					name,
					foundChild.ClassName,
					foundChild:GetFullName()
				)
			)
			return nil
		end
	else
		return default
	end
end

function Utils.setValue(parent: Instance, instanceType: string, name: string, value: any)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(
				string.format(
					"[Utils.setValue] - Value of type %q of name %q is of type %q in %s instead",
					instanceType,
					name,
					foundChild.ClassName,
					foundChild:GetFullName()
				)
			)
		end

		(foundChild :: any).Value = value
	else
		local newChild: any = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = value
		newChild.Parent = parent
	end
end

function Utils.getOrCreateFolder(parent: Instance, folderName: string): Instance
	local found = parent:FindFirstChild(folderName)
	if found then
		return found
	else
		local folder = Instance.new("Folder")
		folder.Name = folderName
		folder.Parent = parent
		return folder
	end
end

return Utils
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="138">
            <Properties>
              <string name="Name">maid</string>
            </Properties>
            <Item class="Folder" referent="139">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="140">
                <Properties>
                  <string name="Name">Maid</string>
                  <string name="Source"><![CDATA[--!strict
--[[
	Manages the cleaning of events and other things. Useful for
	encapsulating state and make deconstructors easy.

	See the [Five Powerful Code Patterns talk](https://developer.roblox.com/en-us/videos/5-powerful-code-patterns-behind-top-roblox-games)
	for a more in-depth look at Maids in top games.

	```lua
	local maid = Maid.new()

	maid:GiveTask(function()
		print("Cleaning up")
	end)

	maid:GiveTask(workspace.ChildAdded:Connect(print))

	-- Disconnects all events, and executes all functions
	maid:DoCleaning()
	```

	@ignore
	@class Maid
]]
-- luacheck: pop

local Maid = {}
Maid.ClassName = "Maid"

export type MaidTask = (() -> ()) | Instance | thread | any | RBXScriptConnection | nil

export type Maid = typeof(setmetatable(
	{} :: {
		Add: <T>(self: Maid, task: T) -> T,
		GiveTask: (self: Maid, task: MaidTask) -> number,
		GivePromise: <T>(self: Maid, promise: T) -> T,
		DoCleaning: (self: Maid) -> (),
		Destroy: (self: Maid) -> (),
		_tasks: { [any]: MaidTask },
		[string | number | MaidTask]: any,
	},
	{} :: typeof({ __index = Maid })
))

--[[
	Constructs a new Maid object

	```lua
	local maid = Maid.new()
	```

	@ignore
	@return Maid
]]
function Maid.new(): Maid
	return setmetatable(
		{
			_tasks = {},
		} :: any,
		Maid
	) :: Maid
end

--[[
	Returns true if the class is a maid, and false otherwise.

	```lua
	print(Maid.isMaid(Maid.new())) --> true
	print(Maid.isMaid(nil)) --> false
	```

	@ignore
	@param value any
	@return boolean
]]
function Maid.isMaid(value: any): boolean
	return type(value) == "table" and value.ClassName == "Maid"
end

--[[
	Returns Maid[key] if not part of Maid metatable

	```lua
	local maid = Maid.new()
	maid._current = Instance.new("Part")
	print(maid._current) --> Part

	maid._current = nil
	print(maid._current) --> nil
	```

	@ignore
	@param index any
	@return MaidTask
]]
function Maid.__index(self: Maid, index: any)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--[[
	Add a task to clean up. Tasks given to a maid will be cleaned when
	maid[index] is set to a different value.

	Task cleanup is such that if the task is an event, it is disconnected.
	If it is an object, it is destroyed.

	```
	Maid[key] = (function)         Adds a task to perform
	Maid[key] = (event connection) Manages an event connection
	Maid[key] = (thread)           Manages a thread
	Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
	Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
	Maid[key] = nil                Removes a named task.
	```

	@ignore
	@param index any
	@param newTask MaidTask
]]
function Maid.__newindex(self: Maid, index: any, newTask: MaidTask)
	if Maid[index] ~= nil then
		error(string.format("Cannot use '%s' as a Maid key", tostring(index)), 2)
	end

	local tasks = self._tasks
	local job = tasks[index]

	if job == newTask then
		return
	end

	tasks[index] = newTask

	if job then
		if typeof(job) == "function" then
			(job :: any)()
		elseif typeof(job) == "table" then
			local destructable: any = job
			if type(destructable.Destroy) == "function" then
				destructable:Destroy()
			end
		elseif typeof(job) == "Instance" then
			job:Destroy()
		elseif typeof(job) == "thread" then
			local cancelled
			if coroutine.running() ~= job then
				cancelled = pcall(function()
					task.cancel(job)
				end)
			end

			if not cancelled then
				task.defer(function()
					task.cancel(job)
				end)
			end
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		end
	end
end

--[[
	Gives a task to the maid for cleanup and returns the resulting value

	@ignore
	@param task MaidTask -- An item to clean
	@return MaidTask
]]
function Maid.Add<T>(self: Maid, task: T): T
	if not task then
		error("Task cannot be false or nil", 2)
	end

	self[#(self._tasks :: any) + 1] = task :: any

	if type(task) == "table" and not task.Destroy then
		warn("[Maid.Add] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return task
end

--[[
	Gives a task to the maid for cleanup, but uses an incremented number as a key.

	@ignore
	@param task MaidTask -- An item to clean
	@return number -- taskId
]]
function Maid.GiveTask(self: Maid, task: MaidTask): number
	if not task then
		error("Task cannot be false or nil", 2)
	end

	local taskId = #(self._tasks :: any) + 1
	self[taskId] = task

	if type(task) == "table" and not (task :: any).Destroy then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

--[[
	Gives a promise to the maid for clean.

	@ignore
	@param promise Promise<T>
	@return Promise<T>
]]
function Maid.GivePromise(self: Maid, promise: any): any
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--[[
	Cleans up all tasks and removes them as entries from the Maid.

	:::note
	Signals that are already connected are always disconnected first. After that
	any signals added during a cleaning phase will be disconnected at random times.
	:::

	:::tip
	DoCleaning() may be recursively invoked. This allows the you to ensure that
	tasks or other tasks. Each task will be executed once.

	However, adding tasks while cleaning is not generally a good idea, as if you add a
	function that adds itself, this will loop indefinitely.
	:::

	@ignore
]]
function Maid.DoCleaning(self: Maid)
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in tasks do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if typeof(job) == "function" then
			(job :: any)()
		elseif typeof(job) == "table" and type((job :: any).Destroy) == "function" then
			(job :: any):Destroy()
		elseif typeof(job) == "Instance" then
			job:Destroy()
		elseif typeof(job) == "thread" then
			local cancelled
			if coroutine.running() ~= job then
				cancelled = pcall(function()
					task.cancel(job)
				end)
			end

			if not cancelled then
				local toCancel = job
				task.defer(function()
					task.cancel(toCancel)
				end)
			end
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		end
		index, job = next(tasks)
	end
end

--[[
	Alias for [Maid.DoCleaning()](/api/Maid#DoCleaning)

	@ignore
	@function Destroy
	@within Maid
]]
Maid.Destroy = Maid.DoCleaning

return Maid
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="141">
                <Properties>
                  <string name="Name">Maid.story</string>
                  <string name="Source"><![CDATA[--[[
	@class Maid.story
]]

local Maid = require(script.Parent.Maid)

return function()
	local maid = Maid.new()

	local thread = maid:Add(task.spawn(function()
		while true do
			task.wait(0.1) -- In the spawn scenario this yields control back to the main thread, adding the task.
			error("Task is not cancelled because of change")
		end
	end))

	return function()
		maid:DoCleaning()
		task.cancel(thread)
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="142">
                <Properties>
                  <string name="Name">MaidTaskUtils</string>
                  <string name="Source"><![CDATA[--[=[
	Utility methods involving maids and tasks.
	@class MaidTaskUtils
]=]

--[=[
	An object that can have the method :Destroy() called on it
	@type Destructable Instance | { Destroy: function }
	@within MaidTaskUtils
]=]
export type Destructable = any

--[=[
	An object that can be cleaned up
	@type MaidTask function | thread | Destructable | RBXScriptConnection
	@within MaidTaskUtils
]=]
export type MaidTask = (() -> ()) | Instance | thread | Destructable | RBXScriptConnection | nil

local MaidTaskUtils = {}

--[=[
	Returns whether a task is a valid job.

	@param job any
	@return boolean
]=]
function MaidTaskUtils.isValidTask(job: any): boolean
	local jobType = typeof(job)
	return jobType == "function"
		or jobType == "thread"
		or jobType == "RBXScriptConnection"
		or jobType == "Instance"
		or (jobType == "table" and type(job.Destroy) == "function")
end

--[=[
	Executes the task as requested.

	@param job MaidTask -- Task to execute
]=]
function MaidTaskUtils.doTask(job: MaidTask)
	if typeof(job) == "function" then
		(job :: any)()
	elseif typeof(job) == "table" then
		if type(job.Destroy) == "function" then
			job:Destroy()
		end
	elseif typeof(job) == "Instance" then
		job:Destroy()
	elseif typeof(job) == "thread" then
		local cancelled
		if coroutine.running() ~= job then
			cancelled = pcall(function()
				task.cancel(job)
			end)
		end

		if not cancelled then
			task.defer(function()
				task.cancel(job)
			end)
		end
	elseif typeof(job) == "RBXScriptConnection" then
		job:Disconnect()
	else
		error(string.format("[MaidTaskUtils.doTask] - Bad job of type %q", typeof(job)))
	end
end

--[=[
	Executes the task delayed after some time.

	```lua
	-- delays cleanup by 5 seconds
	maid:GiveTask(MaidTaskUtils.delayed(5, gui))
	```

	@param time number -- Time in seconds
	@param job MaidTask -- Job to delay execution
	@return () -> () -- function that will execute the job delayed
]=]
function MaidTaskUtils.delayed(time: number, job: MaidTask)
	assert(type(time) == "number", "Bad time")
	assert(MaidTaskUtils.isValidTask(job), "Bad job")

	return function()
		task.delay(time, function()
			MaidTaskUtils.doTask(job)
		end)
	end
end

return MaidTaskUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="143">
            <Properties>
              <string name="Name">math</string>
            </Properties>
            <Item class="Folder" referent="144">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="145">
                <Properties>
                  <string name="Name">Math</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Holds utilty math functions not available on Roblox's math library.
	@class Math
]=]

local Math = {}

--[=[
	Maps a number from one range to another.

	:::note
	Note the mapped value can be outside of the initial range,
	which is very useful for linear interpolation.
	:::

	```lua
	print(Math.map(0.1, 0, 1, 1, 0)) --> 0.9
	```

	@param num number
	@param min0 number
	@param max0 number
	@param min1 number
	@param max1 number
	@return number
]=]
function Math.map(num: number, min0: number, max0: number, min1: number, max1: number): number
	if max0 == min0 then
		error("Range of zero")
	end

	return (((num - min0) * (max1 - min1)) / (max0 - min0)) + min1
end

--[=[
	Returns jittered value at the average value, with the spread being
	random.

	@param average number
	@param spread number? -- Defaults to 50% of the average number which is pretty standard for industry
	@param randomValue number?
	@return number
]=]
function Math.jitter(average: number, spread: number?, randomValue: number?): number
	local randomInput = randomValue or math.random()
	local thisSpread = spread or 0.5 * average

	return average - 0.5 * thisSpread + randomInput * thisSpread
end

--[=[
	Returns true if a number is NaN
	@param num number
	@return boolean
]=]
function Math.isNaN(num: number): boolean
	return num ~= num
end

--[=[
	Returns true if a number is finite
	@param num number
	@return boolean
]=]
function Math.isFinite(num: number): boolean
	return num > -math.huge and num < math.huge
end

--[=[
	Interpolates betweeen two numbers, given an percent. The percent is
	a number in the range that will be used to define how interpolated
	it is between num0 and num1.

	```lua
	print(Math.lerp(-1000, 1000, 0.75)) --> 500
	```

	@param num0 number -- Number
	@param num1 number -- Second number
	@param percent number -- The percent
	@return number -- The interpolated
]=]
function Math.lerp(num0: number, num1: number, percent: number): number
	return num0 + ((num1 - num0) * percent)
end

--[=[
	Solving for angle across from c

	@param a number
	@param b number
	@param c number
	@return number? -- Returns nil if this cannot be solved for
]=]
function Math.lawOfCosines(a: number, b: number, c: number): number?
	local l = (a * a + b * b - c * c) / (2 * a * b)
	local angle = math.acos(l)
	if angle ~= angle then
		return nil
	end
	return angle
end

--[=[
	Round the given number to given precision

	```lua
	print(Math.round(72.1, 5)) --> 75
	```

	@param number number
	@param precision number? -- Defaults to 1
	@return number
]=]
function Math.round(number: number, precision: number?): number
	if precision then
		return math.floor((number / precision) + 0.5) * precision
	else
		return math.floor(number + 0.5)
	end
end

--[=[
	Rounds up to the given precision

	@param number number
	@param precision number
	@return number
]=]
function Math.roundUp(number: number, precision: number): number
	return math.ceil(number / precision) * precision
end

--[=[
	Rounds down to the given precision

	@param number number
	@param precision number
	@return number
]=]
function Math.roundDown(number: number, precision: number): number
	return math.floor(number / precision) * precision
end

return Math
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="146">
            <Properties>
              <string name="Name">observablecollection</string>
            </Properties>
            <Item class="Folder" referent="147">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="148">
                <Properties>
                  <string name="Name">FilteredObservableListView</string>
                  <string name="Source"><![CDATA[--[=[
	@class FilteredObservableListView
]=]

local require = require(script.Parent.loader).load(script)

local BaseObject = require("BaseObject")
local Observable = require("Observable")
local ObservableSortedList = require("ObservableSortedList")
local Rx = require("Rx")

local FilteredObservableListView = setmetatable({}, BaseObject)
FilteredObservableListView.ClassName = "FilteredObservableListView"
FilteredObservableListView.__index = FilteredObservableListView

-- Higher numbers last
local function defaultCompare(a, b)
	-- equivalent of `return a - b` except it supports comparison of strings and stuff
	if b > a then
		return -1
	elseif b < a then
		return 1
	else
		return 0
	end
end

function FilteredObservableListView.new(observableList, observeScoreCallback, compare)
	local self = setmetatable(BaseObject.new(), FilteredObservableListView)

	self._compare = compare or defaultCompare
	self._baseList = assert(observableList, "No observableList")
	self._observeScoreCallback = assert(observeScoreCallback, "No observeScoreCallback")

	self._scoredList = self._maid:Add(ObservableSortedList.new(false, function(a, b)
		-- Preserve index when scoring does not
		if a.score == b.score then
			return a.index - b.index
		else
			return self._compare(a.score, b.score)
		end
	end))

	-- Shockingly this is somewhat performant because the sorted list defers all events
	-- to process the list reordering.
	self._maid:GiveTask(self._baseList:ObserveItemsBrio():Subscribe(function(brio)
		if brio:IsDead() then
			return
		end

		local maid = brio:ToMaid()
		local entry, key = brio:GetValue()
		local observeScore = self._observeScoreCallback(entry)
		assert(Observable.isObservable(observeScore), "Bad observeScore")

		maid._add = self._scoredList:Add(
			entry,
			Rx.combineLatest({
				score = observeScore,
				index = self._baseList:ObserveIndexByKey(key),
			}):Pipe({
				Rx.map(function(state)
					if state.score == nil then
						return nil
					end
					return state
				end),
			})
		)
	end))

	return self
end

--[=[
	Observes all items in the list
	@return Observable<Brio<T>>
]=]
function FilteredObservableListView:ObserveItemsBrio()
	return self._scoredList:ObserveItemsBrio()
end

--[=[
	Observes the index as it changes, until the entry at the existing
	key is removed.

	@param key Symbol
	@return Observable<number>
]=]
function FilteredObservableListView:ObserveIndexByKey(key)
	return self._scoredList:ObserveIndexByKey(key)
end

--[=[
	Gets the count of items in the list
	@return number
]=]
function FilteredObservableListView:GetCount()
	return self._scoredList:GetCount()
end

FilteredObservableListView.__len = FilteredObservableListView.GetCount

--[=[
	Observes the count of the list
	@return Observable<number>
]=]
function FilteredObservableListView:ObserveCount()
	return self._scoredList:ObserveCount()
end

return FilteredObservableListView
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="149">
                <Properties>
                  <string name="Name">ObservableCountingMap</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	An observable map that counts up/down and removes when the count is zero.
	@class ObservableCountingMap
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local DuckTypeUtils = require("DuckTypeUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableSubscriptionTable = require("ObservableSubscriptionTable")
local Set = require("Set")
local Signal = require("Signal")
local ValueObject = require("ValueObject")

local ObservableCountingMap = {}
ObservableCountingMap.ClassName = "ObservableCountingMap"
ObservableCountingMap.__index = ObservableCountingMap

export type ObservableCountingMap<T> = typeof(setmetatable(
	{} :: {
		--[=[
			Fires when an key is added
			@readonly
			@prop KeyAdded Signal<T>
			@within ObservableCountingMap
		]=]
		KeyAdded: Signal.Signal<T>,

		--[=[
			Fires when an key is removed.
			@readonly
			@prop KeyRemoved Signal<T>
			@within ObservableCountingMap
		]=]
		KeyRemoved: Signal.Signal<T>,

		--[=[
			Fires when an item count changes
			@readonly
			@prop KeyChanged Signal<T, number>
			@within ObservableCountingMap
		]=]
		KeyChanged: Signal.Signal<T, number>,

		--[=[
			Fires when the total count changes.
			@prop CountChanged Signal<number>
			@within ObservableCountingMap
		]=]
		TotalKeyCountChanged: Signal.Signal<number>,

		_maid: Maid.Maid,
		_map: { [T]: number },
		_keySubTable: any, -- ObservableSubscriptionTable.ObservableSubscriptionTable<number>,
		_totalKeyCountValue: ValueObject.ValueObject<number>,
	},
	{} :: typeof({ __index = ObservableCountingMap })
))

--[=[
	Constructs a new ObservableCountingMap
	@return ObservableCountingMap<T>
]=]
function ObservableCountingMap.new<T>(): ObservableCountingMap<T>
	local self: any = setmetatable({}, ObservableCountingMap)

	self._maid = Maid.new()
	self._map = {}

	self._totalKeyCountValue = self._maid:Add(ValueObject.new(0, "number"))
	self._keySubTable = self._maid:Add(ObservableSubscriptionTable.new())

	self.KeyAdded = self._maid:Add(Signal.new())
	self.KeyRemoved = self._maid:Add(Signal.new())
	self.KeyChanged = self._maid:Add(Signal.new())
	self.TotalKeyCountChanged = self._totalKeyCountValue.Changed

	return self
end

--[=[
	Returns whether the value is an observable counting map
	@param value any
	@return boolean
]=]
function ObservableCountingMap.isObservableMap(value: any): boolean
	return DuckTypeUtils.isImplementation(ObservableCountingMap, value)
end

--[=[
	Allows iteration over the observable counting map

	@return (T) -> ((T, nextIndex: any) -> ...any, T?)
]=]
function ObservableCountingMap.__iter<T>(self: ObservableCountingMap<T>)
	return pairs(self._map)
end

--[=[
	Observes the current set of active keys
	@return Observable<{ T }>
]=]
function ObservableCountingMap.ObserveKeysList<T>(self: ObservableCountingMap<T>): Observable.Observable<{ T }>
	return self:_observeDerivedDataStructureFromKeys(function()
		local list = table.create(self._totalKeyCountValue.Value)

		for key, _ in self._map do
			table.insert(list, key)
		end

		return list
	end)
end

--[=[
	Observes the current set of active keys
	@return Observable<{ [T]: true }>
]=]
function ObservableCountingMap.ObserveKeysSet<T>(self: ObservableCountingMap<T>): Observable.Observable<Set.Set<T>>
	return self:_observeDerivedDataStructureFromKeys(function()
		local set = {}

		for key, _ in self._map do
			set[key] = true
		end

		return set
	end)
end

function ObservableCountingMap._observeDerivedDataStructureFromKeys<T>(
	self: ObservableCountingMap<T>,
	gatherValues
): Observable.Observable<any>
	return Observable.new(function(sub)
		local maid = Maid.new()

		local function emit()
			sub:Fire(gatherValues())
		end

		maid:GiveTask(self.KeyAdded:Connect(emit))
		maid:GiveTask(self.KeyRemoved:Connect(emit))

		emit()

		self._maid[sub] = maid
		maid:GiveTask(function()
			self._maid[sub] = nil
			sub:Complete()
		end)

		return maid
	end)
end

--[=[
	Observes all keys in the map
	@return Observable<Brio<(T, number)>>
]=]
function ObservableCountingMap.ObservePairsBrio<T>(
	self: ObservableCountingMap<T>
): Observable.Observable<Brio.Brio<(T, number)>>
	return Observable.new(function(sub)
		local maid = Maid.new()
		local keyMaid: any = maid:Add(Maid.new())

		local function handleValue(key: T, value: number)
			if value ~= 0 then
				local brio = Brio.new(key, value)
				keyMaid[key] = brio
				sub:Fire(brio)
			else
				keyMaid[key] = nil
			end
		end

		for key, value in self._map do
			handleValue(key, value)
		end

		maid:GiveTask(self.KeyChanged:Connect(handleValue))

		self._maid[sub] = maid
		maid:GiveTask(function()
			self._maid[sub] = nil
			sub:Complete()
		end)

		return maid
	end) :: any
end

--[=[
	Observes the value for the given key.

	@param key TKey
	@return Observable<number>
]=]
function ObservableCountingMap.ObserveAtKey<T>(self: ObservableCountingMap<T>, key: T): Observable.Observable<number>
	assert(key ~= nil, "Bad key")

	return self._keySubTable:Observe(key, function(sub)
		sub:Fire(self._map[key] or 0)
	end)
end

--[=[
	Observes all keys in the map
	@return Observable<Brio<T>>
]=]
function ObservableCountingMap.ObserveKeysBrio<T>(self: ObservableCountingMap<T>): Observable.Observable<Brio.Brio<T>>
	return Observable.new(function(sub)
		local maid = Maid.new()
		local keyMaid: any = maid:Add(Maid.new())

		local function handleItem(key: T)
			-- Happens upon key added re-entrance
			if keyMaid[key] then
				return
			end

			local brio = Brio.new(key)
			keyMaid[key] = brio
			sub:Fire(brio)
		end

		maid:GiveTask(self.KeyAdded:Connect(handleItem))
		maid:GiveTask(self.KeyRemoved:Connect(function(key)
			keyMaid[key] = nil
		end))

		for key, _ in self._map do
			handleItem(key)
		end

		self._maid[sub] = maid
		maid:GiveTask(function()
			self._maid[sub] = nil
			sub:Complete()
		end)

		return maid
	end) :: any
end

--[=[
	Returns whether the map contains the key
	@param key T
	@return boolean
]=]
function ObservableCountingMap.Contains<T>(self: ObservableCountingMap<T>, key: T): boolean
	assert(key ~= nil, "Bad key")

	return self._map[key] ~= nil
end

--[=[
	Returns the count for the key or 0 if there is no key
	@param key T
	@return number
]=]
function ObservableCountingMap.Get<T>(self: ObservableCountingMap<T>, key: T): number
	assert(key ~= nil, "Bad key")

	return self._map[key] or 0
end

--[=[
	Gets the count of keys in the map
	@return number
]=]
function ObservableCountingMap.GetTotalKeyCount<T>(self: ObservableCountingMap<T>): number
	return self._totalKeyCountValue.Value
end

ObservableCountingMap.__len = ObservableCountingMap.GetTotalKeyCount

--[=[
	Observes the count of the keys in the map
	@return Observable<number>
]=]
function ObservableCountingMap.ObserveTotalKeyCount<T>(self: ObservableCountingMap<T>): Observable.Observable<number>
	return self._totalKeyCountValue:Observe()
end

--[=[
	Sets the current value
	@param key T
	@param amount number?
	@return callback
]=]
function ObservableCountingMap.Set<T>(self: ObservableCountingMap<T>, key: T, amount: number): () -> ()
	local current = self:Get(key)
	if current < amount then
		return self:Add(key, -(amount - current))
	elseif current > amount then
		return self:Add(key, current - amount)
	else
		return function() end
	end
end

--[=[
	Adds the key to the map if it does not exists.
	@param key T
	@param amount number?
	@return callback
]=]
function ObservableCountingMap.Add<T>(self: ObservableCountingMap<T>, key: T, amount: number?): () -> ()
	assert(key ~= nil, "Bad key")
	assert(type(amount) == "number" or amount == nil, "Bad amount")

	local change: number = amount or 1
	if change == 0 then
		return function() end
	end

	local oldValue = self._map[key]

	if oldValue then
		local newValue = oldValue + change
		if newValue == 0 then
			-- Remove item
			self._map[key] = nil

			-- Fire events
			self._totalKeyCountValue.Value = self._totalKeyCountValue.Value - 1

			if self.Destroy then
				self.KeyRemoved:Fire(key)
			end

			if self.Destroy then
				self.KeyChanged:Fire(key, 0)
				self._keySubTable:Fire(key, 0)
			end
		else
			-- Update item
			self._map[key] = newValue
			self.KeyChanged:Fire(key, newValue)
			self._keySubTable:Fire(key, newValue)
		end
	else
		-- Add item
		self._map[key] = change

		-- Fire events
		self._totalKeyCountValue.Value = self._totalKeyCountValue.Value + 1

		if self.Destroy then
			self.KeyAdded:Fire(key)
		end

		if self.Destroy then
			self.KeyChanged:Fire(key, change)
			self._keySubTable:Fire(key, change)
		end
	end

	local removed = false
	return function()
		if self.Destroy and not removed then
			removed = true
			self:Add(key, -change)
		end
	end
end

--[=[
	Removes the key from the set if it exists.
	@param key T
	@param amount number?
	@return callback
]=]
function ObservableCountingMap.Remove<T>(self: ObservableCountingMap<T>, key: T, amount: number?): () -> ()
	assert(key ~= nil, "Bad key")
	assert(type(amount) == "number" or amount == nil, "Bad amount")

	return self:Add(key, -(amount or 1))
end

--[=[
	Gets the first key
	@return T
]=]
function ObservableCountingMap.GetFirstKey<T>(self: ObservableCountingMap<T>): T?
	local value = next(self._map)
	return value
end

--[=[
	Gets a list of all keys.
	@return { T }
]=]
function ObservableCountingMap.GetKeyList<T>(self: ObservableCountingMap<T>): { T }
	local list = table.create(self._totalKeyCountValue.Value)
	for key, _ in self._map do
		table.insert(list, key)
	end
	return list
end

--[=[
	Cleans up the ObservableCountingMap and sets the metatable to nil.
]=]
function ObservableCountingMap.Destroy<T>(self: ObservableCountingMap<T>): ()
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return ObservableCountingMap
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="150">
                <Properties>
                  <string name="Name">ObservableCountingMap.spec</string>
                  <string name="Source"><![CDATA[--[[
	@class ObservableCountingMap.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local ObservableCountingMap = require("ObservableCountingMap")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("ObservableCountingMap.new()", function()
	local observableCountingMap = ObservableCountingMap.new()

	it("should return 0 for unset values", function()
		expect(observableCountingMap:Get("a")).toEqual(0)
		expect(observableCountingMap:GetTotalKeyCount()).toEqual(0)
	end)

	it("should allow you to add to a value", function()
		expect(observableCountingMap:Get("a")).toEqual(0)
		expect(observableCountingMap:GetTotalKeyCount()).toEqual(0)
		observableCountingMap:Add("a", 5)
		expect(observableCountingMap:Get("a")).toEqual(5)
		expect(observableCountingMap:GetTotalKeyCount()).toEqual(1)
	end)

	it("should allow you to add to a value that is already defined", function()
		expect(observableCountingMap:Get("a")).toEqual(5)
		expect(observableCountingMap:GetTotalKeyCount()).toEqual(1)
		observableCountingMap:Add("a", 5)
		expect(observableCountingMap:Get("a")).toEqual(10)
		expect(observableCountingMap:GetTotalKeyCount()).toEqual(1)
	end)

	it("should clean up", function()
		observableCountingMap:Destroy()
	end)
end)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="151">
                <Properties>
                  <string name="Name">ObservableList</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	A list that can be observed for blend and other components
	@class ObservableList
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local DuckTypeUtils = require("DuckTypeUtils")
local ListIndexUtils = require("ListIndexUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableSubscriptionTable = require("ObservableSubscriptionTable")
local RxBrioUtils = require("RxBrioUtils")
local Signal = require("Signal")
local SortFunctionUtils = require("SortFunctionUtils")
local Symbol = require("Symbol")
local ValueObject = require("ValueObject")

local ObservableList = {}
ObservableList.ClassName = "ObservableList"
ObservableList.__index = ObservableList

export type ObservableList<T> = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_keyList: { Symbol.Symbol },
		_contents: { [Symbol.Symbol]: T },
		_indexes: { [Symbol.Symbol]: number },
		_indexObservers: any, -- ObservableSubscriptionTable.ObservableSubscriptionTable<T?>,
		_keyIndexObservables: any, -- ObservableSubscriptionTable.ObservableSubscriptionTable<number?>,
		_countValue: ValueObject.ValueObject<number>,

		--[=[
			Fires when an item is added
			@readonly
			@prop ItemAdded Signal<T, number, Symbol>
			@within ObservableList
		]=]
		ItemAdded: Signal.Signal<T, number, Symbol.Symbol>,

		--[=[
			Fires when an item is removed.
			@readonly
			@prop ItemRemoved Signal<T, Symbol>
			@within ObservableList
		]=]
		ItemRemoved: Signal.Signal<T, Symbol.Symbol>,

		--[=[
			Fires when the count changes.
			@prop CountChanged Signal.Signal<number>,
			@within ObservableList
		]=]
		CountChanged: Signal.Signal<number>,
	},
	{} :: typeof({ __index = ObservableList })
))

--[=[
	Constructs a new ObservableList
	@return ObservableList<T>
]=]
function ObservableList.new<T>(): ObservableList<T>
	local self: ObservableList<T> = setmetatable({} :: any, ObservableList)

	self._maid = Maid.new()

	self._keyList = {} -- { [number]: Symbol }
	self._contents = {} -- { [Symbol]: T }
	self._indexes = {} -- { [Symbol]: number }

	self._indexObservers = self._maid:Add(ObservableSubscriptionTable.new())
	self._keyIndexObservables = self._maid:Add(ObservableSubscriptionTable.new())
	self._countValue = self._maid:Add(ValueObject.new(0, "number"))

	self.ItemAdded = self._maid:Add(Signal.new() :: any)
	self.ItemRemoved = self._maid:Add(Signal.new() :: any)
	self.CountChanged = self._countValue.Changed :: any

	return self
end

--[=[
	Returns whether the value is an observable list
	@param value any
	@return boolean
]=]
function ObservableList.isObservableList(value: any): boolean
	return DuckTypeUtils.isImplementation(ObservableList, value)
end

--[=[
	Observes the list, allocating a new list in the process.

	@return Observable<{ T }>
]=]
function ObservableList.Observe<T>(self: ObservableList<T>): Observable.Observable<{ T }>
	return Observable.new(function(sub)
		local maid = Maid.new()

		local function queueFire()
			if maid._queue then
				return
			end

			maid._queue = task.defer(function()
				maid._queue = nil
				sub:Fire(self:GetList())
			end)
		end

		maid:GiveTask(self.ItemAdded:Connect(queueFire))
		maid:GiveTask(self.ItemRemoved:Connect(queueFire))

		return maid
	end) :: any
end

--[=[
	Allows iteration over the observable map

	@return (T) -> ((T, nextIndex: any) -> ...any, T?)
]=]
function ObservableList.__iter<T>(self: ObservableList<T>): SortFunctionUtils.WrappedIterator<number, T>
	return coroutine.wrap(function()
		for index, value in self._keyList do
			coroutine.yield(index, self._contents[value])
		end
	end)
end

--[=[
	Observes all items in the list
	@return Observable<Brio<T>>
]=]
function ObservableList.ObserveItemsBrio<T>(self: ObservableList<T>): Observable.Observable<Brio.Brio<T>>
	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleItem(item: T, _index, includeKey)
			local brio = Brio.new(item, includeKey)
			maid[includeKey] = brio
			sub:Fire(brio)
		end

		maid:GiveTask(self.ItemAdded:Connect(handleItem))
		maid:GiveTask(self.ItemRemoved:Connect(function(_item, includeKey)
			maid[includeKey] = nil
		end))

		for index, key in self._keyList do
			handleItem(self._contents[key], index, key)
		end

		self._maid[sub] = maid
		maid:GiveTask(function()
			self._maid[sub] = nil
			sub:Complete()
		end)

		return maid
	end) :: any
end

--[=[
	Observes the index as it changes, until the entry at the existing
	index is removed.

	@param indexToObserve number
	@return Observable<number?>
]=]
function ObservableList.ObserveIndex<T>(self: ObservableList<T>, indexToObserve: number): Observable.Observable<number?>
	assert(type(indexToObserve) == "number", "Bad indexToObserve")

	local key = self._keyList[indexToObserve]
	if not key then
		error(string.format("No entry at index %d, cannot observe changes", indexToObserve))
	end

	return self:ObserveIndexByKey(key)
end

--[=[
	Observes the current value at a given index. This can be useful for observing
	the first entry, or matching stuff up to a given slot.

	```
	list:ObserveAtIndex(1):Subscribe(print) --> prints first item
	list:ObserveAtIndex(-1):Subscribe(print) --> prints last item
	```

	@param indexToObserve number
	@return Observable<T?>
]=]
function ObservableList.ObserveAtIndex<T>(self: ObservableList<T>, indexToObserve: number): Observable.Observable<T?>
	assert(type(indexToObserve) == "number", "Bad indexToObserve")

	return self._indexObservers:Observe(indexToObserve, function(sub)
		sub:Fire(self:Get(indexToObserve))
	end)
end

--[=[
	Observes the current value at a given index. This can be useful for observing
	the first entry, or matching stuff up to a given slot.

	@param indexToObserve number
	@return Observable<Brio<T>>
]=]
function ObservableList.ObserveAtIndexBrio<T>(
	self: ObservableList<T>,
	indexToObserve: number
): Observable.Observable<Brio.Brio<T>>
	assert(type(indexToObserve) == "number", "Bad indexToObserve")

	return self:ObserveAtIndex(indexToObserve):Pipe({
		RxBrioUtils.toBrio() :: any,
		RxBrioUtils.onlyLastBrioSurvives() :: any,
	}) :: any
end

--[=[
	Removes the first instance found in contents

	@param value T
	@return boolean
]=]
function ObservableList.RemoveFirst<T>(self: ObservableList<T>, value: T): boolean
	for key, item in self._contents do
		if item == value then
			self:RemoveByKey(key)
			return true
		end
	end

	return false
end

--[=[
	Returns an ValueObject that represents the CountValue

	@return ValueObject<number>
]=]
function ObservableList.GetCountValue<T>(self: ObservableList<T>): ValueObject.ValueObject<number>
	return self._countValue
end

--[=[
	Observes the index as it changes, until the entry at the existing
	key is removed.

	@param key Symbol
	@return Observable<number?>
]=]
function ObservableList.ObserveIndexByKey<T>(self: ObservableList<T>, key: Symbol.Symbol): Observable.Observable<number?>
	assert(Symbol.isSymbol(key), "Bad key")

	return self._keyIndexObservables:Observe(key, function(sub)
		sub:Fire(self:GetIndexByKey(key))
	end) :: any
end

--[=[
	Gets the current index from the key

	@param key Symbol
	@return number?
]=]
function ObservableList.GetIndexByKey<T>(self: ObservableList<T>, key: Symbol.Symbol): number?
	local currentIndex = self._indexes[key]
	if currentIndex then
		return currentIndex
	else
		return nil
	end
end

--[=[
	Gets the count of items in the list
	@return number
]=]
function ObservableList.GetCount<T>(self: ObservableList<T>): number
	return self._countValue.Value or 0
end

ObservableList.__len = ObservableList.GetCount

--[=[
	Observes the count of the list
	@return Observable<number>
]=]
function ObservableList.ObserveCount<T>(self: ObservableList<T>): Observable.Observable<number>
	return self._countValue:Observe()
end

--[=[
	Adds the item to the list at the specified index
	@param item T
	@return callback -- Call to remove
]=]
function ObservableList.Add<T>(self: ObservableList<T>, item: T): () -> ()
	return self:InsertAt(item, #self._keyList + 1)
end

--[=[
	Gets the current item at the index, or nil if it is not defined.
	@param index number
	@return T?
]=]
function ObservableList.Get<T>(self: ObservableList<T>, index: number): T?
	assert(type(index) == "number", "Bad index")

	index = ListIndexUtils.toPositiveIndex(#self._keyList, index)

	local key = self._keyList[index]
	if not key then
		return nil
	end

	return self._contents[key]
end

--[=[
	Adds the item to the list at the specified index
	@param item T
	@param index number?
	@return callback -- Call to remove
]=]
function ObservableList.InsertAt<T>(self: ObservableList<T>, item: T, index: number?): () -> ()
	assert(item ~= nil, "Bad item")
	assert(type(index) == "number", "Bad index")

	index = math.clamp(index, 1, #self._keyList + 1)

	local key = Symbol.named("entryKey")

	self._contents[key] = item
	self._indexes[key] = index

	local changed = {}

	local n = #self._keyList
	for i = n, index, -1 do
		local nextKey = self._keyList[i]
		self._indexes[nextKey] = i + 1
		self._keyList[i + 1] = nextKey

		table.insert(changed, {
			key = nextKey,
			newIndex = i + 1,
		})
	end

	self._keyList[index] = key
	local listLength = #self._keyList

	-- Fire off count
	self._countValue.Value = self._countValue.Value + 1

	-- Fire off add
	self.ItemAdded:Fire(item, index, key)

	-- Fire off the index change on the value
	self._keyIndexObservables:Fire(key, index)
	self._indexObservers:Fire(index, item)
	self._indexObservers:Fire(ListIndexUtils.toNegativeIndex(listLength, index), item)

	for _, data in changed do
		if self._indexes[data.key] == data.newIndex then
			self._indexObservers:Fire(data.newIndex, self._contents[data.key])
			self._indexObservers:Fire(ListIndexUtils.toNegativeIndex(listLength, index), self._contents[data.key])
			self._keyIndexObservables:Fire(data.key, data.newIndex)
		end
	end

	return function()
		if self.Destroy then
			self:RemoveByKey(key)
		end
	end
end

--[=[
	Removes the item at the index
	@param index number
	@return T
]=]
function ObservableList.RemoveAt<T>(self: ObservableList<T>, index: number): T?
	assert(type(index) == "number", "Bad index")

	local key = self._keyList[index]
	if not key then
		return nil
	end

	return self:RemoveByKey(key)
end

--[=[
	Removes the item from the list if it exists.
	@param key Symbol
	@return T
]=]
function ObservableList.RemoveByKey<T>(self: ObservableList<T>, key): T?
	assert(key ~= nil, "Bad key")

	local index = self._indexes[key]
	if not index then
		return nil
	end

	local item = self._contents[key]
	if item == nil then
		return nil
	end

	self._indexes[key] = nil
	self._contents[key] = nil

	local changed = {}

	-- shift everything down
	local n = #self._keyList
	for i = index, n - 1 do
		local nextKey = self._keyList[i + 1]
		self._indexes[nextKey] = i
		self._keyList[i] = nextKey

		table.insert(changed, {
			key = nextKey,
			newIndex = i,
		})
	end
	self._keyList[n] = nil
	local listLength = #self._keyList

	-- Fire off that count changed
	self._countValue.Value = self._countValue.Value - 1

	if self.Destroy then
		self.ItemRemoved:Fire(item, key)
	end

	-- Fire off the index change on the value
	self._keyIndexObservables:Complete(key)
	self._indexObservers:Fire(listLength, nil)

	if listLength == 0 then
		self._indexObservers:Fire(-1, nil)
	end

	-- Fire off index change on each key list (if the data isn't stale)
	for _, data in changed do
		if self._indexes[data.key] == data.newIndex then
			self._indexObservers:Fire(data.newIndex, self._contents[data.key])
			self._indexObservers:Fire(ListIndexUtils.toNegativeIndex(listLength, index), self._contents[data.key])
			self._keyIndexObservables:Fire(data.key, data.newIndex)
		end
	end

	return item
end

--[=[
	Gets a list of all entries.
	@return { T }
]=]
function ObservableList.GetList<T>(self: ObservableList<T>): { T }
	local list = table.create(#self._keyList)
	for index, key in self._keyList do
		list[index] = self._contents[key]
	end
	return list
end

--[=[
	Cleans up the ObservableList and sets the metatable to nil.
]=]
function ObservableList.Destroy<T>(self: ObservableList<T>)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return ObservableList
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="152">
                <Properties>
                  <string name="Name">ObservableList.spec</string>
                  <string name="Source"><![CDATA[--[[
	@class ObservableList.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local ObservableList = require("ObservableList")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("ObservableList.new()", function()
	local observableList = ObservableList.new()

	it("should return nil for unset values", function()
		expect(observableList:Get(1)).toEqual(nil)
	end)

	it("should allow inserting an value", function()
		expect(observableList:GetCount()).toEqual(0)

		observableList:Add("a")

		expect(observableList:Get(1)).toEqual("a")
		expect(observableList:GetCount()).toEqual(1)
	end)

	it("should allow negative queries", function()
		expect(observableList:Get(-1)).toEqual("a")
		expect(observableList:Get(-2)).toEqual(nil)
	end)

	it("should allow false as a value", function()
		expect(observableList:Get(2)).toEqual(nil)
		observableList:Add(false)
		expect(observableList:Get(2)).toEqual(false)
	end)

	it("should allow negative queries after false", function()
		expect(observableList:Get(1)).toEqual("a")
		expect(observableList:Get(2)).toEqual(false)

		expect(observableList:Get(-1)).toEqual(false)
		expect(observableList:Get(-2)).toEqual("a")
	end)

	it("should fire off events for a specific key", function()
		local seen = {}
		local sub = observableList:ObserveIndex(1):Subscribe(function(value)
			table.insert(seen, value)
		end)
		observableList:InsertAt("c", 1)

		sub:Destroy()

		expect(#seen).toEqual(2)
		expect(seen[1]).toEqual(1)
		expect(seen[2]).toEqual(2)
	end)

	it("should fire off events for all keys", function()
		local seen = {}
		local sub = observableList:ObserveItemsBrio():Subscribe(function(value)
			table.insert(seen, value)
		end)
		observableList:Add("a")

		local value = seen[4]:GetValue()
		expect(#seen).toEqual(4)
		expect(value).toEqual("a")
		expect(seen[4]:IsDead()).toEqual(false)

		sub:Destroy()

		expect(#seen).toEqual(4)
		expect(seen[4]:IsDead()).toEqual(true)
	end)

	it("it should be able to observe a specific key", function()
		local seen = {}
		local sub = observableList:ObserveAtIndex(1):Subscribe(function(value)
			table.insert(seen, value)
		end)

		local originalList = observableList:GetList()
		expect(originalList[1]).toEqual("c")

		observableList:InsertAt("dragon", 1)

		sub:Destroy()

		expect(#seen).toEqual(2)
		expect(seen[1]).toEqual("c")
		expect(seen[2]).toEqual("dragon")
	end)

	it("it should be able to observe a specific negative key", function()
		local seen = {}
		local sub = observableList:ObserveAtIndex(-1):Subscribe(function(value)
			table.insert(seen, value)
		end)

		local originalList = observableList:GetList()
		expect(originalList[#originalList]).toEqual("a")

		observableList:Add("fire")

		sub:Destroy()

		expect(#seen).toEqual(2)
		expect(seen[1]).toEqual("a")
		expect(seen[2]).toEqual("fire")
	end)

	it("should fire off events on removal", function()
		local seen = {}
		local sub = observableList:ObserveIndex(2):Subscribe(function(value)
			table.insert(seen, value)
		end)
		observableList:RemoveAt(1)

		sub:Destroy()

		expect(#seen).toEqual(2)
		expect(seen[1]).toEqual(2)
		expect(seen[2]).toEqual(1)
	end)

	it("should clean up", function()
		observableList:Destroy()
	end)
end)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="153">
                <Properties>
                  <string name="Name">ObservableMap</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	A list that can be observed for blend and other components
	@class ObservableMap
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local DuckTypeUtils = require("DuckTypeUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableSubscriptionTable = require("ObservableSubscriptionTable")
local RxBrioUtils = require("RxBrioUtils")
local Signal = require("Signal")
local ValueObject = require("ValueObject")

local ObservableMap = {}
ObservableMap.ClassName = "ObservableMap"
ObservableMap.__index = ObservableMap

export type ObservableMap<TKey, TValue> = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_map: { [TKey]: TValue },
		_keySubTable: any, -- ObservableSubscriptionTable.ObservableSubscriptionTable<TKey>,
		_countValue: ValueObject.ValueObject<number>,

		--[=[
			Fires when a key is added
			@readonly
			@prop KeyAdded Signal<TKey, TValue?>
			@within ObservableMap
		]=]
		KeyAdded: Signal.Signal<(TKey, TValue)>,

		--[=[
			Fires when a key is removed
			@readonly
			@prop KeyRemoved Signal<TKey>
			@within ObservableMap
		]=]
		KeyRemoved: Signal.Signal<TKey>,

		--[=[
			Fires when a key value changes, including add and remove.
			@readonly
			@prop KeyValueChanged Signal<(TKey, TValue?, TValue?)>
			@within ObservableMap
		]=]
		KeyValueChanged: Signal.Signal<(TKey, TValue?, TValue?)>,

		--[=[
			Fires when the count changes.
			@prop CountChanged Signal.Signal<number>
			@within ObservableMap
		]=]
		CountChanged: Signal.Signal<number>,
	},
	{} :: typeof({ __index = ObservableMap })
))

--[=[
	Constructs a new ObservableMap
	@return ObservableMap<TKey, TValue>
]=]
function ObservableMap.new<TKey, TValue>(): ObservableMap<TKey, TValue>
	local self: any = setmetatable({} :: any, ObservableMap)

	self._maid = Maid.new()
	self._map = {}

	self._keySubTable = self._maid:Add(ObservableSubscriptionTable.new())
	self._countValue = self._maid:Add(ValueObject.new(0, "number"))

	self.KeyAdded = self._maid:Add(Signal.new()) -- :Fire(key, value)
	self.KeyRemoved = self._maid:Add(Signal.new()) -- :Fire(key)
	self.KeyValueChanged = self._maid:Add(Signal.new()) -- :Fire(key, value, oldValue)
	self.CountChanged = self._countValue.Changed

	return self
end

--[=[
	Returns whether the set is an observable map
	@param value any
	@return boolean
]=]
function ObservableMap.isObservableMap(value: any): boolean
	return DuckTypeUtils.isImplementation(ObservableMap, value)
end

--[=[
	Allows iteration over the observable map

	@return (T) -> ((T, nextIndex: any) -> ...any, T?)
]=]
function ObservableMap.__iter<TKey, TValue>(self: ObservableMap<TKey, TValue>): ...any
	return pairs(self._map)
end

--[=[
	Observes all keys in the map
	@return Observable<Brio<TKey>>
]=]
function ObservableMap.ObserveKeysBrio<TKey, TValue>(self: ObservableMap<TKey, TValue>): Observable.Observable<Brio.Brio<TKey>>
	return self:_observeKeyValueChanged(function(key: TKey, _value: TValue)
		return Brio.new(key)
	end) :: any
end

--[=[
	Observes all keys in the map
	@return Observable<Brio<TKey>>
]=]
function ObservableMap.ObserveValuesBrio<TKey, TValue>(self: ObservableMap<TKey, TValue>): Observable.Observable<Brio.Brio<TValue>>
	return self:_observeKeyValueChanged(function(_key: TKey, value: TValue)
		return Brio.new(value)
	end) :: any
end

--[=[
	Observes all keys in the map
	@return Observable<Brio<(TKey, TValue)>>
]=]
function ObservableMap.ObservePairsBrio<TKey, TValue>(
	self: ObservableMap<TKey, TValue>
): Observable.Observable<Brio.Brio<(TKey, TValue)>>
	return self:_observeKeyValueChanged(function(key: TKey, value: TValue)
		return Brio.new(key, value)
	end) :: any
end

function ObservableMap._observeKeyValueChanged<TKey, TValue>(
	self: ObservableMap<TKey, TValue>,
	packValue: (TKey, TValue) -> any
): Observable.Observable<Brio.Brio<(TKey, TValue)>>
	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleValue(key: TKey, value: TValue?, _oldValue: TValue?)
			if value ~= nil then
				local brio = packValue(key, value)
				maid[key :: any] = brio
				sub:Fire(brio)
			else
				maid[key :: any] = nil
			end
		end

		for key, value in self._map do
			handleValue(key, value)
		end

		local conn = self.KeyValueChanged:Connect(handleValue)

		local function cleanup()
			self._maid[sub] = nil
			conn:Disconnect()
			sub:Complete()
			maid:Destroy()
		end
		self._maid[sub] = cleanup
		return cleanup
	end) :: any
end

--[=[
	Returns the value for the given key
	@param key TKey
	@return TValue
]=]
function ObservableMap.Get<TKey, TValue>(self: ObservableMap<TKey, TValue>, key: TKey): TValue?
	assert(key ~= nil, "Bad key")

	return self._map[key]
end

--[=[
	Returns whether the map contains the key
	@param key TKey
	@return boolean
]=]
function ObservableMap.ContainsKey<TKey, TValue>(self: ObservableMap<TKey, TValue>, key: TKey): boolean
	assert(key ~= nil, "Bad key")

	return self._map[key] ~= nil
end

--[=[
	Gets the count of items in the set
	@return number
]=]
function ObservableMap.GetCount<TKey, TValue>(self: ObservableMap<TKey, TValue>): number
	return self._countValue.Value or 0
end

ObservableMap.__len = ObservableMap.GetCount

--[=[
	Observes the count of the set

	@return Observable<number>
]=]
function ObservableMap.ObserveCount<TKey, TValue>(self: ObservableMap<TKey, TValue>): Observable.Observable<number>
	return self._countValue:Observe()
end

--[=[
	Observes the value for the given key.

	@param key TKey
	@return Observable<Brio<TValue>>
]=]
function ObservableMap.ObserveAtKeyBrio<TKey, TValue>(
	self: ObservableMap<TKey, TValue>,
	key: TKey
): Observable.Observable<Brio.Brio<TValue>>
	assert(key ~= nil, "Bad key")

	return self:ObserveAtKey(key):Pipe({
		RxBrioUtils.switchToBrio(function(value): boolean
			return value ~= nil
		end) :: any,
	}) :: any
end

--[=[
	Observes the value for the given key.

	@param key TKey
	@return Observable<TValue?>
]=]
function ObservableMap.ObserveAtKey<TKey, TValue>(self: ObservableMap<TKey, TValue>, key: TKey): Observable.Observable<TValue?>
	assert(key ~= nil, "Bad key")

	return self._keySubTable:Observe(key, function(sub)
		sub:Fire(self._map[key] :: any)
	end) :: any
end

--[=[
	Observes the value for the given key. Alias for [ObservableMap.ObserveAtKey].

	@function ObserveValueForKey
	@param key TKey
	@return Observable<TValue?>
	@within ObservableMap
]=]
ObservableMap.ObserveValueForKey = ObservableMap.ObserveAtKey

--[=[
	Adds the item to the set if it does not exists.
	@param key TKey
	@param value TValue?
	@return callback -- Call to remove the value if it was added
]=]
function ObservableMap.Set<TKey, TValue>(self: ObservableMap<TKey, TValue>, key: TKey, value: TValue?): () -> ()
	assert(key ~= nil, "Bad key")

	local oldValue: TValue? = self._map[key]
	if oldValue == value then
		-- no removal since we never added. this is a tad messy.
		return function() end
	end

	self._map[key] = value :: any

	if value == nil then
		self._countValue.Value = self._countValue.Value - 1
		self.KeyRemoved:Fire(key)
	elseif oldValue == nil then
		self._countValue.Value = self._countValue.Value + 1
		self.KeyAdded:Fire(key, value)
	end

	self.KeyValueChanged:Fire(key, value, oldValue)
	self._keySubTable:Fire(key, value)

	return self:_getRemovalCallback(key, value)
end

function ObservableMap._getRemovalCallback<TKey, TValue>(self: ObservableMap<TKey, TValue>, key: TKey, value: TValue?): () -> ()
	return function()
		if not self.Destroy then
			return
		end

		if self._map[key] == value then
			self:Remove(key)
		end
	end
end

--[=[
	Removes the item from the map if it exists.
	@param key TKey
]=]
function ObservableMap.Remove<TKey, TValue>(self: ObservableMap<TKey, TValue>, key: TKey): ()
	assert(key ~= nil, "Bad key")

	self:Set(key, nil)
end

--[=[
	Gets a list of all values.
	@return { TValue }
]=]
function ObservableMap.GetValueList<TKey, TValue>(self: ObservableMap<TKey, TValue>): { TValue }
	local list = table.create(self._countValue.Value)
	for _, value in self._map do
		table.insert(list, value)
	end
	return list
end

--[=[
	Gets a list of all keys.
	@return { TKey }
]=]
function ObservableMap.GetKeyList<TKey, TValue>(self: ObservableMap<TKey, TValue>): { TKey }
	local list = table.create(self._countValue.Value)
	for key, _ in self._map do
		table.insert(list, key)
	end
	return list
end

--[=[
	Observes the list of all keys.
	@return Observable<{ TKey }>
]=]
function ObservableMap.ObserveKeyList<TKey, TValue>(self: ObservableMap<TKey, TValue>): Observable.Observable<{ TKey }>
	return Observable.new(function(sub)
		local topMaid = Maid.new()

		-- TODO: maybe don't allocate as much here?
		local keyList = table.create(self._countValue.Value)
		for key, _ in self._map do
			table.insert(keyList, key)
		end

		topMaid:GiveTask(self.KeyAdded:Connect(function(addedKey)
			table.insert(keyList, addedKey)
			sub:Fire(table.clone(keyList))
		end))

		topMaid:GiveTask(self.KeyRemoved:Connect(function(removedKey)
			local index = table.find(keyList, removedKey)
			if index then
				table.remove(keyList, index)
			end
			sub:Fire(table.clone(keyList))
		end))

		sub:Fire(table.clone(keyList))

		return topMaid
	end) :: any
end

--[=[
	Cleans up the ObservableMap and sets the metatable to nil.
]=]
function ObservableMap.Destroy<TKey, TValue>(self: ObservableMap<TKey, TValue>)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return ObservableMap
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="154">
                <Properties>
                  <string name="Name">ObservableMap.spec</string>
                  <string name="Source"><![CDATA[--[[
	@class ObservableMap.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local ObservableMap = require("ObservableMap")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("ObservableMap.new()", function()
	local observableMap = ObservableMap.new()

	it("should return nil for unset values", function()
		expect(observableMap:Get("a")).toEqual(nil)
	end)

	it("should allow setting a value", function()
		expect(observableMap:GetCount()).toEqual(0)

		observableMap:Set("a", "Hello World")

		expect(observableMap:Get("a")).toEqual("Hello World")
		expect(observableMap:GetCount()).toEqual(1)
	end)

	it("should overwrite values", function()
		expect(observableMap:Get("a")).toEqual("Hello World")

		observableMap:Set("a", "Hello World 2")

		expect(observableMap:Get("a")).toEqual("Hello World 2")
	end)

	it("should allow false as a key", function()
		expect(observableMap:Get(false)).toEqual(nil)
		observableMap:Set(false, "Hello")
		expect(observableMap:Get(false)).toEqual("Hello")
	end)

	it("should fire off events for a specific key", function()
		local seen = {}
		local sub = observableMap:ObserveValueForKey("c"):Subscribe(function(value)
			table.insert(seen, value)
		end)
		observableMap:Set("c", "Hello")

		sub:Destroy()

		expect(#seen).toEqual(1)
		expect(seen[1]).toEqual("Hello")
	end)

	it("should fire off events for all keys", function()
		local seen = {}
		local sub = observableMap:ObserveValuesBrio():Subscribe(function(value)
			table.insert(seen, value)
		end)
		observableMap:Set("d", "Hello")

		expect(#seen).toEqual(4)
		expect(seen[4]:GetValue()).toEqual("Hello")
		expect(seen[4]:IsDead()).toEqual(false)

		sub:Destroy()

		expect(#seen).toEqual(4)
		expect(seen[4]:IsDead()).toEqual(true)
	end)

	it("should clean up", function()
		observableMap:Destroy()
	end)
end)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="155">
                <Properties>
                  <string name="Name">ObservableMapList</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Holds a map of lists. This is good for list-based

	@class ObservableMapList
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableList = require("ObservableList")
local ObservableMap = require("ObservableMap")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local Signal = require("Signal")

local ObservableMapList = {}
ObservableMapList.ClassName = "ObservableMapList"
ObservableMapList.__index = ObservableMapList

type ObservableList<T> = any --ObservableList.ObservableList<T>

export type ObservableMapList<TKey, TValue> = typeof(setmetatable(
	{} :: {
		_observableMapOfLists: any, --ObservableMap.ObservableMap<TKey, ObservableList<TValue>>,
		_maid: Maid.Maid,

		--[=[
			Fires when an item is added
			@readonly
			@prop ListAdded Signal<TKey>
			@within ObservableMapSet
		]=]
		ListAdded: Signal.Signal<TKey, ObservableList<TValue>>,

		--[=[
			Fires when an item is removed
			@readonly
			@prop ListRemoved Signal<TKey>
			@within ObservableMapSet
		]=]
		ListRemoved: Signal.Signal<TKey>,

		--[=[
			Fires when the count changes.
			@prop CountChanged RBXScriptSignal
			@within ObservableMap
		]=]
		CountChanged: Signal.Signal<number>,
	},
	{} :: typeof({ __index = ObservableMapList })
))

--[=[
	Constructs a new ObservableMapList
	@return ObservableMapList<TKey, TValue>
]=]
function ObservableMapList.new<TKey, TValue>(): ObservableMapList<TKey, TValue>
	local self: ObservableMapList<TKey, TValue> = setmetatable({} :: any, ObservableMapList)

	self._maid = Maid.new()
	self._observableMapOfLists = self._maid:Add(ObservableMap.new())

	self.ListAdded = assert(self._observableMapOfLists.KeyAdded, "Bad KeyAdded") -- :Fire(key, set)
	self.ListRemoved = assert(self._observableMapOfLists.KeyRemoved, "Bad KeyRemoved") -- :Fire(key)
	self.CountChanged = assert(self._observableMapOfLists.CountChanged, "Bad CountChanged")

	return self
end

--[=[
	Adds an entry with a dynamic key. This is great for caching things
	that need to be looked up by key.

	:::tip
	If `observeKey` emits nil then the value will be excluded from the list.
	:::

	@param entry TValue
	@param observeKey Observable<TKey>
	@return MaidTask -- Cleanup object that will remove the entry
]=]
function ObservableMapList.Push<TKey, TValue>(self: ObservableMapList<TKey, TValue>, observeKey, entry: TValue): Maid.Maid
	assert(observeKey ~= nil, "Bad observeKey")
	assert(entry ~= nil, "Bad entry")

	local maid = Maid.new()

	if Observable.isObservable(observeKey) then
		maid:GiveTask(observeKey:Subscribe(function(key)
			maid._currentAddValue = nil

			if key ~= nil then
				maid._currentAddValue = self:_addToList(key, entry)
			end
		end))
	else
		maid:GiveTask(self:_addToList(observeKey, entry))
	end

	-- Ensure self-cleanup when map cleans up
	self._maid[maid] = maid
	maid:GiveTask(function()
		self._maid[maid] = nil
	end)

	return maid
end

--[=[
	Gets the first item for the given key

	@param key TKey
	@return TValue | nil
]=]
function ObservableMapList.GetFirstItemForKey<TKey, TValue>(self: ObservableMapList<TKey, TValue>, key: TKey): TValue?
	assert(key ~= nil, "Bad key")

	local observableList = self:GetListForKey(key)
	if not observableList then
		return nil
	end

	return observableList:Get(1)
end

--[=[
	Gets the item for the given key at the index

	```
	mapList:Push("fruits", "apple")
	mapList:Push("fruits", "orange")
	mapList:Push("fruits", "banana")

	-- Print the last item
	print(mapList:GetItemForKeyAtIndex("fruits", -1)) ==> banana
	```

	@param key TKey
	@param index number
	@return TValue?
]=]
function ObservableMapList.GetItemForKeyAtIndex<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>,
	key: TKey,
	index: number
): TValue?
	assert(key ~= nil, "Bad key")
	assert(type(index) == "number", "Bad index")

	local observableList = self:GetListForKey(key)
	if not observableList then
		return nil
	end

	return observableList:Get(index)
end

--[=[
	Gets how many lists exist

	@return number
]=]
function ObservableMapList.GetListCount<TKey, TValue>(self: ObservableMapList<TKey, TValue>): number
	return self._observableMapOfLists:GetCount()
end

ObservableMapList.__len = ObservableMapList.GetListCount

--[=[
	Observes how many lists exist

	@return Observable<number>
]=]
function ObservableMapList.ObserveListCount<TKey, TValue>(self: ObservableMapList<TKey, TValue>): Observable.Observable<number>
	return self._observableMapOfLists:ObserveCount()
end

--[=[
	Gets the current value at the list index

	@param key TKey
	@param index number
	@return TValue?
]=]
function ObservableMapList.GetAtListIndex<TKey, TValue>(self: ObservableMapList<TKey, TValue>, key: TKey, index: number): TValue?
	assert(key ~= nil, "Bad key")
	assert(type(index) == "number", "Bad index")

	local list = self._observableMapOfLists:Get(key)
	if list then
		return list:Get(index)
	else
		return nil
	end
end

--[=[
	Observes the current value at the index

	@param key TKey
	@param index number
	@return Observable<TValue?>
]=]
function ObservableMapList.ObserveAtListIndex<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>,
	key: TKey,
	index: number
): Observable.Observable<TValue?>
	assert(key ~= nil, "Bad key")
	assert(type(index) == "number", "Bad index")

	return self._observableMapOfLists:ObserveAtKey(key):Pipe({
		Rx.switchMap(function(list): any
			if list then
				return list:ObserveAtIndex(index)
			else
				return Rx.of(nil)
			end
		end) :: any,
	}) :: any
end

--[=[
	Gets a list of all keys

	@return { TKey }
]=]
function ObservableMapList.GetKeyList<TKey, TValue>(self: ObservableMapList<TKey, TValue>): { TKey }
	return self._observableMapOfLists:GetKeyList()
end

--[=[
	Observes the list of all keys.
	@return Observable<{ TKey }>
]=]
function ObservableMapList.ObserveKeyList<TKey, TValue>(self: ObservableMapList<TKey, TValue>): Observable.Observable<{ TKey }>
	return self._observableMapOfLists:ObserveKeyList()
end

--[=[
	Observes all keys in the map
	@return Observable<Brio<TKey>>
]=]
function ObservableMapList.ObserveKeysBrio<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>
): Observable.Observable<Brio.Brio<TKey>>
	return self._observableMapOfLists:ObserveKeysBrio()
end

--[=[
	Observes the current value at the index

	@param key TKey
	@param index number
	@return Observable<Brio<TValue>>
]=]
function ObservableMapList.ObserveAtListIndexBrio<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>,
	key: TKey,
	index: number
): Observable.Observable<Brio.Brio<TValue>>
	assert(key ~= nil, "Bad key")
	assert(type(index) == "number", "Bad index")

	return self._observableMapOfLists:ObserveAtKeyBrio(key):Pipe({
		RxBrioUtils.switchMapBrio(function(list)
			return list:ObserveAtIndexBrio(index)
		end) :: any,
		RxBrioUtils.toBrio() :: any,
		RxBrioUtils.where(function(value)
			return value ~= nil
		end) :: any,
	}) :: any
end

--[=[
	Observes all items at the given key

	@param key TKey
	@return Observable<Brio<TValue>>
]=]
function ObservableMapList.ObserveItemsForKeyBrio<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>,
	key: TKey
): Observable.Observable<Brio.Brio<TValue>>
	assert(key ~= nil, "Bad key")

	return self._observableMapOfLists:ObserveAtKeyBrio(key):Pipe({
		RxBrioUtils.switchMapBrio(function(list): any
			if list then
				return list:ObserveItemsBrio()
			else
				return Rx.EMPTY
			end
		end) :: any,
	}) :: any
end

--[=[
	Gets a list for a given key.

	@param key TKey
	@return { TValue }
]=]
function ObservableMapList.GetListFromKey<TKey, TValue>(self: ObservableMapList<TKey, TValue>, key: TKey): { TValue }
	assert(key ~= nil, "Bad key")

	local observableList = self:GetListForKey(key)
	if not observableList then
		return {}
	end

	return observableList:GetList()
end

--[=[
	Gets the observable list for the given key
	@param key TKey
	@return ObservableList<TValue>
]=]
function ObservableMapList.GetListForKey<TKey, TValue>(self: ObservableMapList<TKey, TValue>, key: TKey): any
	assert(key ~= nil, "Bad key")

	return self._observableMapOfLists:Get(key)
end

--[=[
	Gets a list of all of the entries at the given index, if it exists

	@param index number
	@return { TValue}
]=]
function ObservableMapList.GetListOfValuesAtListIndex<TKey, TValue>(self: ObservableMapList<TKey, TValue>, index: number): { TValue }
	assert(type(index) == "number", "Bad index")

	local list = table.create(self._observableMapOfLists:GetCount())

	for _, observableList in self._observableMapOfLists:GetValueList() do
		local value = observableList:Get(index)
		if value ~= nil then
			table.insert(list, value)
		end
	end

	return list
end

--[=[
	Observes the observable list for the given key

	@param key TKey
	@return Observable<ObservableList<TValue>>
]=]
function ObservableMapList.ObserveList<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>,
	key: TKey
): Observable.Observable<ObservableList<TValue>>
	assert(key ~= nil, "Bad key")

	return self._observableMapOfLists:ObserveAtKey(key)
end

--[=[
	Observes the observable list for the given key

	@param key TKey
	@return Observable<Brio<ObservableList<TValue>>>
]=]
function ObservableMapList.ObserveListBrio<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>,
	key: TKey
): Observable.Observable<Brio.Brio<ObservableList<TValue>>>
	assert(key ~= nil, "Bad key")

	return self._observableMapOfLists:ObserveAtKeyBrio(key)
end

--[=[
	Observes all observable lists in the map.

	@return Observable<Brio<ObservableList<TValue>>>
]=]
function ObservableMapList.ObserveListsBrio<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>
): Observable.Observable<Brio.Brio<ObservableList<TValue>>>
	return self._observableMapOfLists:ObserveValuesBrio()
end

--[=[
	Observes the number of entries for the given key

	@param key TKey
	@return Observable<number>
]=]
function ObservableMapList.ObserveCountForKey<TKey, TValue>(
	self: ObservableMapList<TKey, TValue>,
	key: TKey
): Observable.Observable<number>
	assert(key ~= nil, "Bad key")

	return self:ObserveListBrio(key):Pipe({
		RxBrioUtils.switchMapBrio(function(observableList)
			return observableList:ObserveCount()
		end) :: any,
		RxBrioUtils.emitOnDeath(0) :: any,
	}) :: any
end

function ObservableMapList._addToList<TKey, TValue>(self: ObservableMapList<TKey, TValue>, key: TKey, entry: TValue): () -> ()
	local list = self:_getOrCreateList(key)
	return list:Add(entry)
end

function ObservableMapList._getOrCreateList<TKey, TValue>(self: ObservableMapList<TKey, TValue>, key: TKey): ObservableList<TValue>
	local existing = self._observableMapOfLists:Get(key)
	if existing then
		return existing
	end

	local maid = Maid.new()
	local list = maid:Add(ObservableList.new())

	maid:GiveTask(list.CountChanged:Connect(function(count)
		if count <= 0 then
			self._maid[list] = nil
		end
	end))

	maid:GiveTask(self._observableMapOfLists:Set(key, list))
	self._maid[list] = maid

	return list
end

--[=[
	Cleans up the ObservableMapList and sets the metatable to nil.
]=]
function ObservableMapList.Destroy<TKey, TValue>(self: ObservableMapList<TKey, TValue>)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return ObservableMapList
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="156">
                <Properties>
                  <string name="Name">ObservableMapList.spec</string>
                  <string name="Source"><![CDATA[--[[
	@class ObservableMapList.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local ObservableMapList = require("ObservableMapList")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("ObservableMapList.new()", function()
	local observableMapList = ObservableMapList.new()

	it("should return nil for unset values", function()
		expect(observableMapList:GetAtListIndex("dragon", 1)).toEqual(nil)
	end)

	it("should allow additions", function()
		observableMapList:Push("hello", "dragon")
		expect(observableMapList:GetAtListIndex("hello", 1)).toEqual("dragon")
		expect(observableMapList:GetAtListIndex("hello", -1)).toEqual("dragon")
		expect(observableMapList:GetAtListIndex("fire", 1)).toEqual(nil)
	end)
end)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="157">
                <Properties>
                  <string name="Name">ObservableMapSet</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Holds a map of sets. That is, for a given key, a set of all valid entries. This is great
	for looking up something that may have duplicate keys, like configurations or other things.

	@class ObservableMapSet
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableMap = require("ObservableMap")
local ObservableSet = require("ObservableSet")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local Signal = require("Signal")
local Table = require("Table")

local ObservableMapSet = {}
ObservableMapSet.ClassName = "ObservableMapSet"
ObservableMapSet.__index = ObservableMapSet

export type ObservableMapSet<TKey, TValue> = typeof(setmetatable(
	{} :: {
		_observableMapOfSets: any, -- ObservableMap.ObservableMap<TKey, ObservableSet.ObservableSet<TValue>>,
		_maid: Maid.Maid,
		SetAdded: Signal.Signal<TKey>,
		SetRemoved: Signal.Signal<TKey>,
		CountChanged: Signal.Signal<number>,
	},
	{} :: typeof({ __index = ObservableMapSet })
))

--[=[
	Constructs a new ObservableMapSet
	@return ObservableMapSet<TKey, TValue>
]=]
function ObservableMapSet.new<TKey, TValue>(): ObservableMapSet<TKey, TValue>
	local self = setmetatable({} :: any, ObservableMapSet)

	self._maid = Maid.new()
	self._observableMapOfSets = self._maid:Add(ObservableMap.new())

	--[=[
	Fires when an item is added
	@readonly
	@prop SetAdded Signal<TKey>
	@within ObservableMapSet
]=]
	self.SetAdded = assert(self._observableMapOfSets.KeyAdded, "Bad KeyAdded") -- :Fire(key, set)

	--[=[
	Fires when an item is removed
	@readonly
	@prop SetRemoved Signal<TKey>
	@within ObservableMapSet
]=]
	self.SetRemoved = assert(self._observableMapOfSets.KeyRemoved, "Bad KeyRemoved") -- :Fire(key)

	--[=[
	Fires when the count changes.
	@prop CountChanged RBXScriptSignal
	@within ObservableMap
]=]
	self.CountChanged = assert(self._observableMapOfSets.CountChanged, "Bad CountChanged")

	return self
end

--[=[
	Adds an entry with a dynamic key. This is great for caching things
	that need to be looked up by key.

	:::tip
	If `observeKey` emits nil then the value will be excluded from the map.
	:::

	@param entry TValue
	@param observeKey Observable<TKey> | TKey
	@return MaidTask -- Cleanup object that will remove the entry
]=]

function ObservableMapSet.Push<TKey, TValue>(
	self: ObservableMapSet<TKey, TValue>,
	observeKey: Observable.Observable<TKey> | TKey,
	entry: TValue
): Maid.Maid
	assert(observeKey ~= nil, "Bad observeKey")
	assert(entry ~= nil, "Bad entry")

	local maid = Maid.new()

	if Observable.isObservable(observeKey) then
		maid:GiveTask((observeKey :: any):Subscribe(function(key)
			maid._currentAddValue = nil

			if key ~= nil then
				maid._currentAddValue = self:_addToSet(key, entry)
			end
		end))
	else
		maid:GiveTask(self:_addToSet(observeKey :: any, entry))
	end

	-- Ensure self-cleanup when map cleans up
	self._maid[maid] = maid
	maid:GiveTask(function()
		self._maid[maid] = nil
	end)

	return maid
end

--[=[
	Adds an entry with a dynamic key. This is great for caching things
	that need to be looked up by key.

	This code is legacy code since our argument order isn't intuitive

	:::tip
	If `observeKey` emits nil then the value will be excluded from the map.
	:::

	@param entry TValue
	@param observeKey Observable<TKey> | TKey
	@return MaidTask -- Cleanup object that will remove the entry
]=]
function ObservableMapSet.Add<TKey, TValue>(
	self: ObservableMapSet<TKey, TValue>,
	entry: TValue,
	observeKey: Observable.Observable<TKey> | TKey
): Maid.Maid
	assert(Observable.isObservable(observeKey), "Bad observeKey")
	assert(entry ~= nil, "Bad entry")

	warn(
		string.format(
			"[ObservableMapSet.Add] - This API call will swap observable key order eventually. Use ObservableMapSet.Push for now to suppress this warning.\n%s",
			debug.traceback()
		)
	)

	return self:Push(observeKey, entry)
end

--[=[
	Gets a list of all keys.
	@return { TKey }
]=]
function ObservableMapSet.GetKeyList<TKey, TValue>(self: ObservableMapSet<TKey, TValue>): { TKey }
	return self._observableMapOfSets:GetKeyList()
end

--[=[
	Observes the list of all keys.
	@return Observable<{ TKey }>
]=]
function ObservableMapSet.ObserveKeyList<TKey, TValue>(self: ObservableMapSet<TKey, TValue>): Observable.Observable<{ TKey }>
	return self._observableMapOfSets:ObserveKeyList()
end

--[=[
	Observes all keys in the map
	@return Observable<Brio<TKey>>
]=]
function ObservableMapSet.ObserveKeysBrio<TKey, TValue>(self: ObservableMapSet<TKey, TValue>): Observable.Observable<Brio.Brio<TKey>>
	return self._observableMapOfSets:ObserveKeysBrio()
end

--[=[
	Gets how many sets exist
	@return number
]=]
function ObservableMapSet.GetSetCount<TKey, TValue>(self: ObservableMapSet<TKey, TValue>): number
	return self._observableMapOfSets:GetCount()
end

ObservableMapSet.__len = ObservableMapSet.GetSetCount

--[=[
	Observes how many sets exist
	@return Observable<number>
]=]
function ObservableMapSet.ObserveSetCount<TKey, TValue>(self: ObservableMapSet<TKey, TValue>): Observable.Observable<number>
	return self._observableMapOfSets:ObserveCount()
end

--[=[
	Observes all items for the given key
	@param key TKey
	@return Observable<Brio<TValue>>
]=]
function ObservableMapSet.ObserveItemsForKeyBrio<TKey, TValue>(
	self: ObservableMapSet<TKey, TValue>,
	key: TKey
): Observable.Observable<Brio.Brio<TValue>>
	assert(key ~= nil, "Bad key")

	return self._observableMapOfSets:ObserveAtKeyBrio(key):Pipe({
		RxBrioUtils.switchMapBrio(function(set)
			if set then
				return set:ObserveItemsBrio()
			else
				return Rx.EMPTY
			end
		end),
	})
end

--[=[
	Gets the first item for the given key
	@param key TKey
	@return TValue?
]=]
function ObservableMapSet.GetFirstItemForKey<TKey, TValue>(self: ObservableMapSet<TKey, TValue>, key: TKey): TValue?
	assert(key ~= nil, "Bad key")

	local observableSet: ObservableSet.ObservableSet<TValue> = self:GetObservableSetForKey(key) :: any
	if not observableSet then
		return nil
	end

	return observableSet:GetFirstItem()
end

--[=[
	Gets a list for a given key
	@param key TKey
	@return { TValue }
]=]
function ObservableMapSet.GetListForKey<TKey, TValue>(self: ObservableMapSet<TKey, TValue>, key: TKey): Table.Array<TValue>
	assert(key ~= nil, "Bad key")

	local observableSet = self:GetObservableSetForKey(key)
	if not observableSet then
		return {}
	end

	return observableSet:GetList()
end

--[=[
	Gets the observable set for the given key
	@param key TKey
	@return ObservableSet<TValue>
]=]
function ObservableMapSet.GetObservableSetForKey<TKey, TValue>(
	self: ObservableMapSet<TKey, TValue>,
	key: TKey
): ObservableSet.ObservableSet<TValue>
	assert(key ~= nil, "Bad key")

	return self._observableMapOfSets:Get(key)
end

--[=[
	Observes the observable set for the given key

	@param key TKey
	@return Observable<Brio<ObservableSet<TValue>>>
]=]
function ObservableMapSet.ObserveSetBrio<TKey, TValue>(
	self: ObservableMapSet<TKey, TValue>,
	key: TKey
): Observable.Observable<
	Brio.Brio<ObservableSet.ObservableSet<TValue>>
>
	assert(key ~= nil, "Bad key")

	return self._observableMapOfSets:ObserveAtKeyBrio(key)
end

--[=[
	Observes the number of entries for the given key

	@param key TKey
	@return Observable<number>
]=]
function ObservableMapSet.ObserveCountForKey<TKey, TValue>(
	self: ObservableMapSet<TKey, TValue>,
	key: TKey
): Observable.Observable<number>
	assert((key :: any) ~= nil, "Bad key")

	return self:ObserveSetBrio(key):Pipe({
		RxBrioUtils.switchMapBrio(function(observableSet)
			return observableSet:ObserveCount()
		end) :: any,
		RxBrioUtils.emitOnDeath(0) :: any,
	} :: any) :: any
end

function ObservableMapSet._addToSet<TKey, TValue>(self: ObservableMapSet<TKey, TValue>, key: TKey, entry: TValue): () -> ()
	local set = self:_getOrCreateSet(key)
	return set:Add(entry)
end

function ObservableMapSet._getOrCreateSet<TKey, TValue>(
	self: ObservableMapSet<TKey, TValue>,
	key: TKey
): ObservableSet.ObservableSet<TValue>
	local existing = self._observableMapOfSets:Get(key)
	if existing then
		return existing
	end

	local maid = Maid.new()
	local set = maid:Add(ObservableSet.new())

	maid:GiveTask(set.CountChanged:Connect(function(count)
		if count <= 0 then
			self._maid[set] = nil
		end
	end))

	maid:GiveTask(self._observableMapOfSets:Set(key, set))
	self._maid[set] = maid

	return set
end

--[=[
	Cleans up the ObservableMapSet and sets the metatable to nil.
]=]
function ObservableMapSet.Destroy<TKey, TValue>(self: ObservableMapSet<TKey, TValue>)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return ObservableMapSet
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="158">
                <Properties>
                  <string name="Name">ObservableSet</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	A list that can be observed for blend and other components
	@class ObservableSet
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local DuckTypeUtils = require("DuckTypeUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableSubscriptionTable = require("ObservableSubscriptionTable")
local Set = require("Set")
local Signal = require("Signal")
local ValueObject = require("ValueObject")

local ObservableSet = {}
ObservableSet.ClassName = "ObservableSet"
ObservableSet.__index = ObservableSet

export type ObservableSet<T> = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_set: Set.Set<T>,
		_containsObservables: any,
		_countValue: ValueObject.ValueObject<number>,
		ItemAdded: Signal.Signal<T>,
		ItemRemoved: Signal.Signal<T>,
		CountChanged: Signal.Signal<number>,
	},
	{} :: typeof({ __index = ObservableSet })
))

--[=[
	Constructs a new ObservableSet
	@return ObservableSet<T>
]=]
function ObservableSet.new<T>(): ObservableSet<T>
	local self = setmetatable({} :: any, ObservableSet)

	self._maid = Maid.new()
	self._set = {}

	self._containsObservables = self._maid:Add(ObservableSubscriptionTable.new())
	self._countValue = self._maid:Add(ValueObject.new(0, "number"))

	--[=[
	Fires when an item is added
	@readonly
	@prop ItemAdded Signal<T>
	@within ObservableSet
]=]
	self.ItemAdded = self._maid:Add(Signal.new())

	--[=[
	Fires when an item is removed.
	@readonly
	@prop ItemRemoved Signal<T>
	@within ObservableSet
]=]
	self.ItemRemoved = self._maid:Add(Signal.new())

	--[=[
	Fires when the count changes.
	@prop CountChanged RBXScriptSignal
	@within ObservableSet
]=]
	self.CountChanged = self._countValue.Changed

	return self
end

--[=[
	Returns whether the value is an observable set
	@param value any
	@return boolean
]=]
function ObservableSet.isObservableSet(value: any): boolean
	return DuckTypeUtils.isImplementation(ObservableSet, value)
end

--[=[
	Allows iteration over the observable set

	@return (T) -> ((T, nextIndex: any) -> ...any, T?)
]=]
function ObservableSet.__iter<T>(self: ObservableSet<T>): typeof(pairs({} :: Set.Set<T>))
	return pairs(self._set)
end

--[=[
	Observes all items in the set
	@return Observable<Brio<T>>
]=]
function ObservableSet.ObserveItemsBrio<T>(self: ObservableSet<T>): Observable.Observable<Brio.Brio<T>>
	return Observable.new(function(sub)
		if not self.Destroy then
			return sub:Fail("ObservableSet is already cleaned up")
		end

		local maid = Maid.new()
		local brios: Set.Map<T, Brio.Brio<T>> = {}

		local function handleItem(item: T)
			if brios[item] then
				-- Happens when we're re-entrance
				return
			end

			local brio = Brio.new(item)
			brios[item] = brio :: any
			sub:Fire(brio)
		end

		maid:GiveTask(self.ItemAdded:Connect(handleItem))
		maid:GiveTask(self.ItemRemoved:Connect(function(item: T)
			if brios[item] then
				local brio = brios[item]
				brios[item] = nil

				brio:Destroy()
			end
		end))

		for item, _ in self._set do
			handleItem(item)
		end

		self._maid[sub] = maid
		maid:GiveTask(function()
			for _, brio: any in brios do
				brio:Destroy()
			end
			self._maid[sub] = nil
			sub:Complete()
		end)

		return maid
	end) :: any
end

--[=[
	Observes the current value at a given index. This can be useful for observing
	the first entry, or matching stuff up to a given slot.

	@param item T
	@return Observable<boolean>
]=]
function ObservableSet.ObserveContains<T>(self: ObservableSet<T>, item: T): Observable.Observable<boolean>
	assert(item ~= nil, "Bad item")

	return Observable.new(function(sub)
		if not self.Destroy then
			return sub:Fail("ObservableSet is already cleaned up")
		end

		local maid = Maid.new()

		if self._set[item] then
			sub:Fire(true)
		else
			sub:Fire(false)
		end

		maid:GiveTask(self._containsObservables:Observe(item):Subscribe(function(doesContain)
			sub:Fire(doesContain)
		end))

		self._maid[sub] = maid
		maid:GiveTask(function()
			self._maid[sub] = nil
			sub:Complete()
		end)

		return maid
	end) :: any
end

--[=[
	Returns whether the set contains the item
	@param item T
	@return boolean
]=]
function ObservableSet.Contains<T>(self: ObservableSet<T>, item: T): boolean
	assert(item ~= nil, "Bad item")

	return self._set[item] == true
end

--[=[
	Gets the count of items in the set
	@return number
]=]
function ObservableSet.GetCount<T>(self: ObservableSet<T>): number
	return self._countValue.Value or 0
end

ObservableSet.__len = ObservableSet.GetCount

--[=[
	Observes the count of the set
	@return Observable<number>
]=]
function ObservableSet.ObserveCount<T>(self: ObservableSet<T>): Observable.Observable<number>
	return self._countValue:Observe()
end

--[=[
	Adds the item to the set if it does not exists.
	@param item T
	@return callback -- Call to remove
]=]
function ObservableSet.Add<T>(self: ObservableSet<T>, item: T): () -> ()
	assert(item ~= nil, "Bad item")

	if not self._set[item] then
		self._set[item] = true

		-- Fire events
		self._countValue.Value = self._countValue.Value + 1
		self.ItemAdded:Fire(item)
		self._containsObservables:Fire(item, true)
	end

	return function()
		if self.Destroy then
			self:Remove(item)
		end
	end
end

--[=[
	Removes the item from the set if it exists.
	@param item T
	@return True if removed
]=]
function ObservableSet.Remove<T>(self: ObservableSet<T>, item: T): boolean
	assert(item ~= nil, "Bad item")

	if self._set[item] then
		self._set[item] = nil

		-- Fire in reverse order
		self._containsObservables:Fire(item, false)
		if self.Destroy then
			self.ItemRemoved:Fire(item)
		end
		self._countValue.Value = self._countValue.Value - 1
		return true
	else
		return false
	end
end

--[=[
	Gets an arbitrary item in the set (not guaranteed to be ordered)
	@return T
]=]
function ObservableSet.GetFirstItem<T>(self: ObservableSet<T>): T?
	local value = next(self._set)
	return value
end

--[=[
	Gets a list of all entries.
	@return { T }
]=]
function ObservableSet.GetList<T>(self: ObservableSet<T>): { T }
	local list = table.create(self._countValue.Value)
	for item, _ in self._set do
		table.insert(list, item)
	end
	return list
end

--[=[
	Gets a copy of the set
	@return { [T]: true }
]=]
function ObservableSet.GetSetCopy<T>(self: ObservableSet<T>): Set.Set<T>
	return table.clone(self._set)
end

--[=[
	Gets the raw set. Do not modify this set.
	@return { [T]: true }
]=]
function ObservableSet.GetRawSet<T>(self: ObservableSet<T>): Set.Set<T>
	return self._set
end

--[=[
	Cleans up the ObservableSet and sets the metatable to nil.
]=]
function ObservableSet.Destroy<T>(self: ObservableSet<T>)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return ObservableSet
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="159">
                <Properties>
                  <string name="Name">SortedList</string>
                </Properties>
                <Item class="ModuleScript" referent="160">
                  <Properties>
                    <string name="Name">ObservableSortedList</string>
                    <string name="Source"><![CDATA[--strict
--[=[
	A list that can be observed for blend and other components and maintains sorting order.

	This allows you to observe both an index, observe a value at an index, and more.

	This class is a red-black binary sorted tree. Unlike previous iterations of this class, we can add
	values in log(n) time, and remove in log(n) time, and it uses less memory.

	Previously we'd use O(n^2) processing time when constructing this class.

	We reuse the node itself as the indexing key.

	This class always prefers to add equivalent elements to the end of the list if they're not in the list.
	Otherwise it prefers minimal movement.

	@class ObservableSortedList
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local DuckTypeUtils = require("DuckTypeUtils")
local ListIndexUtils = require("ListIndexUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableSubscriptionTable = require("ObservableSubscriptionTable")
local Rx = require("Rx")
local Signal = require("Signal")
local SortFunctionUtils = require("SortFunctionUtils")
local SortedNode = require("SortedNode")
local SortedNodeValue = require("SortedNodeValue")
local ValueObject = require("ValueObject")

local ObservableSortedList = {}
ObservableSortedList.ClassName = "ObservableSortedList"
ObservableSortedList.__index = ObservableSortedList

export type CompareFunction<T> = (T, T) -> number

export type ObservableSortedList<T> = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_root: SortedNode.SortedNode<T>?,
		_nodesAdded: { [SortedNode.SortedNode<T>]: boolean },
		_nodesRemoved: { [SortedNode.SortedNode<T>]: boolean },
		_lowestIndexChanged: number?,
		_compare: CompareFunction<T>,
		_countValue: ValueObject.ValueObject<number>,
		_indexObservers: any,
		_nodeIndexObservables: any,
		_mainObservables: any,
		ItemAdded: Signal.Signal<T, number, SortedNode.SortedNode<T>>,
		ItemRemoved: Signal.Signal<T, SortedNode.SortedNode<T>>,
		OrderChanged: Signal.Signal<()>,
		CountChanged: Signal.Signal<number>,
	},
	{} :: typeof({ __index = ObservableSortedList })
))

--[=[
	Constructs a new ObservableSortedList
	@param isReversed boolean
	@param compare function
	@return ObservableSortedList<T>
]=]
function ObservableSortedList.new<T>(isReversed: boolean?, compare: CompareFunction<T>?): ObservableSortedList<T>
	assert(type(isReversed) == "boolean" or isReversed == nil, "Bad isReversed")

	local self = setmetatable({} :: any, ObservableSortedList)

	self._maid = Maid.new()

	self._indexObservers = self._maid:Add(ObservableSubscriptionTable.new())
	self._nodeIndexObservables = self._maid:Add(ObservableSubscriptionTable.new())

	self._mainObservables = self._maid:Add(ObservableSubscriptionTable.new())

	self._nodesAdded = {}
	self._nodesRemoved = {}
	self._lowestIndexChanged = nil

	self._compare = if isReversed then SortFunctionUtils.reverse(compare) else compare

	self._countValue = self._maid:Add(ValueObject.new(0, "number"))

	--[=[
	Fires when an item is added

	@readonly
	@prop ItemAdded Signal<T, number, Symbol>
	@within ObservableSortedList
]=]
	self.ItemAdded = self._maid:Add(Signal.new())

	--[=[
	Fires when an item is removed.

	@readonly
	@prop ItemRemoved Signal<T, Symbol>
	@within ObservableSortedList
]=]
	self.ItemRemoved = self._maid:Add(Signal.new())

	--[=[
	Fires when the order could have changed

	@readonly
	@prop OrderChanged Signal
	@within ObservableSortedList
]=]
	self.OrderChanged = self._maid:Add(Signal.new())

	--[=[
	Fires when the count changes

	@readonly
	@prop CountChanged Signal<number>
	@within ObservableSortedList
]=]
	self.CountChanged = self._countValue.Changed

	return self
end

--[=[
	Returns whether the value is an observable list
	@param value any
	@return boolean
]=]
function ObservableSortedList.isObservableSortedList(value: any): boolean
	return DuckTypeUtils.isImplementation(ObservableSortedList, value)
end

--[=[
	Observes the list, allocating a new list in the process.

	@return Observable<{ T }>
]=]
function ObservableSortedList.Observe<T>(self: ObservableSortedList<T>): Observable.Observable<{ T }>
	return self._mainObservables:Observe("list"):Pipe({
		Rx.start(function()
			return self:GetList()
		end),
	})
end

--[=[
	Allows iteration over the observable map

	@return (T) -> ((T, nextIndex: any) -> ...any, T?)
]=]
function ObservableSortedList.__iter<T>(self: ObservableSortedList<T>): SortFunctionUtils.WrappedIterator<number, T>
	if self._root then
		return self._root:IterateData()
	else
		return SortFunctionUtils.emptyIterator
	end
end

--[=[
	Iterates over an index range

	@param start number
	@param finish number
	@return (T) -> ((T, nextIndex: any) -> ...any, T?)
]=]
function ObservableSortedList.IterateRange<T>(
	self: ObservableSortedList<T>,
	start: number,
	finish: number
): SortFunctionUtils.WrappedIterator<number, T>
	return coroutine.wrap(function()
		for index: number, node in self:_iterateNodesRange(start, finish) do
			coroutine.yield(index, node.data)
		end
	end) :: any
end

function ObservableSortedList._iterateNodes<T>(
	self: ObservableSortedList<T>
): SortFunctionUtils.WrappedIterator<number, SortedNode.SortedNode<T>>
	if self._root then
		return self._root:IterateNodes()
	else
		return SortFunctionUtils.emptyIterator
	end
end

function ObservableSortedList._iterateNodesRange<T>(
	self: ObservableSortedList<T>,
	start: number,
	finish: number?
): SortFunctionUtils.WrappedIterator<number, SortedNode.SortedNode<T>>
	if self._root then
		return self._root:IterateNodesRange(start, finish)
	else
		return SortFunctionUtils.emptyIterator
	end
end

function ObservableSortedList._containsNode<T>(self: ObservableSortedList<T>, node: SortedNode.SortedNode<T>): boolean
	assert(SortedNode.isSortedNode(node), "Bad node")

	if self._root then
		return self._root:ContainsNode(node)
	else
		return false
	end
end

function ObservableSortedList._findNodeForDataLinearSearchSlow<T>(
	self: ObservableSortedList<T>,
	data: T
): SortedNode.SortedNode<T>?
	if self._root then
		return self._root:FindFirstNodeForData(data)
	else
		return nil
	end
end

function ObservableSortedList._findNodeAtIndex<T>(self: ObservableSortedList<T>, index: number): SortedNode.SortedNode<T>?
	assert(type(index) == "number", "Bad index")

	if self._root then
		return self._root:FindNodeAtIndex(index)
	else
		return nil
	end
end

function ObservableSortedList._findNodeIndex<T>(self: ObservableSortedList<T>, node: SortedNode.SortedNode<T>): number?
	assert(SortedNode.isSortedNode(node), "Bad node")

	if self._root then
		return self._root:FindNodeIndex(node)
	else
		return nil
	end
end

--[=[
	Gets the first node for a given symbol

	@param content T
	@return Symbol
]=]
function ObservableSortedList.FindFirstKey<T>(self: ObservableSortedList<T>, content: T): SortedNode.SortedNode<T>?
	return self:_findNodeForDataLinearSearchSlow(content)
end

function ObservableSortedList.PrintDebug<T>(self: ObservableSortedList<T>)
	print(self._root)
end

--[=[
	Returns true if the value exists

	@param content T
	@return boolean
]=]
function ObservableSortedList.Contains<T>(self: ObservableSortedList<T>, content): boolean
	assert(content ~= nil, "Bad content")

	-- TODO: Speed up
	return self:_findNodeForDataLinearSearchSlow(content) ~= nil
end

--[=[
	Observes all items in the list
	@return Observable<Brio<T, Symbol>>
]=]
function ObservableSortedList.ObserveItemsBrio<T>(
	self: ObservableSortedList<T>
): Observable.Observable<Brio.Brio<T, SortedNode.SortedNode<T>>>
	return Observable.new(function(sub)
		local maid = Maid.new()

		-- TODO: Optimize this so we don't have to make so many brios and connect
		-- to so many events

		local function handleItem(data: T, _index, node)
			local brio = Brio.new(data, node)
			maid[node] = brio
			sub:Fire(brio)
		end

		-- NOTE: This can modify the list...?
		for index, node in self:_iterateNodes() do
			handleItem(node.data, index, node)
		end

		maid:GiveTask(self.ItemAdded:Connect(handleItem))
		maid:GiveTask(self.ItemRemoved:Connect(function(_item, node)
			maid[node] = nil
		end))

		-- TODO: Prevent this stuff from happening too
		self._maid[sub] = maid
		maid:GiveTask(function()
			self._maid[sub] = nil
			sub:Complete()
		end)

		return maid
	end) :: any
end

--[=[
	Observes the index as it changes, until the entry at the existing
	index is removed.

	@param indexToObserve number
	@return Observable<number>
]=]
function ObservableSortedList.ObserveIndex<T>(
	self: ObservableSortedList<T>,
	indexToObserve: number
): Observable.Observable<number>
	assert(type(indexToObserve) == "number", "Bad indexToObserve")

	local node = self:_findNodeAtIndex(indexToObserve)
	if not node then
		error(
			string.format(
				"[ObservableSortedList.ObserveIndex] - No entry at index %d, cannot observe changes",
				indexToObserve
			)
		)
	end

	return self:ObserveIndexByKey(node)
end

--[=[
	Observes the current value at a given index. This can be useful for observing
	the first entry, or matching stuff up to a given slot.

	@param indexToObserve number
	@return Observable<(T, Key)>
]=]
function ObservableSortedList.ObserveAtIndex<T>(
	self: ObservableSortedList<T>,
	indexToObserve: number
): Observable.Observable<T, SortedNode.SortedNode<T>>
	assert(type(indexToObserve) == "number", "Bad indexToObserve")

	return self._indexObservers:Observe(indexToObserve, function(sub)
		local node = self:_findNodeAtIndex(indexToObserve)
		if node then
			sub:Fire(node.data, node)
		else
			sub:Fire(nil, nil)
		end
	end) :: any
end

--[=[
	Observes the index as it changes, until the entry at the existing
	node is removed.

	@param node SortedNode
	@return Observable<number>
]=]
function ObservableSortedList.ObserveIndexByKey<T>(
	self: ObservableSortedList<T>,
	node: SortedNode.SortedNode<T>
): Observable.Observable<number>
	assert(SortedNode.isSortedNode(node), "Bad node")

	return self._nodeIndexObservables:Observe(node, function(sub)
		local currentIndex = self:_findNodeIndex(node)
		if currentIndex then
			sub:Fire(currentIndex)
		end
	end) :: any
end

--[=[
	Gets the current index from the node

	@param node SortedNode
	@return number
]=]
function ObservableSortedList.GetIndexByKey<T>(self: ObservableSortedList<T>, node: SortedNode.SortedNode<T>): number?
	assert(SortedNode.isSortedNode(node), "Bad node")

	return self:_findNodeIndex(node)
end

--[=[
	Gets the count of items in the list
	@return number
]=]
function ObservableSortedList.GetCount<T>(self: ObservableSortedList<T>): number
	return self._countValue.Value or 0
end

ObservableSortedList.__len = ObservableSortedList.GetCount

--[=[
	Gets a list of all entries.
	@return { T }
]=]
function ObservableSortedList.GetList<T>(self: ObservableSortedList<T>): { T }
	local list = table.create(self._countValue.Value)
	for index, data in self:__iter() do
		list[index] = data
	end
	return table.freeze(list)
end

--[=[
	Observes the count of the list
	@return Observable<number>
]=]
function ObservableSortedList.ObserveCount<T>(self: ObservableSortedList<T>): Observable.Observable<number>
	return self._countValue:Observe()
end

--[=[
	Adds the item to the list at the specified index
	@param data T
	@param observeValue Observable<Comparable> | Comparable
	@return callback -- Call to remove
]=]
function ObservableSortedList.Add<T>(
	self: ObservableSortedList<T>,
	data: T,
	observeValue: Observable.Observable<number> | number
): () -> ()
	assert(data ~= nil, "Bad data")
	assert(Observable.isObservable(observeValue) or observeValue ~= nil, "Bad observeValue")

	local node = SortedNode.new(data)

	-- TODO: Store maid in node to prevent lookup of node -> index
	local maid = Maid.new()

	if Observable.isObservable(observeValue) then
		maid:GiveTask((observeValue :: any):Subscribe(function(sortValue: number)
			self:_assignSortValue(node, sortValue)
		end))
	elseif observeValue ~= nil then
		self:_assignSortValue(node, observeValue :: number)
	else
		error("Bad observeValue")
	end

	maid:GiveTask(function()
		-- TODO: Avoid cleaning up all these nodes when global maid cleans up
		self:_assignSortValue(node, nil)
		self._nodeIndexObservables:Complete(node)
	end)

	self._maid[node] = maid

	return function()
		self._maid[node] = nil
	end
end

function ObservableSortedList._assignSortValue<T>(
	self: ObservableSortedList<T>,
	node: SortedNode.SortedNode<T>,
	value: number?
): ()
	if SortedNodeValue.isSortedNodeValue(node.value) then
		if (node.value :: any):GetValue() == value then
			return
		end
	elseif node.value == value then
		return
	end

	if value == nil then
		if self._root and self._root:ContainsNode(node) then
			if self._nodesAdded[node] then
				self._nodesAdded[node] = nil
			else
				self._nodesRemoved[node] = true
			end

			self:_applyLowestIndexChanged(node:GetIndex())
			self:_removeNode(node)
			node.value = nil
			self:_queueFireEvents()
		else
			node.value = nil
		end

		return
	end

	if self._compare ~= nil then
		value = SortedNodeValue.new(value, self._compare) :: any
	end

	-- our value changing didn't change anything
	if not node:NeedsToMove(self._root, value) then
		node.value = value
		return
	end

	self._nodesRemoved[node] = nil

	if self._root and self._root:ContainsNode(node) then
		self:_applyLowestIndexChanged(node:GetIndex())
		self:_removeNode(node)
	else
		self._nodesAdded[node] = true
	end

	node.value = value

	self:_insertNode(node)
	self:_applyLowestIndexChanged(node:GetIndex())
	self:_queueFireEvents()
end

function ObservableSortedList._applyLowestIndexChanged<T>(self: ObservableSortedList<T>, index: number)
	if self._lowestIndexChanged == nil then
		self._lowestIndexChanged = index
		return
	end

	if index < self._lowestIndexChanged then
		self._lowestIndexChanged = index
	end
end

function ObservableSortedList._queueFireEvents<T>(self: ObservableSortedList<T>)
	if self._maid._fireEvents then
		return
	end

	self._maid._fireEvents = task.defer(function()
		self._maid._fireEvents = nil
		self:_fireEvents()
	end)
end

function ObservableSortedList._fireEvents<T>(self: ObservableSortedList<T>)
	-- print(self._root)

	local lowestIndexChanged = self._lowestIndexChanged
	self._lowestIndexChanged = nil

	local nodesAdded = self._nodesAdded
	self._nodesAdded = {}

	local nodesRemoved = self._nodesRemoved
	self._nodesRemoved = {}

	local lastCount = self._countValue.Value
	local newCount = if self._root then self._root.descendantCount else 0

	-- Fire count changed first
	self._countValue.Value = newCount

	if not self.Destroy then
		return
	end

	-- TODO: Prevent Rx.of(itemAdded) stuff in our UI
	for node in nodesAdded do
		-- TODO: Prevent query slow here...?
		local index = node:GetIndex()
		self.ItemAdded:Fire(node.data, index, node)
	end

	if not self.Destroy then
		return
	end

	for node in nodesRemoved do
		self.ItemRemoved:Fire(node.data, node)
	end

	if not self.Destroy then
		return
	end

	self.OrderChanged:Fire()

	if not self.Destroy then
		return
	end

	do
		local descendantCount = self._root and self._root.descendantCount or 0
		for index, node in self:_iterateNodesRange(lowestIndexChanged) do
			-- TODO: Handle negative observations to avoid refiring upon insertion
			-- TODO: Handle our state changing while we're firing
			-- TODO: Avoid looping over nodes if we don't need to (track observations in node itself?)
			local negative = ListIndexUtils.toNegativeIndex(descendantCount, index)
			self._nodeIndexObservables:Fire(node, index)
			self._indexObservers:Fire(index, node.data, node)
			self._indexObservers:Fire(negative, node.data, node)
		end

		for index = newCount + 1, lastCount do
			self._indexObservers:Fire(index, nil, nil)
		end

		-- TODO: Fire negatives beyond range
	end

	if not self.Destroy then
		return
	end

	if self._mainObservables:HasSubscriptions("list") then
		-- TODO: Reuse list
		local list = self:GetList()
		self._mainObservables:Fire("list", list)
	end
end

function ObservableSortedList._insertNode<T>(self: ObservableSortedList<T>, node: SortedNode.SortedNode<T>)
	assert(SortedNode.isSortedNode(node), "Bad SortedNode")

	if self._root == nil then
		node:MarkBlack()
		self._root = node
	else
		self._root = self._root:InsertNode(node)
	end
end

function ObservableSortedList._removeNode<T>(self: ObservableSortedList<T>, nodeToRemove: SortedNode.SortedNode<T>)
	assert(SortedNode.isSortedNode(nodeToRemove), "Bad SortedNode")

	if self._root ~= nil then
		self._root = self._root:RemoveNode(nodeToRemove)
	end
end

--[=[
	Gets the current item at the index, or nil if it is not defined.
	@param index number
	@return T?
]=]
function ObservableSortedList.Get<T>(self: ObservableSortedList<T>, index: number): T?
	assert(type(index) == "number", "Bad index")

	local node = self:_findNodeAtIndex(index)
	if not node then
		return nil
	end

	return node.data
end

--[=[
	Removes the item from the list if it exists.
	@param node SortedNode
	@return T
]=]
function ObservableSortedList.RemoveByKey<T>(self: ObservableSortedList<T>, node: SortedNode.SortedNode<T>)
	assert(SortedNode.isSortedNode(node), "Bad node")

	self._maid[node] = nil
end

--[=[
	Cleans up the ObservableSortedList and sets the metatable to nil.
]=]
function ObservableSortedList.Destroy<T>(self: ObservableSortedList<T>)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return ObservableSortedList
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="161">
                  <Properties>
                    <string name="Name">ObservableSortedList.spec</string>
                    <string name="Source"><![CDATA[--[[
	@class ObservableSortedList.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local ObservableSortedList = require("ObservableSortedList")
local Rx = require("Rx")
local StepUtils = require("StepUtils")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("ObservableSortedList.new()", function()
	local observableSortedList = ObservableSortedList.new()

	it("should return nil for unset values", function()
		expect(observableSortedList:Get(1)).toEqual(nil)
	end)

	it("should allow inserting an value", function()
		expect(observableSortedList:GetCount()).toEqual(0)

		observableSortedList:Add("b", Rx.of("b"))

		StepUtils.deferWait()

		expect(observableSortedList:Get(1)).toEqual("b")
		expect(observableSortedList:GetCount()).toEqual(1)
	end)

	it("should sort the items", function()
		expect(observableSortedList:GetCount()).toEqual(1)

		observableSortedList:Add("a", Rx.of("a"))

		StepUtils.deferWait()

		expect(observableSortedList:Get(1)).toEqual("a")
		expect(observableSortedList:Get(2)).toEqual("b")
		expect(observableSortedList:GetCount()).toEqual(2)
	end)

	it("should add in order if number is the same", function()
		observableSortedList = ObservableSortedList.new()
		observableSortedList:Add("a", Rx.of(0))
		observableSortedList:Add("b", Rx.of(0))
		observableSortedList:Add("c", Rx.of(0))

		StepUtils.deferWait()

		expect(observableSortedList:Get(1)).toEqual("a")
		expect(observableSortedList:Get(2)).toEqual("b")
		expect(observableSortedList:Get(3)).toEqual("c")
		expect(observableSortedList:GetCount()).toEqual(3)
	end)
end)
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="162">
                  <Properties>
                    <string name="Name">ObservableSortedList.story</string>
                    <string name="Source"><![CDATA[--[[
	@class observableSortedList.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Blend = require("Blend")
local Maid = require("Maid")
local ObservableSortedList = require("ObservableSortedList")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local ValueObject = require("ValueObject")

local ENTRIES = 10
local CHANGE_TO_NEGATIVE_INDEX = false

return function(target)
	local maid = Maid.new()

	local observableSortedList = maid:Add(ObservableSortedList.new())

	local random = Random.new(35)

	local values = {}
	for i = 1, ENTRIES do
		local scoreValue = maid:Add(ValueObject.new(0 or random:NextNumber(), "number"))

		local data = {
			originalIndex = i,
			scoreValue = scoreValue,
		}

		values[i] = data

		maid:GiveTask(task.delay(i * 0.05, function()
			maid:Add(observableSortedList:Add(data, scoreValue:Observe()))
		end))

		if CHANGE_TO_NEGATIVE_INDEX then
			maid:GiveTask(task.delay(ENTRIES * 0.05 + random:NextNumber() * 3, function()
				-- print("change", scoreValue.Value, " to", -1)
				scoreValue.Value = -i
			end))
		end
	end

	maid:GiveTask(observableSortedList.OrderChanged:Connect(function()
		local results = {}
		local inOrder = true
		local lastValue = nil
		for _, item in observableSortedList:GetList() do
			if lastValue then
				if item.scoreValue.Value < lastValue then
					inOrder = false
				end
			end
			lastValue = item.scoreValue.Value
			table.insert(results, string.format("%3d", item.scoreValue.Value))
		end

		if not inOrder then
			warn("BAD SORT ", table.concat(results, ", "))
		else
			print("-->", table.concat(results, ", "))
		end
	end))

	-- maid:GiveTask(task.delay(0.1, function()
	-- 	values[7].scoreValue.Value = -5
	-- end))

	maid:GiveTask(Blend.mount(target, {
		Blend.New "Frame" {
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,

			Blend.New "UIListLayout" {
				Padding = UDim.new(0, 5),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				VerticalAlignment = Enum.VerticalAlignment.Top,
			},

			Blend.New "UIPadding" {
				PaddingTop = UDim.new(0, 10),
				PaddingBottom = UDim.new(0, 10),
			},

			observableSortedList:ObserveItemsBrio():Pipe({
				RxBrioUtils.flatMapBrio(function(data, itemKey)
					local valid = ValueObject.new(false, "boolean")

					return Blend.New "Frame" {
						Size = UDim2.fromOffset(100, 30),
						BackgroundColor3 = Blend.Spring(
							Blend.Computed(valid, function(isValid)
								if isValid then
									return Color3.new(1, 1, 1)
								else
									return Color3.new(1, 0.5, 0.5)
								end
							end),
							5
						),
						LayoutOrder = observableSortedList:ObserveIndexByKey(itemKey),

						Blend.New "UICorner" {
							CornerRadius = UDim.new(0, 5),
						},

						Blend.New "TextLabel" {
							Name = "Score",
							Text = data.scoreValue:Observe():Pipe({
								Rx.map(tostring),
							}),
							Size = UDim2.fromScale(1, 1),
							BackgroundTransparency = 1,
							Position = UDim2.new(1, 10, 0.5, 0),
							AnchorPoint = Vector2.new(0, 0.5),
							TextColor3 = Color3.new(1, 1, 1),
							TextXAlignment = Enum.TextXAlignment.Left,
						},

						Blend.New "TextBox" {
							Name = "SetScore",
							Size = UDim2.fromScale(1, 1),
							Text = tostring(data.scoreValue.Value),
							BackgroundTransparency = 1,
							[Blend.OnChange "Text"] = function(newValue)
								if tonumber(newValue) then
									data.scoreValue.Value = tonumber(newValue)
									valid.Value = true
								else
									valid.Value = false
								end
							end,
						},

						Blend.New "TextLabel" {
							Name = "OriginalIndex",
							Text = data.originalIndex,
							Size = UDim2.fromScale(1, 1),
							BackgroundTransparency = 1,
							Position = UDim2.new(0, -10, 0.5, 0),
							AnchorPoint = Vector2.new(1, 0.5),
							TextColor3 = Color3.new(1, 1, 1),
							TextXAlignment = Enum.TextXAlignment.Right,
						},
					}
				end),
			}),
		},
	}))

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="163">
                  <Properties>
                    <string name="Name">ObservableSortedList_Performance.story</string>
                    <string name="Source"><![CDATA[--[[
	@class ObservableSortedList.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Maid = require("Maid")
local ObservableSortedList = require("ObservableSortedList")

return function(_target)
	local maid = Maid.new()

	local function test(n, label, sortedList, getElement)
		local function add(number)
			sortedList:Add(tostring(number), number)
		end

		local startTime = os.clock()
		for i = 1, n do
			add(getElement(i))
		end

		print(string.format("%25s %0.2f ms", label .. " construction", (os.clock() - startTime) * 1000))
	end

	local function cleanup(label, sortedList)
		local startTime = os.clock()

		sortedList:Destroy()

		print(string.format("%25s %0.2f ms", label .. " destruction", (os.clock() - startTime) * 1000))
	end

	local function getRandomElement()
		return math.random()
	end

	local function inOrder(i)
		return i
	end

	local function same()
		return 0
	end

	local function runTest(label, n, getElement)
		local observableSortedList = maid:Add(ObservableSortedList.new())

		print(string.format("%25s n = %d", label, n))
		print(string.format("%25s %8s", string.rep("-", 25), string.rep("-", 10)))

		test(n, "new impl", observableSortedList, getElement)
		cleanup("new impl", observableSortedList)

		print("\n")
	end

	local n = 1000
	runTest("test random_order", n, getRandomElement)
	runTest("test in_order", n, inOrder)
	runTest("same", n, same)

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="164">
                  <Properties>
                    <string name="Name">ObservableSortedList_Print.story</string>
                    <string name="Source"><![CDATA[--[[
	@class ObservableSortedList.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Maid = require("Maid")
local ObservableSortedList = require("ObservableSortedList")

return function(_target)
	local maid = Maid.new()

	print("----")

	task.spawn(function()
		local observableSortedList = maid:Add(ObservableSortedList.new())

		local toRemove = {}

		local function add(number)
			table.insert(toRemove, observableSortedList:Add(tostring(number), number))
		end

		-- local random = Random.new(5000)
		-- for i=1, 10 do
		-- 	add(random:NextNumber())
		-- end

		local random = Random.new()
		for _i = 1, 10 do
			add(math.floor(100 * random:NextNumber()))
		end

		for index, node in observableSortedList._root:IterateNodesRange(3, 7) do
			print(index, node:GetIndex())
		end

		observableSortedList:PrintDebug()

		for _, item in toRemove do
			item()
		end

		-- observableSortedList:PrintDebug()
		observableSortedList:Destroy()
	end)

	-- for i=1, 10 do
	-- 	add(-i)
	-- 	add(i)
	-- end

	-- add(2)
	-- add(1)
	-- add(3)
	-- add(4)
	-- add(5)
	-- add(0)

	-- print(observableSortedList:GetList())

	return function()
		maid:DoCleaning()
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="165">
                  <Properties>
                    <string name="Name">SortFunctionUtils</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	@class SortFunctionUtils
]=]

local SortFunctionUtils = {}

export type SortFunction<T> = (a: T, b: T) -> number

export type WrappedIterator<T...> = (...any) -> T...

--[=[
	Reverses a given sort function

	@param compare (a: T, b: T) -> number
	@return (a: T, b: T) -> number
]=]
function SortFunctionUtils.reverse<T>(compare: SortFunction<T>?): SortFunction<T>
	local comparison = compare or SortFunctionUtils.default
	return function(a: T, b: T): number
		return (comparison :: any)(b, a)
	end
end

--[=[
	Sorts a given list of items using the given compare function

	Higher numbers last

	@param a T
	@param b T
	@return number
]=]
function SortFunctionUtils.default(a: any, b: any): number
	-- equivalent of `return a - b` except it supports comparison of strings and stuff
	if b > a then
		return -1
	elseif b < a then
		return 1
	else
		return 0
	end
end

function SortFunctionUtils.emptyIterator() end

return SortFunctionUtils
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="166">
                  <Properties>
                    <string name="Name">SortedNode</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Used by [ObservableSortedList] to maintain a red-black binary search tree.

	@class SortedNode
]=]

local require = require(script.Parent.loader).load(script)

local DuckTypeUtils = require("DuckTypeUtils")
local ListIndexUtils = require("ListIndexUtils")
local SortFunctionUtils = require("SortFunctionUtils")
local SortedNodeValue = require("SortedNodeValue")
local Table = require("Table")

local DEBUG_ASSERTION_SLOW = false

export type SortedNodeColor = "BLACK" | "RED"

export type SortedNodeColorMap = {
	BLACK: "BLACK",
	RED: "RED",
}

local Color = Table.readonly({
	BLACK = "BLACK",
	RED = "RED",
} :: SortedNodeColorMap)

local SortedNode = {}
SortedNode.ClassName = "SortedNode"
SortedNode.__index = SortedNode

export type SortedNode<T> = typeof(setmetatable(
	{} :: {
		left: SortedNode<T>?,
		right: SortedNode<T>?,
		parent: SortedNode<T>?,
		color: SortedNodeColor,
		value: number?, -- Actually SortedNodeValue too, but we treat as number
		descendantCount: number,
		data: T,
	},
	{} :: typeof({ __index = SortedNode })
))

function SortedNode.new<T>(data: T): SortedNode<T>
	assert(data ~= nil, "Bad data")

	local self: SortedNode<T> = setmetatable({} :: any, SortedNode)

	self.data = data
	self.color = Color.RED
	self.descendantCount = 1

	return self
end

function SortedNode.isSortedNode(value: any): boolean
	return DuckTypeUtils.isImplementation(SortedNode, value)
end

function SortedNode.IterateNodes<T>(self: SortedNode<T>): SortFunctionUtils.WrappedIterator<number, SortedNode<T>>
	return coroutine.wrap(function()
		local stack: { SortedNode<T> } = {}
		local current: any? = self
		local index = 1

		while current or #stack > 0 do
			-- Reach the leftmost node of the current node
			while current ~= nil do
				table.insert(stack, current)
				current = current.left
			end

			current = table.remove(stack)
			coroutine.yield(index, current)
			index += 1
			current = (current :: any).right
		end
	end) :: any
end

function SortedNode.IterateData<T>(self: SortedNode<T>): SortFunctionUtils.WrappedIterator<number, T>
	return coroutine.wrap(function()
		local stack: { SortedNode<T> } = {}
		local current: any = self
		local index = 1

		while current or #stack > 0 do
			-- Reach the leftmost node of the current node
			while current ~= nil do
				table.insert(stack, current)
				current = current.left
			end

			local removed: SortedNode<T> = assert(table.remove(stack), "Must have entry")
			coroutine.yield(index, removed.data)
			index += 1
			current = removed.right
		end
	end) :: any
end

--[=[
	Inclusive iterator like string.sub. Faster than skipping because we
	binary search our initial node

	@param start number
	@param finish number
	@return (T) -> ((T, nextIndex: any) -> ...any, T?)
]=]
function SortedNode.IterateNodesRange<T>(
	self: SortedNode<T>,
	start: number,
	finish: number?
): SortFunctionUtils.WrappedIterator<number, SortedNode<T>>
	assert(type(start) == "number", "Bad start")
	assert(type(finish) == "number" or finish == nil, "Bad finish")
	assert(self.parent == nil, "Should only be called on root")

	if start == 1 and (finish == nil or finish == -1) then
		return self:IterateNodes()
	end

	return coroutine.wrap(function()
		local target: number = ListIndexUtils.toPositiveIndex(self.descendantCount, start)
		local endTarget: number = ListIndexUtils.toPositiveIndex(self.descendantCount, finish or -1)
		local current: any? = self:FindNodeAtIndex(target)

		-- We're out of range
		if not current then
			return
		end

		local index: number = target

		while current do
			coroutine.yield(index, current)
			index += 1

			if index > endTarget then
				return
			end

			-- Emit right most tree first
			if current.right then
				for _, value in current.right:IterateNodes() do
					coroutine.yield(index, value)
					index += 1

					if index > endTarget then
						return
					end
				end
			end

			-- Skip all scenarios where we're on the right
			while current.parent and current:_isOnRight() do
				current = current.parent
			end

			current = current.parent
		end

		return
	end) :: any
end

function SortedNode.FindNodeAtIndex<T>(self: SortedNode<T>, searchIndex: number): SortedNode<T>?
	assert(type(searchIndex) == "number", "Bad searchIndex")
	assert(self.parent == nil, "Should only be called on root")

	local target = ListIndexUtils.toPositiveIndex(self.descendantCount, searchIndex)
	if target > self.descendantCount or target <= 0 then
		return nil
	end

	local current: any = self
	local index = 1
	if self.left then
		index += self.left.descendantCount
	end

	while current do
		if index == target then
			return current
		elseif target < index then
			current = current.left
			index -= 1
			if current.right ~= nil then
				index -= current.right.descendantCount
			end
		else
			current = current.right
			index += 1
			if current.left ~= nil then
				index += current.left.descendantCount
			end
		end
	end

	return nil
end

function SortedNode.FindNodeIndex<T>(self: SortedNode<T>, node: SortedNode<T>): number?
	assert(SortedNode.isSortedNode(node), "Bad node")
	assert(self.parent == nil, "Should only be called on root")

	-- TODO: Don't iterate twice
	if self:ContainsNode(node) then
		return node:GetIndex()
	else
		return nil
	end
end

function SortedNode.GetIndex<T>(self: SortedNode<T>): number
	local index = 1

	if self.left then
		index += self.left.descendantCount
	end

	local current = self
	while current.parent ~= nil do
		if current == current.parent.right then
			index += 1

			if (current :: any).parent.left then
				index += (current :: any).parent.left.descendantCount
			end
		end

		current = current.parent
	end

	return index
end

function SortedNode.FindFirstNodeForData<T>(self: SortedNode<T>, data: T): SortedNode<T>?
	-- TODO: This is a linear search, very bad

	for _, current in self:IterateNodes() do
		if current.data == data then
			return current
		end
	end

	return nil
end

function SortedNode.NeedsToMove<T>(self: SortedNode<T>, root: SortedNode<T>?, newValue: number): boolean
	assert(newValue ~= nil, "Bad newValue")

	if self.parent ~= nil then
		if self:_isOnLeft() then
			if self.parent.value < newValue then
				return true
			end
		else
			if self.parent.value > newValue then
				return true
			end
		end
	else
		if self ~= root or root == nil then
			return true
		end
	end

	if self.left and self.left.value > newValue then
		return true
	end

	if self.right and self.right.value < newValue then
		return true
	end

	return false
end

--[=[
	Returns true if the node is contained within the parent node
]=]
function SortedNode.ContainsNode<T>(self: SortedNode<T>, node: SortedNode<T>): boolean
	assert(SortedNode.isSortedNode(node), "Bad SortedNode")

	local current: any = node
	while current do
		if current == self then
			return true
		end

		current = current.parent
	end

	return false
end

function SortedNode.MarkBlack<T>(self: SortedNode<T>)
	self.color = Color.BLACK
end

function SortedNode.InsertNode<T>(self: SortedNode<T>, node: SortedNode<T>): SortedNode<T>
	assert(SortedNode.isSortedNode(node), "Bad SortedNode")
	assert(self.parent == nil, "Should only be called on root")
	assert(node.parent == nil, "Already parented")
	assert(node.left == nil, "Already has left child")
	assert(node.right == nil, "Already has right child")

	local root = self
	local originalCount = root.descendantCount

	node.color = Color.RED

	local parent: SortedNode<T>? = nil
	local current: any = root

	while current ~= nil do
		parent = current
		if node.value < current.value then
			current = current.left
		else
			current = current.right
		end
	end

	if parent == nil then
		root = node
	elseif node.value < parent.value then
		parent:_setLeft(node)
	else
		parent:_setRight(node)
	end

	-- Fix the tree after insertion
	root = self:_fixDoubleRed(root, node)

	if DEBUG_ASSERTION_SLOW then
		root:_assertIntegrity()
		root:_assertRootIntegrity()
		root:_assertFullIntegritySlow()
		root:_assertRedBlackIntegrity()
		root:_assertRedBlackFullIntegritySlow()
		root:_assertDescendantCount(originalCount + 1)
	end

	return root
end

function SortedNode._leftRotate<T>(_self: SortedNode<T>, root, node): SortedNode<T>
	assert(root, "No root")
	assert(node, "No node")

	local newParent = node.right
	node:_setRight(newParent.left)

	if node == root then
		newParent:_unparent()
		root = newParent
	elseif node == node.parent.right then
		node.parent:_setRight(newParent)
	elseif node == node.parent.left then
		node.parent:_setLeft(newParent)
	else
		error("Bad state")
	end

	newParent:_setLeft(node)

	return root
end

function SortedNode._rightRotate<T>(_self: SortedNode<T>, root, node): SortedNode<T>
	assert(root, "No root")
	assert(node, "No node")

	local newParent = node.left
	node:_setLeft(newParent.right)

	if node == root then
		newParent:_unparent()
		root = newParent
	elseif node == node.parent.right then
		node.parent:_setRight(newParent)
	elseif node == node.parent.left then
		node.parent:_setLeft(newParent)
	else
		error("Bad state")
	end

	newParent:_setRight(node)

	return root
end

function SortedNode._swapColors<T>(self: SortedNode<T>, other: SortedNode<T>)
	self.color, other.color = other.color, self.color
end

function SortedNode._fixDoubleRed<T>(self: SortedNode<T>, root: SortedNode<T>, node: SortedNode<T>): SortedNode<T>
	if node == root then
		node.color = Color.BLACK
		return root
	end

	local parent: any = assert(node.parent, "Must have node parent")
	local grandparent: any = node.parent and node.parent.parent
	local uncle: any = node:_uncle()

	if not grandparent then
		return root
	end

	if parent.color == Color.BLACK then
		return root
	end

	if uncle and uncle.color == Color.RED then
		parent.color = Color.BLACK
		uncle.color = Color.BLACK
		grandparent.color = Color.RED

		root = self:_fixDoubleRed(root, grandparent)
	else
		-- Rotate
		if grandparent.left == parent then
			if parent.left == node then
				parent:_swapColors(grandparent)
			elseif parent.right == node then
				root = self:_leftRotate(root, parent)
				node:_swapColors(grandparent)
			else
				error("Bad state")
			end

			root = self:_rightRotate(root, grandparent)
		elseif grandparent.right == parent then
			if parent.left == node then
				root = self:_rightRotate(root, parent)
				node:_swapColors(grandparent)
			elseif parent.right == node then
				parent:_swapColors(grandparent)
			else
				error("Bad state")
			end

			root = self:_leftRotate(root, grandparent)
		else
			error("Bad state")
		end
	end

	return root
end

function SortedNode._setLeft<T>(self: SortedNode<T>, node: SortedNode<T>?)
	assert(node ~= self, "Cannot assign to self")

	if self.left == node then
		return
	end

	if self.left then
		self.left.parent = nil
		self.left = nil
	end

	if node then
		if node.parent then
			node:_unparent()
		end

		self.left = node
		node.parent = self
	end

	self:_updateAllParentDescendantCount()
end

function SortedNode._setRight<T>(self: SortedNode<T>, node: SortedNode<T>?)
	assert(node ~= self, "Cannot assign to self")

	if self.right == node then
		return
	end

	if self.right then
		self.right.parent = nil
		self.right = nil
	end

	if node then
		if node.parent then
			node:_unparent()
		end

		self.right = node
		node.parent = self
	end

	self:_updateAllParentDescendantCount()
end

function SortedNode._updateAllParentDescendantCount<T>(self: SortedNode<T>)
	local current: any = self
	while current do
		local descendantCount = 1
		local left = current.left
		if left then
			descendantCount += left.descendantCount
		end
		local right = current.right
		if right then
			descendantCount += right.descendantCount
		end

		current.descendantCount = descendantCount
		current = current.parent
	end
end

function SortedNode.RemoveNode<T>(self: SortedNode<T>, node: SortedNode<T>): SortedNode<T>
	assert(SortedNode.isSortedNode(node), "Bad SortedNode")
	assert(self.parent == nil, "Should only be called on root")

	local root = self
	local originalCount = root.descendantCount

	if not root:ContainsNode(node) then
		return self
	end

	root = self:_removeNodeHelper(root, node)

	if DEBUG_ASSERTION_SLOW then
		if root then
			root:_assertIntegrity()
			root:_assertRootIntegrity()
			root:_assertFullIntegritySlow()
			root:_assertRedBlackIntegrity()
			root:_assertRedBlackFullIntegritySlow()

			root:_assertDescendantCount(originalCount - 1)
		else
			if originalCount ~= 1 then
				error(string.format("Removed %d nodes instead of 1", originalCount - 1))
			end
		end
	end

	return root
end

function SortedNode._removeNodeHelper<T>(
	self: SortedNode<T>,
	root: SortedNode<T>?,
	node: SortedNode<T>?,
	depth: number?
): SortedNode<T>
	assert(root, "Bad root")
	assert(node, "Bad node")
	depth = (depth or 0) + 1

	if depth > 2 then
		error("Should not recursively call remove node helper more than once")
	end

	local replacement = self:_findReplacement(node)
	local bothBlack = (replacement == nil or replacement.color == Color.BLACK) and node.color == Color.BLACK
	local parent = node.parent

	if replacement == nil then
		-- Node is a leaf or only has 1 child
		if node == root then
			root = nil
		else
			if bothBlack then
				root = self:_fixDoubleBlack(root, node)
				assert(root, "Should have root")
			else
				local sibling = node:_sibling()
				if sibling then
					sibling.color = Color.RED
				end
			end

			assert(node.descendantCount == 1, "Cannot unparent")
			node:_unparent()
		end
	elseif node.left == nil or node.right == nil then
		-- Node to be deleted has only one child

		if node == root then
			root = self:_swapNodes(root, node, replacement)
			root = self:_removeNodeHelper(root, node, depth)
		else
			assert(parent, "Node must have parent")

			if node:_isOnLeft() then
				parent:_setLeft(replacement)
			elseif node:_isOnRight() then
				parent:_setRight(replacement)
			else
				error("Bad state")
			end

			if bothBlack then
				root = self:_fixDoubleBlack(root, replacement)
				assert(root, "Should have root")
			else
				-- One of these are red, swap to black
				replacement.color = Color.BLACK
			end
		end
	else
		-- two children
		root = self:_swapNodes(root, node, replacement)
		root = self:_removeNodeHelper(root, node, depth)
	end

	if DEBUG_ASSERTION_SLOW then
		if root then
			root:_assertIntegrity()
			root:_assertRootIntegrity()
			root:_assertFullIntegritySlow()
			root:_assertRedBlackIntegrity()
			root:_assertRedBlackFullIntegritySlow()
		end
	end

	return root
end

function SortedNode._swapNodes<T>(
	_self: SortedNode<T>,
	root: SortedNode<T>,
	node: SortedNode<T>,
	replacement: SortedNode<T>
): SortedNode<T>?
	assert(root, "No root")
	assert(node, "No node")
	assert(replacement, "No replacement")
	assert(node ~= replacement, "Node can not be the replacement")

	-- In direct descendant scenario node is always parent
	if replacement:ContainsNode(node) then
		node, replacement = replacement, node
	end

	assert(replacement ~= root, "Replacement cannot be root")
	assert(replacement.parent, "Replacement must have parent")
	local descendantCount = root.descendantCount

	local nodeParent = node.parent
	local nodeLeft = node.left
	local nodeRight = node.right
	local nodeOnLeft = nodeParent and node:_isOnLeft()
	local nodeColor: SortedNodeColor = node.color
	local replacementLeft = replacement.left
	local replacementRight = replacement.right
	local replacementParent = replacement.parent
	local replacementOnLeft = replacement:_isOnLeft()
	local replacementColor: SortedNodeColor = replacement.color

	if replacement.parent == node then
		node:_unparent()
		replacement:_unparent()

		-- Special case for direct descendants, node is always parent in this scenario
		if nodeParent == nil then
			if node == root then
				root = replacement
			else
				error("Should be root if our item's parent is nil")
			end
		elseif nodeOnLeft then
			nodeParent:_setLeft(replacement)
		else
			nodeParent:_setRight(replacement)
		end

		-- Transformed to: Replacement -> Node
		if replacementOnLeft then
			replacement:_setLeft(node)
			replacement:_setRight(nodeRight)
		else
			replacement:_setRight(node)
			replacement:_setLeft(nodeLeft)
		end

		node:_setLeft(replacementLeft)
		node:_setRight(replacementRight)

		if DEBUG_ASSERTION_SLOW then
			assert(node.parent == replacement, "Swap failed on node.parent")
			assert(replacement.parent == nodeParent, "Swap failed on replacement.parent")
			assert(node.left == replacementLeft, "Swap failed on node.left")
			assert(node.right == replacementRight, "Swap failed on node.right")
		end
	else
		node:_unparent()
		replacement:_unparent()

		-- Unparent everything
		node:_setLeft(replacementLeft)
		node:_setRight(replacementRight)
		replacement:_setLeft(nodeLeft)
		replacement:_setRight(nodeRight)

		if nodeParent == nil then
			if node == root then
				root = replacement
			else
				error("Bad state")
			end
		elseif nodeOnLeft then
			nodeParent:_setLeft(replacement)
		else
			nodeParent:_setRight(replacement)
		end

		if replacementOnLeft then
			replacementParent:_setLeft(node)
		else
			replacementParent:_setRight(node)
		end

		if DEBUG_ASSERTION_SLOW then
			assert(node.parent == replacementParent, "Swap failed on node.parent")
			assert(replacement.parent == nodeParent, "Swap failed on replacement.parent")
			assert(node.left == replacementLeft, "Swap failed on node.left")
			assert(node.right == replacementRight, "Swap failed on node.right")
			assert(replacement.left == nodeLeft, "Swap failed on replacement.left")
			assert(replacement.right == nodeRight, "Swap failed on replacement.right")
		end
	end

	node.color = replacementColor
	replacement.color = nodeColor

	if DEBUG_ASSERTION_SLOW then
		root:_assertDescendantCount(descendantCount)
	end

	return root
end

function SortedNode._findReplacement<T>(_self: SortedNode<T>, node: SortedNode<T>): SortedNode<T>?
	if node.left and node.right then
		return node.right:_successor()
	end

	if node.left and node.right then
		return nil
	end

	if node.left then
		return node.left
	else
		return node.right
	end
end

function SortedNode._successor<T>(self: SortedNode<T>): SortedNode<T>
	local node = self
	while node.left ~= nil do
		node = node.left
	end
	return node
end

--[[
	https://www.geeksforgeeks.org/deletion-in-red-black-tree/?ref=oin_asr9
]]
function SortedNode._fixDoubleBlack<T>(self: SortedNode<T>, root: SortedNode<T>, node: SortedNode<T>): SortedNode<T>
	assert(root, "No root")
	assert(node, "No node")

	if node == root then
		return root
	end

	assert(node.parent, "Should have parent")

	local sibling = node:_sibling()
	local parent = node.parent

	if sibling == nil then
		return self:_fixDoubleBlack(root, parent)
	end

	if sibling.color == Color.RED then
		parent.color = Color.RED
		sibling.color = Color.BLACK

		if sibling:_isOnLeft() then
			-- Left case
			root = self:_rightRotate(root, parent)
		elseif parent.right == sibling then
			-- Right case
			root = self:_leftRotate(root, parent)
		else
			error("Bad state")
		end

		root = self:_fixDoubleBlack(root, node)
	elseif sibling.color == Color.BLACK then
		if sibling:_hasRedChild() then
			-- At least 1 red child

			if sibling.left and sibling.left.color == Color.RED then
				if sibling:_isOnLeft() then
					-- Left-left
					sibling.left.color = Color.BLACK
					sibling.color = parent.color
					parent.color = Color.BLACK -- This should be true, but the guide I'm following doesn't specify this?
					root = self:_rightRotate(root, parent)
				else
					-- Right-left
					sibling.left.color = parent.color
					parent.color = Color.BLACK -- This should be true, but the guide I'm following doesn't specify this?
					root = self:_rightRotate(root, sibling)
					root = self:_leftRotate(root, parent)
				end
			else
				if sibling:_isOnLeft() then
					-- Left-right
					(sibling :: any).right.color = parent.color
					parent.color = Color.BLACK -- This should be true, but the guide I'm following doesn't specify this?
					root = self:_leftRotate(root, sibling)
					root = self:_rightRotate(root, parent)
				else
					-- Right-right
					(sibling :: any).right.color = sibling.color
					sibling.color = parent.color
					parent.color = Color.BLACK -- This should be true, but the guide I'm following doesn't specify this?
					root = self:_leftRotate(root, parent)
				end
			end
		else
			-- 2 black children
			sibling.color = Color.RED
			if parent.color == Color.BLACK then
				root = self:_fixDoubleBlack(root, parent)
			else
				parent.color = Color.BLACK
			end
		end
	else
		error("Bad state")
	end

	return root
end

function SortedNode._isOnLeft<T>(self: SortedNode<T>): boolean
	assert(self.parent, "Must have parent to invoke this method")

	return self.parent.left == self
end

function SortedNode._isOnRight<T>(self: SortedNode<T>): boolean
	assert(self.parent, "Must have parent to invoke this method")

	return self.parent.right == self
end

function SortedNode._hasRedChild<T>(self: SortedNode<T>): boolean
	if self.left and self.left.color == Color.RED then
		return true
	end

	if self.right and self.right.color == Color.RED then
		return true
	end

	return false
end

function SortedNode._unparent<T>(self: SortedNode<T>)
	local parent = self.parent
	if not parent then
		return
	elseif parent.left == self then
		parent:_setLeft(nil)
	elseif parent.right == self then
		parent:_setRight(nil)
	else
		error("Bad state")
	end
end

function SortedNode._uncle<T>(self: SortedNode<T>): SortedNode<T>?
	local grandparent = self:_grandparent()
	if not grandparent then
		return nil
	end

	if self.parent == grandparent.left then
		return grandparent.right
	elseif self.parent == grandparent.right then
		return grandparent.left
	else
		return nil
	end
end

function SortedNode._sibling<T>(self: SortedNode<T>): SortedNode<T>?
	local parent = self.parent
	if parent then
		if self == parent.left then
			return parent.right
		elseif self == parent.right then
			return parent.left
		else
			error("Bad state")
		end
	else
		return nil
	end
end

function SortedNode._grandparent<T>(self: SortedNode<T>)
	if self.parent then
		return self.parent.parent
	else
		return nil
	end
end

type SortedNodeTostringStackEntry<T> = {
	node: SortedNode<T>?,
	indent: string,
	isLeft: boolean,
}

function SortedNode.__tostring<T>(self: SortedNode<T>): string
	local result: string
	if self.parent == nil then
		result = "BinarySearchTree\n"
	else
		result = "SortedNode\n"
	end

	local stack: { SortedNodeTostringStackEntry<T> } = {} -- Stack to hold nodes and their details
	local seen = {}
	table.insert(stack, { node = self, indent = "", isLeft = false })

	while #stack > 0 do
		local current: SortedNodeTostringStackEntry<T> = assert(table.remove(stack), "Must have entry") -- Pop from the stack
		local wasSeen

		if current.node then
			wasSeen = seen[current.node]
			seen[current.node] = true
		else
			wasSeen = false
		end

		local node = current.node
		local indent = current.indent
		local isLeft = current.isLeft

		-- Add current node to result with indentation
		result = result .. indent
		if isLeft then
			result = result .. "├── "
			indent = indent .. "│   "
		else
			result = result .. "└── "
			indent = indent .. "    "
		end

		if node then
			local text = string.format(
				"SortedNode { index=%d, value=%s, descendants=%d, color=%s }",
				node:GetIndex(),
				tostring(node.value),
				node.descendantCount,
				node.color
			)

			if wasSeen then
				result = result .. "<LOOPED> "
			end

			result = result .. text .. "\n"
		else
			result = result .. "nil" .. "\n"
		end

		if node and not wasSeen and (node.left or node.right) then
			-- Push right and left children to the stack with updated indentation
			-- Right child is pushed first so that left child is processed first
			table.insert(stack, { node = node.right, indent = indent, isLeft = false })
			table.insert(stack, { node = node.left, indent = indent, isLeft = true })
		end
	end

	return result
end

function SortedNode._childCount<T>(self: SortedNode<T>): number
	if self.left == nil and self.right == nil then
		return 0
	elseif self.left and self.right then
		return 1
	else
		return 2
	end
end

function SortedNode._debugGetRoot<T>(self: SortedNode<T>): SortedNode<T>
	assert(DEBUG_ASSERTION_SLOW, "Must have debug enabled")

	local seen = {}
	local root = self
	seen[root] = true

	while root.parent ~= nil do
		root = root.parent
		if seen[root] then
			error("Loop in parents")
		end
		seen[root] = true
	end

	return root
end

function SortedNode._assertRedBlackIntegrity<T>(self: SortedNode<T>)
	assert(DEBUG_ASSERTION_SLOW, "Must have debug enabled")

	-- https://en.wikipedia.org/wiki/Red%E2%80%93black_tree
	if self.color == Color.RED then
		-- Check adjacency
		if self.left then
			if self.left.color == Color.RED then
				error(
					string.format(
						"A red node should not have a red child %s\n%s",
						tostring(self:_debugGetRoot()),
						tostring(self)
					)
				)
			end
		end

		if self.right then
			if self.right.color == Color.RED then
				error(
					string.format(
						"A red node should not have a red child %s\n%s",
						tostring(self:_debugGetRoot()),
						tostring(self)
					)
				)
			end
		end

		if self.parent then
			if self.parent.color == Color.RED then
				error(
					string.format(
						"A red node should not be have a red parent %s\n%s",
						tostring(self:_debugGetRoot()),
						tostring(self)
					)
				)
			end
		end
	end

	if self.left ~= nil and self.right == nil then
		if self.left.color ~= Color.RED then
			error(
				string.format(
					"Any node with 1 child must be red %s\n%s",
					tostring(self:_debugGetRoot()),
					tostring(self)
				)
			)
		end
	end

	if self.left == nil and self.right ~= nil then
		if self.right.color ~= Color.RED then
			error(
				string.format(
					"Any node with 1 child must be red %s\n%s",
					tostring(self:_debugGetRoot()),
					tostring(self)
				)
			)
		end
	end
end

function SortedNode._assertRedBlackFullIntegritySlow<T>(self: SortedNode<T>)
	assert(DEBUG_ASSERTION_SLOW, "Must have debug enabled")

	local root = self:_debugGetRoot()

	for _, node in root:IterateNodes() do
		node:_assertRedBlackIntegrity()
	end

	local seen = {}

	local maxDepth = nil
	local function recurse(node: SortedNode<T>, ancestorBlackCount: number)
		if seen[node] then
			error("Loop in nodes")
		end

		seen[node] = true

		if node.color == Color.BLACK then
			ancestorBlackCount += 1
		end

		if node.left then
			recurse(node.left, ancestorBlackCount)
		else
			if maxDepth == nil then
				maxDepth = ancestorBlackCount
			elseif maxDepth ~= ancestorBlackCount then
				error(
					string.format(
						"Leaf nodes must all pass through the same amount (%d) of black nodes to root, but we are at %d",
						maxDepth,
						ancestorBlackCount
					)
				)
			end
		end

		if node.right then
			recurse(node.right, ancestorBlackCount)
		else
			if maxDepth == nil then
				maxDepth = ancestorBlackCount
			elseif maxDepth ~= ancestorBlackCount then
				error(
					string.format(
						"Leaf nodes must all pass through the same amount (%d) of black nodes to root but we are at %d",
						maxDepth,
						ancestorBlackCount
					)
				)
			end
		end
	end

	assert(root.color == Color.BLACK, "Root must be black")
	recurse(root, 0)
end

function SortedNode._assertIntegrity<T>(self: SortedNode<T>)
	assert(DEBUG_ASSERTION_SLOW, "Must have debug enabled")
	assert(self.left ~= self, "Node cannot be parented to self")
	assert(self.right ~= self, "Node cannot be parented to self")
	assert(self.parent ~= self, "Node cannot be parented to self")

	local parent = self.parent
	if parent then
		assert(parent.left == self or parent.right == self, "We are parented without parent data being set")

		if parent.left == self then
			if self.value > parent.value then
				error(
					string.format(
						"self.parent.left.value %s >= parent.value %s",
						self:_valueToHumanReadable(),
						parent:_valueToHumanReadable()
					)
				)
			end
		end

		if parent.right == self then
			if self.value < parent.value then
				error(
					string.format(
						"self.parent.right.value %s <= parent.value %s",
						self:_valueToHumanReadable(),
						parent:_valueToHumanReadable()
					)
				)
			end
		end
	end

	local descendantCount = 1
	local left = self.left
	if left then
		assert(left.parent == self, "Left parent is not set to us")

		if left.value > self.value then
			error(
				string.format(
					"left.value %s > self.value %s",
					left:_valueToHumanReadable(),
					self:_valueToHumanReadable()
				)
			)
		end

		descendantCount += left.descendantCount
	end

	local right = self.right
	if right then
		assert(right.parent == self, "Right parent is not set to us")

		if right.value < self.value then
			error(
				string.format(
					"right.value %s <= self.value %s",
					right:_valueToHumanReadable(),
					self:_valueToHumanReadable()
				)
			)
		end

		descendantCount += right.descendantCount
	end

	if self.descendantCount ~= descendantCount then
		error(string.format("Bad descendantCount on node (%d, should be %d)", self.descendantCount, descendantCount))
	end
end

function SortedNode._valueToHumanReadable<T>(self: SortedNode<T>): string
	local value: any = self.value
	if type(value) == "number" then
		return string.format("%0.2f", value)
	elseif SortedNodeValue.isSortedNodeValue(value) then
		return tostring(value)
	else
		error(string.format("Bad value %s", tostring(value)))
	end
end

function SortedNode._assertFullIntegritySlow<T>(self: SortedNode<T>)
	assert(DEBUG_ASSERTION_SLOW, "Must have debug enabled")

	local root = self:_debugGetRoot()
	local previous = nil
	local seen = {}
	for index, node in root:IterateNodes() do
		if seen[node] then
			error("Loop in nodes")
		end

		seen[node] = true
		if previous then
			assert(previous.value <= node.value, "Node is out of order")
		end

		previous = node
		node:_assertIntegrity()

		if node:GetIndex() ~= index then
			error(string.format("Node index at %d should be %d", index, node:GetIndex()))
		end
	end
end

function SortedNode._assertRootIntegrity<T>(self: SortedNode<T>)
	assert(DEBUG_ASSERTION_SLOW, "Must have debug enabled")
	assert(self.parent == nil, "Root should not have a parent")
	assert(self.color == Color.BLACK, "Root should be black")
end

function SortedNode._assertDescendantCount<T>(self: SortedNode<T>, expected: number)
	assert(DEBUG_ASSERTION_SLOW, "Must have debug enabled")

	if self.descendantCount ~= expected then
		error(string.format("Bad descendantCount, expected %d descendants, have %d", expected, self.descendantCount), 2)
	end
end

return SortedNode
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="167">
                  <Properties>
                    <string name="Name">SortedNodeValue</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Simplifies comparison logic

	@class SortedNodeValue
]=]

local require = require(script.Parent.loader).load(script)

local DuckTypeUtils = require("DuckTypeUtils")

local SortedNodeValue = {}
SortedNodeValue.ClassName = "SortedNodeValue"
SortedNodeValue.__index = SortedNodeValue

export type CompareFunction<T> = (T, T) -> number

export type SortedNodeValue<T> = typeof(setmetatable(
	{} :: {
		_value: T,
		_compare: CompareFunction<T>,
	},
	{} :: typeof({ __index = SortedNodeValue })
))

function SortedNodeValue.new<T>(value: T, compare: CompareFunction<T>): SortedNodeValue<T>
	local self = setmetatable({}, SortedNodeValue)

	self._value = value
	self._compare = compare

	return self
end

function SortedNodeValue.GetValue<T>(self: SortedNodeValue<T>): T
	return self._value
end

function SortedNodeValue.isSortedNodeValue(value: any): boolean
	return DuckTypeUtils.isImplementation(SortedNodeValue, value)
end

function SortedNodeValue.__eq<T>(self: SortedNodeValue<T>, other: SortedNodeValue<T>): boolean
	assert(SortedNodeValue.isSortedNodeValue(other), "Bad other")
	assert(other._compare == self._compare, "Bad compare")

	return self._compare(self._value, other._value) == 0
end

function SortedNodeValue.__lt<T>(self: SortedNodeValue<T>, other: SortedNodeValue<T>): boolean
	assert(SortedNodeValue.isSortedNodeValue(other), "Bad other")
	assert(other._compare == self._compare, "Bad compare")

	return self._compare(self._value, other._value) < 0
end

function SortedNodeValue.__gt<T>(self: SortedNodeValue<T>, other: SortedNodeValue<T>): boolean
	assert(SortedNodeValue.isSortedNodeValue(other), "Bad other")
	assert(other._compare == self._compare, "Bad compare")

	return self._compare(self._value, other._value) > 0
end

return SortedNodeValue
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="168">
                <Properties>
                  <string name="Name">Utils</string>
                </Properties>
                <Item class="ModuleScript" referent="169">
                  <Properties>
                    <string name="Name">ListIndexUtils</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	@class ListIndexUtils
]=]

local ListIndexUtils = {}

--[=[
	Converts a negative index to a positive one for the list indexing

	@param listLength number
	@param index number
	@return number
]=]
function ListIndexUtils.toPositiveIndex(listLength: number, index: number): number
	assert(type(listLength) == "number", "Bad listLength")
	assert(type(index) == "number", "Bad index")

	if index > 0 then
		return index
	elseif index < 0 then
		return listLength + index + 1
	else
		error(string.format("[ListIndexUtils.toPositiveIndex] - Bad index %d", index))
	end
end

--[=[
	Converts a positive index to a negative one for list indexing

	@param listLength number
	@param index number
	@return number
]=]
function ListIndexUtils.toNegativeIndex(listLength: number, index: number): number
	assert(type(listLength) == "number", "Bad listLength")
	assert(type(index) == "number", "Bad index")

	if index <= 0 then
		error(string.format("[ListIndexUtils.toPositiveIndex] - Invalid positive index %d", index))
	end

	return -listLength + index - 1
end

return ListIndexUtils
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="170">
            <Properties>
              <string name="Name">permissionprovider</string>
            </Properties>
            <Item class="Folder" referent="171">
              <Properties>
                <string name="Name">Client</string>
              </Properties>
              <Item class="ModuleScript" referent="172">
                <Properties>
                  <string name="Name">PermissionServiceClient</string>
                  <string name="Source"><![CDATA[--[=[
	Provides permissions on the client. See [PermissionService] for more details.

	:::tip
	Be sure to initialize the [PermissionService] on the server.
	:::

	@class PermissionServiceClient
	@client
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local PermissionProviderClient = require("PermissionProviderClient")
local PermissionProviderConstants = require("PermissionProviderConstants")
local Promise = require("Promise")
local ServiceBag = require("ServiceBag")

local PermissionServiceClient = {}
PermissionServiceClient.ServiceName = "PermissionServiceClient"

--[=[
	Initializes the permission service on the client. Should be done via [ServiceBag].
	@param serviceBag ServiceBag
]=]
function PermissionServiceClient:Init(serviceBag: ServiceBag.ServiceBag)
	assert(not self._serviceBag, "Already initialized")
	self._serviceBag = assert(serviceBag, "no serviceBag")
	self._maid = Maid.new()

	self._providerPromise =
		Promise.resolved(PermissionProviderClient.new(PermissionProviderConstants.DEFAULT_REMOTE_FUNCTION_NAME))
end

--[=[
	Returns whether the player is an admin.

	@param player Player | nil
	@return Promise<boolean>
]=]
function PermissionServiceClient:PromiseIsAdmin(player: Player?)
	assert((typeof(player) == "Instance" and player:IsA("Player")) or player == nil, "Bad player")

	return self:PromisePermissionProvider():Then(function(permissionProvider)
		return permissionProvider:PromiseIsAdmin(player)
	end)
end

--[=[
	Returns the permission provider
	@return Promise<PermissionProviderClient>
]=]
function PermissionServiceClient:PromisePermissionProvider()
	return self._providerPromise
end

function PermissionServiceClient:Destroy()
	self._maid:DoCleaning()
end

return PermissionServiceClient
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="173">
                <Properties>
                  <string name="Name">Providers</string>
                </Properties>
                <Item class="ModuleScript" referent="174">
                  <Properties>
                    <string name="Name">PermissionProviderClient</string>
                    <string name="Source"><![CDATA[--[=[
	Permission provider using the remote event. See [PermissionServiceClient].

	@client
	@class PermissionProviderClient
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")

local PermissionProviderConstants = require("PermissionProviderConstants")
local Promise = require("Promise")
local PromiseGetRemoteFunction = require("PromiseGetRemoteFunction")

local PermissionProviderClient = {}
PermissionProviderClient.__index = PermissionProviderClient
PermissionProviderClient.ClassName = "PermissionProviderClient"

export type PermissionProviderClient = typeof(setmetatable(
	{} :: {
		_remoteFunctionName: string,
		_remoteFunctionPromise: Promise.Promise<RemoteFunction>?,
		_cachedAdminPromise: Promise.Promise<boolean>?,
	},
	{} :: typeof({ __index = PermissionProviderClient })
))

function PermissionProviderClient.new(remoteFunctionName: string): PermissionProviderClient
	local self: PermissionProviderClient = setmetatable({} :: any, PermissionProviderClient)

	self._remoteFunctionName = remoteFunctionName or PermissionProviderConstants.DEFAULT_REMOTE_FUNCTION_NAME

	return self
end

--[=[
	Returns whether the local player is an admin.

	@param player Player | nil
	@return Promise<boolean>
]=]
function PermissionProviderClient.PromiseIsAdmin(
	self: PermissionProviderClient,
	player: Player?
): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player") or player == nil, "Bad player")

	if player ~= nil then
		assert(player == Players.LocalPlayer, "We only support local player for now")
	end

	if player == nil then
		player = Players.LocalPlayer
	end

	if self._cachedAdminPromise then
		return self._cachedAdminPromise
	end

	self._cachedAdminPromise = self:_promiseRemoteFunction():Then(function(remoteFunction)
		return Promise.spawn(function(resolve, reject)
			local result = nil
			local ok, err = pcall(function()
				result = remoteFunction:InvokeServer()
			end)
			if not ok then
				return reject(err)
			end

			if type(result) ~= "boolean" then
				return reject("Got non-boolean from server")
			end

			return resolve(result)
		end)
	end)

	return self._cachedAdminPromise :: any
end

function PermissionProviderClient._promiseRemoteFunction(self: PermissionProviderClient)
	if self._remoteFunctionPromise then
		return self._remoteFunctionPromise
	end

	self._remoteFunctionPromise = PromiseGetRemoteFunction(self._remoteFunctionName)
	return self._remoteFunctionPromise
end

return PermissionProviderClient
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="Folder" referent="175">
              <Properties>
                <string name="Name">Server</string>
              </Properties>
              <Item class="ModuleScript" referent="176">
                <Properties>
                  <string name="Name">PermissionProviderUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions to provide/configure a permission. See [BasePermissionProvider] and [PermissionService].

	@server
	@class PermissionProviderUtils
]=]

local require = require(script.Parent.loader).load(script)

local PermissionProviderConstants = require("PermissionProviderConstants")

local PermissionProviderUtils = {}

type GroupRankConfig_Input = {
	groupId: number,
	minAdminRequiredRank: number,
	minCreatorRequiredRank: number,
	remoteFunctionName: string?,
}

export type GroupRankConfig = {
	type: "GroupRankConfigType",
} & GroupRankConfig_Input

export type SingleUserConfig_Input = {
	userId: number,
	remoteFunctionName: string?,
}

export type SingleUserConfig = {
	type: "SingleUserConfigType",
} & SingleUserConfig_Input

export type PermissionProviderConfig = GroupRankConfig | SingleUserConfig

--[=[
	Creates a group rank config
	@param config { groupId: number, minAdminRequiredRank: number, minCreatorRequiredRank: number }
	@return table
]=]
function PermissionProviderUtils.createGroupRankConfig(config: GroupRankConfig_Input): GroupRankConfig
	assert(type(config.groupId) == "number", "Bad groupId")
	assert(type(config.minCreatorRequiredRank) == "number", "Bad minCreatorRequiredRank")
	assert(type(config.minAdminRequiredRank) == "number", "Bad minAdminRequiredRank")

	return {
		type = PermissionProviderConstants.GROUP_RANK_CONFIG_TYPE,
		groupId = config.groupId,
		minAdminRequiredRank = config.minAdminRequiredRank,
		minCreatorRequiredRank = config.minCreatorRequiredRank,
		remoteFunctionName = config.remoteFunctionName or PermissionProviderConstants.DEFAULT_REMOTE_FUNCTION_NAME,
	}
end

--[=[
	Creates a single user config
	@param config { userId: number }
	@return table
]=]
function PermissionProviderUtils.createSingleUserConfig(config: SingleUserConfig_Input): SingleUserConfig
	assert(type(config.userId) == "number", "Bad userId")

	return {
		type = PermissionProviderConstants.SINGLE_USER_CONFIG_TYPE,
		userId = config.userId,
		remoteFunctionName = config.remoteFunctionName or PermissionProviderConstants.DEFAULT_REMOTE_FUNCTION_NAME,
	}
end

--[=[
	Creates an automatic configuration from the game.
	@return table
]=]
function PermissionProviderUtils.createConfigFromGame(): PermissionProviderConfig
	if game.CreatorType == Enum.CreatorType.Group then
		return PermissionProviderUtils.createGroupRankConfig({
			groupId = game.CreatorId,
			minAdminRequiredRank = 250,
			minCreatorRequiredRank = 254,
		})
	else
		return PermissionProviderUtils.createSingleUserConfig({
			userId = game.CreatorId,
		})
	end
end

return PermissionProviderUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="177">
                <Properties>
                  <string name="Name">PermissionService</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Provides permissions for the game. See [BasePermissionProvider].

	:::tip
	Be sure to initialize the [PermissionServiceClient] on the client.
	:::

	```lua
	local require = require(script.Parent.loader).load(script)

	local PermissionProvider = require("PermissionProvider")
	local PermissionProviderUtils = require("PermissionProviderUtils")

	return PermissionProvider.new(PermissionProviderUtils.createGroupRankConfig({
	  groupId = 8668163;
	  minAdminRequiredRank = 250;
	  minCreatorRequiredRank = 254;
	}))
	```

	@server
	@class PermissionService
]=]

local require = require(script.Parent.loader).load(script)

local BasePermissionProvider = require("BasePermissionProvider")
local Brio = require("Brio")
local CreatorPermissionProvider = require("CreatorPermissionProvider")
local GroupPermissionProvider = require("GroupPermissionProvider")
local Maid = require("Maid")
local Observable = require("Observable")
local PermissionLevel = require("PermissionLevel")
local PermissionLevelUtils = require("PermissionLevelUtils")
local PermissionProviderConstants = require("PermissionProviderConstants")
local PermissionProviderUtils = require("PermissionProviderUtils")
local Promise = require("Promise")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local RxPlayerUtils = require("RxPlayerUtils")
local ServiceBag = require("ServiceBag")

local PermissionService = {}
PermissionService.ServiceName = "PermissionService"

export type PermissionService = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_promise: Promise.Promise<()>,
		_provider: any,
	},
	{} :: typeof({ __index = PermissionService })
))

--[=[
	Initializes the service. Should be done via [ServiceBag].
	@param _serviceBag ServiceBag
]=]
function PermissionService.Init(self: PermissionService, _serviceBag: ServiceBag.ServiceBag)
	assert(not self._promise, "Already initialized")
	assert(not self._provider, "Already have provider")

	self._provider = nil
	self._maid = Maid.new()
	self._promise = self._maid:Add(Promise.new())
end

--[=[
	Sets the provider from a config. See [PermissionProviderUtils.createGroupRankConfig]
	and [PermissionProviderUtils.createSingleUserConfig].

	@param config { type: string }
]=]
function PermissionService.SetProviderFromConfig(
	self: PermissionService,
	config: PermissionProviderUtils.PermissionProviderConfig
)
	assert(self._promise, "Not initialized")
	assert(not self._provider, "Already have provider set")

	if config.type == PermissionProviderConstants.GROUP_RANK_CONFIG_TYPE then
		self._provider = GroupPermissionProvider.new(config)
	elseif config.type == PermissionProviderConstants.SINGLE_USER_CONFIG_TYPE then
		self._provider = CreatorPermissionProvider.new(config)
	else
		error("Bad provider")
	end
end

--[=[
	Starts the permission service. Should be done via [ServiceBag].
]=]
function PermissionService.Start(self: PermissionService)
	if not self._provider then
		self:SetProviderFromConfig(PermissionProviderUtils.createConfigFromGame())
	end

	self._provider:Start()

	self._promise:Resolve(self._provider)
end

--[=[
	Returns the permission provider
	@return Promise<BasePermissionProvider>
]=]
function PermissionService.PromisePermissionProvider(
	self: PermissionService
): Promise.Promise<BasePermissionProvider.BasePermissionProvider>
	assert(self._promise, "Not initialized")

	return self._promise
end

--[=[
	Returns whether the player is an admin.
	@param player Player
	@return Promise<boolean>
]=]
function PermissionService.PromiseIsAdmin(self: PermissionService, player: Player): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "bad player")

	return self:PromiseIsPermissionLevel(player, PermissionLevel.ADMIN)
end

--[=[
	Returns whether the player is a creator.
	@param player Player
	@return Promise<boolean>
]=]
function PermissionService.PromiseIsCreator(self: PermissionService, player: Player): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "bad player")

	return self:PromiseIsPermissionLevel(player, PermissionLevel.CREATOR)
end

--[=[
	Returns whether the player is a creator.
	@param player Player
	@param permissionLevel PermissionLevel
	@return Promise<boolean>
]=]
function PermissionService.PromiseIsPermissionLevel(
	self: PermissionService,
	player: Player,
	permissionLevel: PermissionLevel.PermissionLevel
): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "bad player")
	assert(PermissionLevelUtils.isPermissionLevel(permissionLevel), "Bad permissionLevel")

	return self:PromisePermissionProvider():Then(function(permissionProvider)
		return permissionProvider:PromiseIsPermissionLevel(player, permissionLevel)
	end)
end

--[=[
	Observe all creators in the game

	@param permissionLevel PermissionLevel
	@return Observable<Brio<Player>>
]=]
function PermissionService.ObservePermissionedPlayersBrio(
	self: PermissionService,
	permissionLevel: PermissionLevel.PermissionLevel
): Observable.Observable<Brio.Brio<Player>>
	assert(PermissionLevelUtils.isPermissionLevel(permissionLevel), "Bad permissionLevel")

	return RxPlayerUtils.observePlayersBrio():Pipe({
		RxBrioUtils.flatMapBrio(function(player)
			return Rx.fromPromise(self:PromiseIsPermissionLevel(player, permissionLevel)):Pipe({
				Rx.switchMap(function(hasPermission): any
					if hasPermission then
						return Rx.of(player)
					else
						return Rx.EMPTY
					end
				end) :: any,
			}) :: any
		end) :: any,
	}) :: any
end

function PermissionService.Destroy(self: PermissionService)
	self._maid:DoCleaning()
	self._provider = nil
end

return PermissionService
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="178">
                <Properties>
                  <string name="Name">Providers</string>
                </Properties>
                <Item class="ModuleScript" referent="179">
                  <Properties>
                    <string name="Name">BasePermissionProvider</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Basic interface for providing permissions.
	@server
	@class BasePermissionProvider
]=]

local require = require(script.Parent.loader).load(script)

local BaseObject = require("BaseObject")
local GetRemoteFunction = require("GetRemoteFunction")
local PermissionLevel = require("PermissionLevel")
local PermissionLevelUtils = require("PermissionLevelUtils")
local PermissionProviderUtils = require("PermissionProviderUtils")
local Promise = require("Promise")
local Table = require("Table")

local BasePermissionProvider = setmetatable({}, BaseObject)
BasePermissionProvider.ClassName = "BasePermissionProvider"
BasePermissionProvider.__index = BasePermissionProvider

export type BasePermissionProvider = typeof(setmetatable(
	{} :: {
		_config: { remoteFunctionName: string },
		_remoteFunctionName: string,
		_remoteFunction: RemoteFunction?,
	},
	{} :: typeof({ __index = BasePermissionProvider })
)) & BaseObject.BaseObject

--[=[
	Initializes a new permission provider

	@param config { remoteFunctionName: string }
	@return BasePermissionProvider
]=]
function BasePermissionProvider.new(config: PermissionProviderUtils.PermissionProviderConfig): BasePermissionProvider
	local self: BasePermissionProvider = setmetatable(BaseObject.new() :: any, BasePermissionProvider)

	self._config = Table.readonly(assert(config, "Bad config") :: any)
	self._remoteFunctionName = assert(self._config.remoteFunctionName, "Bad config")

	return self
end

--[=[
	Starts the permission provider. Should be done via ServiceBag.
]=]
function BasePermissionProvider.Start(self: BasePermissionProvider): ()
	assert(not (self :: any)._remoteFunction, "No remoteFunction")

	local remoteFunction = GetRemoteFunction(self._remoteFunctionName)
	remoteFunction.OnServerInvoke = function(...)
		return self:_onServerInvoke(...)
	end
	self._remoteFunction = remoteFunction
end

--[=[
	Returns whether the player is a creator.
	@param player Player
	@param permissionLevel PermissionLevel
	@return Promise<boolean>
]=]
function BasePermissionProvider.PromiseIsPermissionLevel(
	_self: BasePermissionProvider,
	player: Player,
	permissionLevel: PermissionLevel.PermissionLevel
): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(PermissionLevelUtils.isPermissionLevel(permissionLevel), "Bad permissionLevel")

	error("Not implemented")
end

--[=[
	Returns whether the player is a creator.
	@param player Player
	@param permissionLevel PermissionLevel
	@return Promise<boolean>
]=]
function BasePermissionProvider.IsPermissionLevel(
	self: BasePermissionProvider,
	player: Player,
	permissionLevel: PermissionLevel.PermissionLevel
): boolean
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(PermissionLevelUtils.isPermissionLevel(permissionLevel), "Bad permissionLevel")

	local promise = self:PromiseIsPermissionLevel(player, permissionLevel)
	if promise:IsPending() then
		return false -- We won't yield for this
	end

	local ok, result = promise:Yield()
	if not ok then
		warn(string.format("[BasePermissionProvider] - %s", tostring(result)))
		return false
	end

	return result
end

--[=[
	Returns whether the player is a creator.
	@param player Player
	@return Promise<boolean>
]=]
function BasePermissionProvider.PromiseIsCreator(self: BasePermissionProvider, player: Player): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	return self:PromiseIsPermissionLevel(player, PermissionLevel.CREATOR)
end

--[=[
	Returns whether the player is an admin.
	@param player Player
	@return Promise<boolean>
]=]
function BasePermissionProvider.PromiseIsAdmin(self: BasePermissionProvider, player: Player): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	return self:PromiseIsPermissionLevel(player, PermissionLevel.ADMIN)
end

--[=[
	Returns whether the player is a creator.

	:::info
	May return false if not loaded. Prefer using the promise version.
	:::

	@param player Player
	@return boolean
]=]
function BasePermissionProvider.IsCreator(self: BasePermissionProvider, player: Player): boolean
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	return self:IsPermissionLevel(player, PermissionLevel.CREATOR)
end

--[=[
	Returns whether the player is an admin.

	:::info
	May return false if not loaded. Prefer using the promise version.
	:::

	@param player Player
	@return boolean
]=]
function BasePermissionProvider.IsAdmin(self: BasePermissionProvider, player: Player): boolean
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	return self:IsPermissionLevel(player, PermissionLevel.ADMIN)
end

function BasePermissionProvider._onServerInvoke(self: BasePermissionProvider, player: Player): boolean
	local promise = self:PromiseIsAdmin(player)
	local ok, result = promise:Yield()
	if not ok then
		warn(string.format("[BasePermissionProvider] - Failed retrieval due to %q", tostring(result)))
		return false
	end

	return result and true or false
end

return BasePermissionProvider
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="180">
                  <Properties>
                    <string name="Name">CreatorPermissionProvider</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Provides permissions from a single user creator

	@server
	@class CreatorPermissionProvider
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local BasePermissionProvider = require("BasePermissionProvider")
local PermissionLevel = require("PermissionLevel")
local PermissionLevelUtils = require("PermissionLevelUtils")
local PermissionProviderConstants = require("PermissionProviderConstants")
local PermissionProviderUtils = require("PermissionProviderUtils")
local Promise = require("Promise")

local CreatorPermissionProvider = setmetatable({}, BasePermissionProvider)
CreatorPermissionProvider.ClassName = "CreatorPermissionProvider"
CreatorPermissionProvider.__index = CreatorPermissionProvider

export type CreatorPermissionProvider = typeof(setmetatable(
	{} :: {
		_config: PermissionProviderUtils.SingleUserConfig,
		_userId: number,
	},
	{} :: typeof({ __index = CreatorPermissionProvider })
)) & BasePermissionProvider.BasePermissionProvider

--[=[
	@param config table
	@return CreatorPermissionProvider
]=]
function CreatorPermissionProvider.new(config: PermissionProviderUtils.SingleUserConfig): CreatorPermissionProvider
	local self: CreatorPermissionProvider =
		setmetatable(BasePermissionProvider.new(config) :: any, CreatorPermissionProvider)

	assert(self._config.type == PermissionProviderConstants.SINGLE_USER_CONFIG_TYPE, "Bad configType")
	self._userId = assert(self._config.userId, "No userId")

	return self
end

--[=[
	Returns whether the player is at a specific permission level.

	@param player Player
	@param permissionLevel PermissionLevel
	@return Promise<boolean>
]=]
function CreatorPermissionProvider.PromiseIsPermissionLevel(
	self: CreatorPermissionProvider,
	player: Player,
	permissionLevel: PermissionLevel.PermissionLevel
): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(PermissionLevelUtils.isPermissionLevel(permissionLevel), "Bad permissionLevel")

	if permissionLevel == PermissionLevel.ADMIN or permissionLevel == PermissionLevel.CREATOR then
		return Promise.resolved(player.UserId == self._userId or RunService:IsStudio())
	else
		error("Unknown permissionLevel")
	end
end

return CreatorPermissionProvider
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="181">
                  <Properties>
                    <string name="Name">GroupPermissionProvider</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Provides permissions from a group

	@server
	@class GroupPermissionProvider
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")

local BasePermissionProvider = require("BasePermissionProvider")
local GroupUtils = require("GroupUtils")
local PermissionLevel = require("PermissionLevel")
local PermissionLevelUtils = require("PermissionLevelUtils")
local PermissionProviderConstants = require("PermissionProviderConstants")
local PermissionProviderUtils = require("PermissionProviderUtils")
local Promise = require("Promise")

local GroupPermissionProvider = setmetatable({}, BasePermissionProvider)
GroupPermissionProvider.__index = GroupPermissionProvider
GroupPermissionProvider.ClassName = "GroupPermissionProvider"

export type GroupPermissionProvider = typeof(setmetatable(
	{} :: {
		_config: PermissionProviderUtils.GroupRankConfig,
		_groupId: number,
		_minAdminRequiredRank: number,
		_minCreatorRequiredRank: number,
		_adminsCache: { [number]: true },
		_creatorCache: { [number]: true },
		_promiseRankPromisesCache: { [number]: Promise.Promise<number> },
	},
	{} :: typeof({ __index = GroupPermissionProvider })
)) & BasePermissionProvider.BasePermissionProvider

--[=[
	@param config table
	@return GroupPermissionProvider
]=]
function GroupPermissionProvider.new(config: PermissionProviderUtils.GroupRankConfig): GroupPermissionProvider
	local self = setmetatable(BasePermissionProvider.new(config) :: any, GroupPermissionProvider)

	assert(self._config.type == PermissionProviderConstants.GROUP_RANK_CONFIG_TYPE, "Bad configType")

	self._adminsCache = {} -- [userId] = true
	self._creatorCache = {} -- [userId] = true

	self._promiseRankPromisesCache = {} -- [userId] = promise

	return self
end

--[=[
	Starts the permission provider. Should be done via ServiceBag.
]=]
function GroupPermissionProvider.Start(self: GroupPermissionProvider)
	assert(self._config, "Bad config")

	getmetatable(GroupPermissionProvider).Start(self)

	self._maid:GiveTask(Players.PlayerRemoving:Connect(function(player: Player)
		local userId = player.UserId

		self._adminsCache[userId] = nil
		self._creatorCache[userId] = nil

		local promise = self._promiseRankPromisesCache[userId]
		if promise then
			promise:Reject()
			self._promiseRankPromisesCache[userId] = nil
		end
	end))

	self._maid:GiveTask(Players.PlayerAdded:Connect(function(player)
		self:_handlePlayer(player)
	end))

	for _, player in Players:GetPlayers() do
		self:_handlePlayer(player)
	end

	return self
end

--[=[
	Returns whether the player is at a specific permission level

	@param player Player
	@param permissionLevel PermissionLevel
	@return Promise<boolean>
]=]
function GroupPermissionProvider.PromiseIsPermissionLevel(
	self: GroupPermissionProvider,
	player: Player,
	permissionLevel: PermissionLevel.PermissionLevel
): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(PermissionLevelUtils.isPermissionLevel(permissionLevel), "Bad permissionLevel")

	if permissionLevel == PermissionLevel.ADMIN then
		return self:_promiseIsAdmin(player)
	elseif permissionLevel == PermissionLevel.CREATOR then
		return self:_promiseIsCreator(player)
	else
		error("Unknown permissionLevel")
	end
end

function GroupPermissionProvider._promiseIsCreator(
	self: GroupPermissionProvider,
	player: Player
): Promise.Promise<boolean>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(player:IsDescendantOf(game), "Bad player")

	if self._creatorCache[player.UserId] then
		return Promise.resolved(true)
	end

	return self:_promiseRankInGroup(player):Then(function(rank)
		return rank >= self._config.minCreatorRequiredRank
	end)
end

function GroupPermissionProvider._promiseIsAdmin(
	self: GroupPermissionProvider,
	player: Player
): Promise.Promise<boolean>
	assert(player:IsDescendantOf(game))

	-- really not saving much time.
	if self._creatorCache[player.UserId] then
		return Promise.resolved(true)
	end

	if self._adminsCache[player.UserId] then
		return Promise.resolved(true)
	end

	return self:_promiseRankInGroup(player):Then(function(rank)
		return rank >= self._config.minAdminRequiredRank
	end)
end

function GroupPermissionProvider._handlePlayer(self: GroupPermissionProvider, player: Player): ()
	assert(player, "Bad player")

	self:_promiseRankInGroup(player):Then(function(rank)
		if rank >= self._config.minAdminRequiredRank then
			self._adminsCache[player.UserId] = true
		end

		if rank >= self._config.minCreatorRequiredRank then
			self._creatorCache[player.UserId] = true
		end
	end)
end

function GroupPermissionProvider._promiseRankInGroup(
	self: GroupPermissionProvider,
	player: Player
): Promise.Promise<number>
	assert(typeof(player) == "Instance", "Bad player")

	if self._promiseRankPromisesCache[player.UserId] then
		return self._promiseRankPromisesCache[player.UserId]
	end

	self._promiseRankPromisesCache[player.UserId] = GroupUtils.promiseRankInGroup(player, self._config.groupId)
	return self._promiseRankPromisesCache[player.UserId]
end

return GroupPermissionProvider
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="Folder" referent="182">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="183">
                <Properties>
                  <string name="Name">PermissionLevel</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class PermissionLevel
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

export type PermissionLevel = "admin" | "creator"

export type PermissionLevelMap = {
	ADMIN: "admin",
	CREATOR: "creator",
}

return Table.readonly({
	ADMIN = "admin",
	CREATOR = "creator",
} :: PermissionLevelMap)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="184">
                <Properties>
                  <string name="Name">PermissionLevelUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class PermissionLevelUtils
]=]

local require = require(script.Parent.loader).load(script)

local PermissionLevel = require("PermissionLevel")

local PermissionLevelUtils = {}

local ALLOWED = {}
for _, item in PermissionLevel do
	ALLOWED[item] = true
end

--[=[
	Returns true if a permission level
]=]
function PermissionLevelUtils.isPermissionLevel(permissionLevel: any): boolean
	return ALLOWED[permissionLevel] == true
end

return PermissionLevelUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="185">
                <Properties>
                  <string name="Name">PermissionProviderConstants</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Constants for the permission system
	@class PermissionProviderConstants
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

export type PermissionProviderConstants = {
	DEFAULT_REMOTE_FUNCTION_NAME: "PermissionProviderDefaultRemoteFunction",
	GROUP_RANK_CONFIG_TYPE: "GroupRankConfigType",
	SINGLE_USER_CONFIG_TYPE: "SingleUserConfigType",
}

return Table.readonly({
	DEFAULT_REMOTE_FUNCTION_NAME = "PermissionProviderDefaultRemoteFunction",

	-- types
	GROUP_RANK_CONFIG_TYPE = "GroupRankConfigType",
	SINGLE_USER_CONFIG_TYPE = "SingleUserConfigType",
} :: PermissionProviderConstants)
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="186">
            <Properties>
              <string name="Name">playerutils</string>
            </Properties>
            <Item class="Folder" referent="187">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="188">
                <Properties>
                  <string name="Name">PlayerUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class PlayerUtils
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

local PlayerUtils = {}

--[=[
	Human-readable version of a player name. If the player's name is the same
	as the display name, then returns that player's name. Otherwise returns
	a formatted name with the player's name like this "oot (@martxn)" which
	lets you know the username and the display name.

	Note this is not localized, although most languages should be ok. Great for
	output for dev logs and command services which are less picky.

	@param player Player
	@return string -- Formatted name
]=]
function PlayerUtils.formatName(player: Player): string
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	local name = player.Name
	local displayName = player.DisplayName

	return PlayerUtils.formatDisplayName(name, displayName)
end

--[=[
	Human-readable version of a player name. If the player's name is the same
	as the display name, then returns that player's name. Otherwise returns
	a formatted name with the player's name like this "oot (@martxn)" which
	lets you know the username and the display name.

	Note this is not localized, although most languages should be ok. Great for
	output for dev logs and command services which are less picky.

	@param name string
	@param displayName string
	@return string -- Formatted name
]=]
function PlayerUtils.formatDisplayName(name: string, displayName: string): string
	if string.lower(name) == string.lower(displayName) then
		return displayName
	else
		return string.format("%s (@%s)", displayName, name)
	end
end

export type UserInfo = {
	Username: string,
	DisplayName: string,
	HasVerifiedBadge: boolean,
}

--[=[
	Formats the display name from the user info
	@param userInfo UserInfo
	@return string
]=]
function PlayerUtils.formatDisplayNameFromUserInfo(userInfo: UserInfo): string
	assert(type(userInfo) == "table", "Bad userInfo")
	assert(type(userInfo.Username) == "string", "Bad userInfo.Username")
	assert(type(userInfo.DisplayName) == "string", "Bad userInfo.DisplayName")

	local result = PlayerUtils.formatDisplayName(userInfo.Username, userInfo.DisplayName)

	if userInfo.HasVerifiedBadge then
		return PlayerUtils.addVerifiedBadgeToName(result)
	end

	return result
end

--[=[
	Adds verified badges to the name

	@param name string
	@return string
]=]
function PlayerUtils.addVerifiedBadgeToName(name: string): string
	return string.format("%s %s", name, utf8.char(0xE000))
end

local NAME_COLORS: { Color3 } = {
	(BrickColor :: any).new("Bright red").Color,
	(BrickColor :: any).new("Bright blue").Color,
	(BrickColor :: any).new("Earth green").Color,
	(BrickColor :: any).new("Bright violet").Color,
	(BrickColor :: any).new("Bright orange").Color,
	(BrickColor :: any).new("Bright yellow").Color,
	(BrickColor :: any).new("Light reddish violet").Color,
	(BrickColor :: any).new("Brick yellow").Color,
}

local function hashName(playerName: string): number
	local value = 0
	for index = 1, #playerName do
		local cValue = string.byte(string.sub(playerName, index, index))
		local reverseIndex = #playerName - index + 1
		if #playerName % 2 == 1 then
			reverseIndex = reverseIndex - 1
		end
		if reverseIndex % 4 >= 2 then
			cValue = -cValue
		end
		value = value + cValue
	end
	return value
end

--[=[
	Retrieves the display name color for a given player (for the Roblox chat)

	@param displayName string
	@return Color3
]=]
function PlayerUtils.getDefaultNameColor(displayName: string): Color3
	return NAME_COLORS[(hashName(displayName) % #NAME_COLORS) + 1]
end

--[=[
	Calls :LoadCharacter() in a promise

	@param player Player
	@return Promise<Model>
]=]
function PlayerUtils.promiseLoadCharacter(player: Player): Promise.Promise<Model>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	return Promise.spawn(function(resolve, reject)
		local ok, err = pcall(function()
			player:LoadCharacter()
		end)
		if not ok then
			return reject(err or "Failed to load character")
		end

		return resolve()
	end)
end

--[=[
	Calls :LoadCharacterWithHumanoidDescription() in a promise

	@param player Player
	@param humanoidDescription HumanoidDescription
	@return Promise<Model>
]=]
function PlayerUtils.promiseLoadCharacterWithHumanoidDescription(
	player: Player,
	humanoidDescription: HumanoidDescription
): Promise.Promise<Model>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(
		typeof(humanoidDescription) == "Instance" and humanoidDescription:IsA("HumanoidDescription"),
		"Bad humanoidDescription"
	)

	return Promise.spawn(function(resolve, reject)
		local ok, err = pcall(function()
			player:LoadCharacterWithHumanoidDescription(humanoidDescription)
		end)
		if not ok then
			return reject(err or "Failed to load character")
		end

		return resolve()
	end)
end

return PlayerUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="189">
                <Properties>
                  <string name="Name">RxPlayerUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utilities for observing players
	@class RxPlayerUtils
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")
local RxInstanceUtils = require("RxInstanceUtils")

local RxPlayerUtils = {}

--[=[
	Observe players for the lifetime they exist
	@param predicate ((Player) -> boolean)?
	@return Observable<Brio<Player>>
]=]
function RxPlayerUtils.observePlayersBrio(predicate: Rx.Predicate<Player>?): Observable.Observable<Brio.Brio<Player>>
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate!")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handlePlayer(player: Player)
			if predicate == nil or predicate(player) then
				local brio = Brio.new(player)
				maid[player] = brio

				sub:Fire(brio)
			end
		end

		maid:GiveTask(Players.PlayerAdded:Connect(handlePlayer))

		maid:GiveTask(Players.PlayerRemoving:Connect(function(player)
			maid[player] = nil
		end))

		for _, player in Players:GetPlayers() do
			task.spawn(function()
				handlePlayer(player)
			end)
		end

		return maid
	end) :: any
end

--[=[
	Observes the current local player

	@return Observable<Brio<Player>>
]=]
function RxPlayerUtils.observeLocalPlayerBrio(): Observable.Observable<Brio.Brio<Player>>
	return RxInstanceUtils.observePropertyBrio(Players, "LocalPlayer", function(value)
		return value ~= nil
	end)
end

--[=[
	Observe players as they're added, and as they are.
	@param predicate ((Player) -> boolean)?
	@return Observable<Player>
]=]
function RxPlayerUtils.observePlayers(predicate: Rx.Predicate<Player>?): Observable.Observable<Player>
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handlePlayer(player: Player)
			if predicate == nil or predicate(player) then
				sub:Fire(player)
			end
		end

		maid:GiveTask(Players.PlayerAdded:Connect(handlePlayer))

		for _, player in Players:GetPlayers() do
			task.spawn(function()
				handlePlayer(player)
			end)
		end

		return maid
	end) :: any
end

--[=[
	Observes the first time the character appearance is loaded

	@param player Player
	@return Observable<()>
]=]
function RxPlayerUtils.observeFirstAppearanceLoaded(player: Player): Observable.Observable<()>
	assert(typeof(player) == "Instance", "Bad player")

	return Observable.new(function(sub)
		if player:HasAppearanceLoaded() then
			sub:Fire()
			sub:Complete()
			return
		end

		local maid = Maid.new()

		-- In case this works
		maid:GiveTask(player.CharacterAppearanceLoaded:Connect(function()
			sub:Fire()
			sub:Complete()
		end))

		maid:GiveTask(task.spawn(function()
			while not player:HasAppearanceLoaded() and player:IsDescendantOf(game) do
				task.wait(0.05)
			end

			if player:HasAppearanceLoaded() then
				sub:Fire()
				sub:Complete()
			else
				sub:Fail("Failed to load appearance before player left the game")
			end
		end))

		return maid
	end)
end

return RxPlayerUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="190">
            <Properties>
              <string name="Name">promise</string>
            </Properties>
            <Item class="Folder" referent="191">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="192">
                <Properties>
                  <string name="Name">Promise</string>
                  <string name="Source"><![CDATA[--!nocheck
--[=[
	Promises, but without error handling as this screws with stack traces, using Roblox signals

	See: https://promisesaplus.com/

	@class Promise
]=]

local HttpService = game:GetService("HttpService")

-- Turns out debug.traceback() is slow
local ENABLE_TRACEBACK = false
local _emptyRejectedPromise = nil
local _emptyFulfilledPromise = nil
local EMPTY_PACKED_TUPLE = table.freeze({ n = 0 })

local Promise = {}
Promise.ClassName = "Promise"
Promise.__index = Promise

export type Resolve<T...> = (T...) -> ()
export type Reject = (...any) -> ()
export type ResolveReject<T...> = (Resolve<T...>, Reject) -> ()

export type Promise<T...> = typeof(setmetatable(
	{} :: {
		_fulfilled: any?,
		_rejected: any?,
		_unconsumedException: boolean,
		_pendingExecuteList: { any }?,
		_source: string,
	},
	{} :: typeof({ __index = Promise })
))

--[=[
	Determines whether a value is a promise or not.

	@param value any
	@return boolean
]=]
function Promise.isPromise(value: any): boolean
	return type(value) == "table" and value.ClassName == "Promise"
end

--[=[
	Constructs a new promise.

	::warning
	Do not yield within this func callback, as it will yield on the
	main thread. This is a performance optimization.
	::

	@param func (resolve: (...) -> (), reject: (...) -> ()) -> ()?
	@return Promise<T...>
]=]
function Promise.new<T...>(func: ResolveReject<T...>?): Promise<T...>
	local self = setmetatable({
		_pendingExecuteList = {},
		_unconsumedException = true,
		_source = ENABLE_TRACEBACK and debug.traceback("Promise.new()", 2) or "",
	}, Promise)

	if type(func) == "function" then
		func(self:_getResolveReject())
	end

	return self
end

--[=[
	Initializes a new promise with the given function in a spawn wrapper.

	@param func (resolve: (...) -> (), reject: (...) -> ()) -> ()?
	@return Promise<T...>
]=]
function Promise.spawn<T...>(func: ResolveReject<T...>): Promise<T...>
	local self = Promise.new()

	task.spawn(func, self:_getResolveReject())

	return self
end

--[=[
	Initializes a new promise with the given function in a delay wrapper.

	@param seconds number
	@param func (resolve: (...) -> (), reject: (...) -> ()) -> ()?
	@return Promise<T...>
]=]
function Promise.delay<T...>(seconds: number, func: ResolveReject<T...>): Promise<T...>
	assert(type(seconds) == "number", "Bad seconds")
	assert(type(func) == "function", "Bad func")

	local self = Promise.new()

	task.delay(seconds, func, self:_getResolveReject())

	return self
end

--[=[
	Initializes a new promise with the given function in a deferred wrapper.

	@param func (resolve: (...) -> (), reject: (...) -> ()) -> ()?
	@return Promise<T...>
]=]
function Promise.defer<T...>(func: ResolveReject<T...>): Promise<T...>
	local self = Promise.new()

	-- Just the function part of the resolve/reject protocol!
	task.defer(func, self:_getResolveReject())

	return self
end

--[=[
	Returns a resolved promise with the following values

	@param ... Values to resolve to
	@return Promise<T...>
]=]
function Promise.resolved<T...>(...: T...): Promise<T...>
	local n = select("#", ...)
	if n == 0 then
		-- Reuse promise here to save on calls to Promise.resolved()
		return _emptyFulfilledPromise
	elseif n == 1 and Promise.isPromise(...) then
		local promise = (...)

		-- Resolving to promise that is already resolved. Just return the promise!
		if not promise._pendingExecuteList then
			return promise
		end
	end

	local promise = Promise.new()
	promise:Resolve(...)
	return promise
end

--[=[
	Returns a rejected promise with the following values

	@param ... Values to reject to
	@return Promise<T...>
]=]
function Promise.rejected<T...>(...): Promise<()>
	local n = select("#", ...)
	if n == 0 then
		-- Reuse promise here to save on calls to Promise.rejected()
		return _emptyRejectedPromise
	end

	local promise = Promise.new()
	promise:_reject(table.pack(...))
	return promise
end

--[=[
	Returns whether or not the promise is pending

	@return bool -- True if pending, false otherwise
]=]
function Promise.IsPending<T...>(self: Promise<T...>): boolean
	return self._pendingExecuteList ~= nil
end

--[=[
	Returns whether or not the promise is fulfilled

	@return bool -- True if fulfilled
]=]
function Promise.IsFulfilled<T...>(self: Promise<T...>): boolean
	return self._fulfilled ~= nil
end

--[=[
	Returns whether or not the promise is rejected

	@return bool -- True if rejected
]=]
function Promise.IsRejected<T...>(self: Promise<T...>): boolean
	return self._rejected ~= nil
end

--[=[
	Yields until the promise is complete, and errors if an error
	exists, otherwise returns the fulfilled results.

	@yields
	@return T
]=]
function Promise.Wait<T...>(self: Promise<T...>): T...
	if self._fulfilled then
		return table.unpack(self._fulfilled, 1, self._fulfilled.n)
	elseif self._rejected then
		error(tostring(self._rejected[1]), 2)
	else
		local waitingCoroutine = coroutine.running()

		self:Then(function()
			task.spawn(waitingCoroutine)
		end, function()
			task.spawn(waitingCoroutine)
		end)

		coroutine.yield()

		if self._rejected then
			error(tostring(self._rejected[1]), 2)
		elseif self._fulfilled then
			return table.unpack(self._fulfilled, 1, self._fulfilled.n)
		else
			error("Bad state")
		end
	end
end

--[=[
	Yields until the promise is complete, then returns a boolean indicating
	the result, followed by the values from the promise.

	@yields
	@return boolean, T
]=]
function Promise.Yield<T...>(self: Promise<T...>): (boolean, T...)
	if self._fulfilled then
		return true, table.unpack(self._fulfilled, 1, self._fulfilled.n)
	elseif self._rejected then
		return false, table.unpack(self._rejected, 1, self._rejected.n)
	else
		local waitingCoroutine = coroutine.running()

		self:Then(function()
			task.spawn(waitingCoroutine)
		end, function()
			task.spawn(waitingCoroutine)
		end)

		coroutine.yield()

		if self._fulfilled then
			return true, table.unpack(self._fulfilled, 1, self._fulfilled.n)
		elseif self._rejected then
			return false, table.unpack(self._rejected, 1, self._rejected.n)
		else
			error("Bad state")
		end
	end
end

--[=[
	Promise resolution procedure, resolves the given values

	@param ... T
]=]
function Promise:Resolve<T...>(...: T...)
	if not self._pendingExecuteList then
		return
	end

	local len = select("#", ...)
	if len == 0 then
		self:_fulfill(EMPTY_PACKED_TUPLE)
	elseif self == (...) then
		self:Reject("TypeError: Resolved to self")
	elseif Promise.isPromise(...) then
		if len > 1 then
			local message =
				string.format("When resolving a promise, extra arguments are discarded! See:\n\n%s", self._source)
			warn(message)
		end

		local promise2 = (...)
		if promise2._pendingExecuteList then -- pending
			promise2._unconsumedException = false
			promise2._pendingExecuteList[#promise2._pendingExecuteList + 1] = {
				function(...)
					self:Resolve(...)
				end,
				function(...)
					-- Still need to verify at this point that we're pending!
					if self._pendingExecuteList then
						self:_reject(table.pack(...))
					end
				end,
			}
		elseif promise2._rejected then -- rejected
			promise2._unconsumedException = false
			self:_reject(promise2._rejected)
		elseif promise2._fulfilled then -- fulfilled
			self:_fulfill(promise2._fulfilled)
		else
			error("[Promise.Resolve] - Bad promise2 state")
		end
	elseif type(...) == "function" then
		if len > 1 then
			local message =
				string.format("When resolving a function, extra arguments are discarded! See:\n\n%s", self._source)
			warn(message)
		end

		local func = ...
		func(self:_getResolveReject())
	else
		-- TODO: Handle thenable promises!
		-- Problem: Lua has :andThen() and also :Then() as two methods in promise
		-- implementations.
		self:_fulfill(table.pack(...))
	end
end

--[[
	Fulfills the promise with the value
	@param values { T } -- Params to fulfil with
	@private
]]
function Promise._fulfill<T...>(self: Promise<T...>, values)
	if not self._pendingExecuteList then
		return
	end

	self._fulfilled = values

	local list = self._pendingExecuteList
	self._pendingExecuteList = nil
	for _, data in list do
		self:_executeThen(unpack(data))
	end
end

--[=[
	Rejects the promise with the values given
	@param ... T -- Params to reject with
]=]
function Promise.Reject<T...>(self: Promise<T...>, ...)
	self:_reject(table.pack(...))
end

function Promise._reject<T...>(self: Promise<T...>, values)
	if not self._pendingExecuteList then
		return
	end

	self._rejected = values

	local list = self._pendingExecuteList
	self._pendingExecuteList = nil
	for _, data in list do
		self:_executeThen(unpack(data))
	end

	-- Check for uncaught exceptions
	if self._unconsumedException and self._rejected.n > 0 then
		task.defer(function()
			-- Yield to end of frame, giving control back to Roblox.
			-- This is the equivalent of giving something back to a task manager.
			if self._unconsumedException then
				local errOutput = self:_toHumanReadable(values[1])

				if ENABLE_TRACEBACK then
					warn(
						string.format("[Promise] - Uncaught exception in promise\n\n%q\n\n%s", errOutput, self._source)
					)
				else
					warn(string.format("[Promise] - Uncaught exception in promise: %q", errOutput))
				end
			end
		end)
	end
end

function Promise._toHumanReadable<T...>(_self: Promise<T...>, data: any): string
	if type(data) == "table" then
		local errOutput
		local ok = pcall(function()
			errOutput = HttpService:JSONEncode(data)
		end)
		if not ok then
			errOutput = tostring(data)
		end
		return errOutput
	else
		return tostring(data)
	end
end

--[=[
	Handlers if/when promise is fulfilled/rejected. It takes up to two arguments, callback functions
	for the success and failure cases of the Promise. May return the same promise if certain behavior
	is met.

	:::info
	We do not comply with 2.2.4 (onFulfilled or onRejected must not be called until the execution context stack
	contains only platform code). This means promises may stack overflow, however, it also makes promises a lot cheaper
	:::

	If/when promise is rejected, all respective onRejected callbacks must execute in the order of their
	originating calls to then.

	If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their
	originating calls to then.

	@param onFulfilled function -- Called if/when fulfilled with parameters
	@param onRejected function -- Called if/when rejected with parameters
	@return Promise<T...>
]=]
function Promise.Then<T...>(self: Promise<T...>, onFulfilled: ((T...) -> any...)?, onRejected: ((...any) -> any...)?)
	if type(onRejected) == "function" then
		self._unconsumedException = false
	end

	if self._pendingExecuteList then
		local promise = Promise.new()
		self._pendingExecuteList[#self._pendingExecuteList + 1] = { onFulfilled, onRejected, promise }
		return promise
	else
		return self:_executeThen(onFulfilled, onRejected, nil)
	end
end

--[=[
	Like then, but the value passed down the chain is the resolved value of the promise, not
	the value returned from onFulfilled or onRejected

	Will still yield for the result if a promise is returned, but will discard the result.

	@param onFulfilled function
	@param onRejected function
	@return Promise<T...> -- Returns self
]=]
function Promise.Tap<T...>(self: Promise<T...>, onFulfilled, onRejected)
	-- Run immediately like then, but we return something safer!
	local result = self:Then(onFulfilled, onRejected)
	if result == self then
		return result
	end

	-- Most of the time we can just return the same
	-- promise. But sometimes we need to yield
	-- for the result to finish, and then resolve that result to a new result
	if result._fulfilled then
		return self
	elseif result._rejected then
		return self
	elseif result._pendingExecuteList then
		-- Definitely the most expensive case, might be able to make this better over time
		local function returnSelf()
			return self
		end

		return result:Then(returnSelf, returnSelf)
	else
		error("Bad result state")
	end
end

--[=[
	Executes upon pending stop

	@param func function
	@return Promise<T...>
]=]
function Promise.Finally<T...>(self: Promise<T...>, func)
	return self:Then(func, func)
end

--[=[
	Catch errors from the promise

	@param onRejected function
	@return Promise<T...>
]=]
function Promise.Catch<T...>(self: Promise<T...>, onRejected)
	return self:Then(nil, onRejected)
end

--[=[
	Rejects the current promise. Utility left for Maid task
]=]
function Promise.Destroy<T...>(self: Promise<T...>)
	self:_reject(EMPTY_PACKED_TUPLE)
end

--[=[
	Returns the results from the promise.

	:::warning
	This API surface will error if the promise is still pending.
	:::

	@return boolean -- true if resolved, false otherwise.
	@return any
]=]
function Promise.GetResults<T...>(self: Promise<T...>): (boolean, T...)
	if self._rejected then
		return false, table.unpack(self._rejected, 1, self._rejected.n)
	elseif self._fulfilled then
		return true, table.unpack(self._fulfilled, 1, self._fulfilled.n)
	else
		error("Still pending")
	end
end

function Promise._getResolveReject<T...>(self: Promise<T...>): (Resolve<T...>, Reject)
	return function(...)
		self:Resolve(...)
	end, function(...)
		self:_reject(table.pack(...))
	end
end

--[=[
	@private

	@param onFulfilled function?
	@param onRejected function?
	@param promise2 Promise<T...>? -- May be nil. If it is, then we have the option to return self
	@return Promise
]=]
function Promise._executeThen<T...>(self: Promise<T...>, onFulfilled, onRejected, promise2)
	if self._fulfilled then
		if type(onFulfilled) == "function" then
			-- If either onFulfilled or onRejected returns a value x, run
			-- the Promise Resolution Procedure [[Resolve]](promise2, x).
			if promise2 then
				promise2:Resolve(onFulfilled(table.unpack(self._fulfilled, 1, self._fulfilled.n)))
				return promise2
			else
				local results = table.pack(onFulfilled(table.unpack(self._fulfilled, 1, self._fulfilled.n)))
				if results.n == 0 then
					return _emptyFulfilledPromise
				elseif results.n == 1 and Promise.isPromise(results[1]) then
					return results[1]
				else
					local promise = Promise.new()
					-- Technically undefined behavior from A+, but we'll resolve to nil like ES6 promises
					promise:Resolve(table.unpack(results, 1, results.n))
					return promise
				end
			end
		else
			-- If onFulfilled is not a function, it must be ignored.
			-- If onFulfilled is not a function and promise1 is fulfilled,
			-- promise2 must be fulfilled with the same value as promise1.
			if promise2 then
				promise2:_fulfill(self._fulfilled)
				return promise2
			else
				return self
			end
		end
	elseif self._rejected then
		if type(onRejected) == "function" then
			-- If either onFulfilled or onRejected returns a value x, run
			-- the Promise Resolution Procedure [[Resolve]](promise2, x).
			if promise2 then
				promise2:Resolve(onRejected(table.unpack(self._rejected, 1, self._rejected.n)))
				return promise2
			else
				local results = table.pack(onRejected(table.unpack(self._rejected, 1, self._rejected.n)))
				if results.n == 0 then
					return _emptyFulfilledPromise
				elseif results.n == 1 and Promise.isPromise(results[1]) then
					return results[1]
				else
					local promise = Promise.new()
					-- Technically undefined behavior from A+, but we'll resolve to nil like ES6 promises
					promise:Resolve(table.unpack(results, 1, results.n))
					return promise
				end
			end
		else
			-- If onRejected is not a function, it must be ignored.
			-- If onRejected is not a function and promise1 is rejected, promise2 must be
			-- rejected with the same reason as promise1.
			if promise2 then
				promise2:_reject(self._rejected)

				return promise2
			else
				return self
			end
		end
	else
		error("Internal error: still pending")
	end
end

-- Initialize promise values
_emptyFulfilledPromise = Promise.new()
_emptyFulfilledPromise:_fulfill(EMPTY_PACKED_TUPLE)

_emptyRejectedPromise = Promise.new()
_emptyRejectedPromise:_reject(EMPTY_PACKED_TUPLE)

return Promise
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="193">
                <Properties>
                  <string name="Name">PromiseRetryUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class PromiseRetryUtils
]=]

local require = require(script.Parent.loader).load(script)

local Math = require("Math")
local Promise = require("Promise")

local PromiseRetryUtils = {}

export type RetryOptions = {
	initialWaitTime: number,
	maxAttempts: number,
	printWarning: boolean,
}

--[=[
	Returns a promise that will retry the given callback until it succeeds or the max attempts
	is reached.

	@param callback function -- Callback that returns a promise
	@param options RetryOptions -- Options for retrying
	@return Promise<T>
]=]
function PromiseRetryUtils.retry<T...>(callback: () -> Promise.Promise<T...>, options: RetryOptions): Promise.Promise<T...>
	assert(type(options.initialWaitTime) == "number", "Bad initialWaitTime")
	assert(type(options.maxAttempts) == "number", "Bad maxAttempts")
	assert(type(options.printWarning) == "boolean", "Bad printWarning")
	assert(options.maxAttempts >= 1, "Bad maxAttempts")

	local promise = Promise.new()
	local isLoopResolved = false

	local running = task.spawn(function()
		local waitTime = options.initialWaitTime
		local lastResults

		for attemptNumber = 1, options.maxAttempts do
			lastResults = table.pack(callback():Yield())

			if lastResults[1] then
				isLoopResolved = true
				promise:Resolve(table.unpack(lastResults, 2, lastResults.n))
				return
			end

			if options.printWarning then
				warn(
					string.format(
						"[PromiseRetryUtils] - Retrying %d/%d due to failure %q",
						attemptNumber,
						options.maxAttempts,
						tostring(lastResults[2])
					)
				)
			end

			task.wait(Math.jitter(waitTime * 2 ^ attemptNumber))
		end

		isLoopResolved = true
		local errorMessage = string.format(
			"Attempted request %d times before failing with error %s",
			options.maxAttempts,
			tostring(lastResults[2])
		)
		promise:Reject(errorMessage, table.unpack(lastResults, 3, lastResults.n))
	end)

	-- Esnure cleanup, but only when we're out of here
	promise:Finally(function()
		if not isLoopResolved then
			task.cancel(running)
		end
	end)

	return promise
end

return PromiseRetryUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="194">
                <Properties>
                  <string name="Name">PromiseUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility methods for promise
	@class PromiseUtils
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")
local Signal = require("Signal")

local PromiseUtils = {}

--[=[
	Returns the value of the first promise resolved
	@param promises { Promise<T> }
	@return Promise<T> -- Promise that resolves with first result
]=]
function PromiseUtils.any<T...>(promises: { Promise.Promise<T...> }): Promise.Promise<T...>
	local returnPromise = Promise.new()

	local function resolve(...)
		returnPromise:Resolve(...)
	end

	local function reject(...)
		returnPromise:Reject(...)
	end

	for _, promise: any in promises do
		promise:Then(resolve, reject)
	end

	return returnPromise
end

--[=[
	Returns a promise that will resolve after the set amount of seconds

	@param seconds number
	@return Promise
]=]
function PromiseUtils.delayed(seconds: number): Promise.Promise<()>
	assert(type(seconds) == "number", "Bad seconds")

	return Promise.delay(seconds, function(resolve, _reject)
		resolve()
	end)
end

--[=[
	Executes all promises. If any fails, the result will be rejected. However, it yields until
	every promise is complete.

	:::warning
	Passing in a spare array (i.e. {nil, promise}) will result in undefined behavior here.
	:::

	@param promises { Promise<T> }
	@return Promise<T>
]=]
function PromiseUtils.all<T>(promises: { Promise.Promise<T> }): Promise.Promise<T>
	if #promises == 0 then
		return Promise.resolved()
	elseif #promises == 1 then
		return promises[1]
	end

	local remainingCount = #promises
	local returnPromise: Promise.Promise<T> = Promise.new()
	local results = {}
	local allFulfilled = true

	local function syncronize(index: number, isFullfilled: boolean)
		return function(value)
			allFulfilled = allFulfilled and isFullfilled
			results[index] = value
			remainingCount = remainingCount - 1
			if remainingCount == 0 then
				local method = allFulfilled and "Resolve" or "Reject"
				returnPromise[method](returnPromise, unpack(results, 1, #promises))
			end
		end
	end

	for index, promise: any in promises do
		promise:Then(syncronize(index, true), syncronize(index, false))
	end

	return returnPromise
end

--[=[
	Keeps on trying promises until one of them succeeds, or reports
	the last failure.

	@param promises { Promise<T> }
]=]
function PromiseUtils.firstSuccessOrLastFailure<T...>(promises: { Promise.Promise<T...> }): Promise.Promise<T...>
	if #promises == 0 then
		return Promise.resolved()
	elseif #promises == 1 then
		return promises[1]
	end

	local remainingCount: number = #promises
	local returnPromise: Promise.Promise<T...> = Promise.new()

	local function syncronize(isFullfilled)
		return function(...)
			remainingCount = remainingCount - 1

			if isFullfilled then
				return returnPromise:Resolve(...)
			end

			if remainingCount == 0 then
				return returnPromise:Reject(...)
			end

			return
		end
	end

	for _, promise: any in promises do
		promise:Then(syncronize(true), syncronize(false))
	end

	return returnPromise
end

--[=[
	Combines the result of promises together

	@param stateTable any
	@return Promise<any>
]=]
function PromiseUtils.combine(stateTable: any): Promise.Promise<any>
	assert(type(stateTable) == "table", "Bad stateTable")

	local remainingCount = 0
	local results = {}

	for key, value in stateTable do
		if Promise.isPromise(value) then
			remainingCount = remainingCount + 1
		else
			results[key] = value
		end
	end

	if remainingCount == 0 then
		return Promise.resolved(stateTable)
	end

	local returnPromise = Promise.new()
	local allFulfilled = true

	local function syncronize(key, isFullfilled)
		return function(value)
			allFulfilled = allFulfilled and isFullfilled
			results[key] = value
			remainingCount = remainingCount - 1

			if remainingCount == 0 then
				local method = allFulfilled and "Resolve" or "Reject"
				returnPromise[method](returnPromise, results)
			end
		end
	end

	for key, value in stateTable do
		if Promise.isPromise(value) then
			value:Then(syncronize(key, true), syncronize(key, false))
		end
	end

	return returnPromise
end

--[=[
	Inverts the result of a promise, turning a resolved promise
	into a rejected one, and a rejected one into a resolved one.

	@param promise Promise<T>
	@return Promise<T>
]=]
function PromiseUtils.invert<T...>(promise: Promise.Promise<T...>): Promise.Promise<T...>
	if promise:IsPending() then
		return promise:Then(function(...)
			return Promise.rejected(...)
		end, function(...)
			return Promise.resolved(...)
		end)
	else
		local results = { promise:GetResults() }
		if results[1] then
			return Promise.rejected(unpack(results, 2))
		else
			return Promise.resolved(unpack(results, 2))
		end
	end
end

--[=[
	Creates a promise from a signal

	@param signal Signal<T>
	@return Promise<T>
]=]
function PromiseUtils.fromSignal<T...>(signal: Signal.Signal<T...>): Promise.Promise<T...>
	local promise = Promise.new()
	local conn: Signal.Connection<T...>?

	promise:Finally(function()
		if conn then
			conn:Disconnect()
		end
		conn = nil
	end)

	conn = signal:Connect(function(...)
		promise:Resolve(...)
	end)

	return promise
end

--[=[
	Creates a new promise from the given promise that will
	reject after the given `timeoutTime`

	@param timeoutTime number
	@param fromPromise Promise<T>
	@return Promise<T>
]=]
function PromiseUtils.timeout<T...>(timeoutTime: number, fromPromise: Promise.Promise<T...>): Promise.Promise<T...>
	assert(type(timeoutTime) == "number", "Bad timeoutTime")
	assert(fromPromise, "Bad fromPromise")

	if not fromPromise:IsPending() then
		return fromPromise
	end

	local promise = Promise.new()

	promise:Resolve(fromPromise)

	task.delay(timeoutTime, function()
		promise:Reject()
	end)

	return promise
end

return PromiseUtils
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="195">
                <Properties>
                  <string name="Name">Utility</string>
                </Properties>
                <Item class="ModuleScript" referent="196">
                  <Properties>
                    <string name="Name">PendingPromiseTracker</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Tracks pending promises
	@class PendingPromiseTracker
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

local PendingPromiseTracker = {}
PendingPromiseTracker.ClassName = "PendingPromiseTracker"
PendingPromiseTracker.__index = PendingPromiseTracker

export type PendingPromiseTracker<T...> = typeof(setmetatable(
	{} :: {
		_pendingPromises: { [Promise.Promise<T...>]: true },
	},
	{} :: typeof({ __index = PendingPromiseTracker })
))

--[=[
	Returns a new pending promise tracker

	@return PendingPromiseTracker<T>
]=]
function PendingPromiseTracker.new<T...>(): PendingPromiseTracker<T...>
	local self = setmetatable({}, PendingPromiseTracker)

	self._pendingPromises = {}

	return self
end

--[=[
	Adds a new promise to the tracker. If it's not pending it will not add.
]=]
function PendingPromiseTracker.Add<T...>(self: PendingPromiseTracker<T...>, promise: Promise.Promise<T...>)
	if promise:IsPending() then
		self._pendingPromises[promise] = true
		promise:Finally(function()
			self._pendingPromises[promise] = nil
		end)
	end
end

--[=[
	Gets all of the promises that are pending
]=]
function PendingPromiseTracker.GetAll<T...>(self: PendingPromiseTracker<T...>): { Promise.Promise<T...> }
	local promises: { Promise.Promise<T...> } = {}
	for promise: any, _ in self._pendingPromises do
		table.insert(promises, promise)
	end
	return promises
end

return PendingPromiseTracker
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="197">
                  <Properties>
                    <string name="Name">PromiseInstanceUtils</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	@class PromiseInstanceUtils
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Promise = require("Promise")

local PromiseInstanceUtils = {}

--[=[
	Promise that resolves when an instance is removed

	@param instance Instance
	@return Promise
]=]
function PromiseInstanceUtils.promiseRemoved(instance: Instance): Promise.Promise<()>
	assert(instance:IsDescendantOf(game))

	local maid = Maid.new()
	local promise = Promise.new()

	maid:GiveTask(instance.AncestryChanged:Connect(function(_, parent)
		if not parent then
			promise:Resolve()
		end
	end))

	promise:Finally(function()
		maid:DoCleaning()
	end)

	return promise
end

return PromiseInstanceUtils
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="198">
                  <Properties>
                    <string name="Name">promiseChild</string>
                    <string name="Source"><![CDATA[--[=[
	Warps the WaitForChild API with a promise
	@class promiseChild
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

--[=[
	Wraps the :WaitForChild API with a promise

	@function promiseChild
	@param parent Instance
	@param name string
	@param timeOut number?
	@return Promise<Instance>
	@within promiseChild
]=]
return function(parent: Instance, name: string, timeOut: number?): Promise.Promise<Instance>
	local result = parent:FindFirstChild(name)
	if result then
		return Promise.resolved(result)
	end

	return Promise.spawn(function(resolve, reject)
		local child: Instance?
		if timeOut then
			child = parent:WaitForChild(name, timeOut)
		else
			child = parent:WaitForChild(name)
		end

		if child then
			resolve(child)
		else
			reject("Timed out")
		end
	end)
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="199">
                  <Properties>
                    <string name="Name">promisePropertyValue</string>
                    <string name="Source"><![CDATA[--[=[
	Promises a property value
	@class promisePropertyValue
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

--[=[
	Promise that resolves when the property value is truthy.

	:::warning
	To use properly please make sure to reject the promise for proper GC if the object requiring
	:::

	@function promisePropertyValue
	@param instance Instance
	@param propertyName string
	@return Promise<Instance>
	@within promisePropertyValue
]=]
return function(instance: Instance, propertyName: string)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(propertyName) == "string", "Bad propertyName")

	local result = instance[propertyName]
	if result then
		return Promise.resolved(result)
	end

	local promise = Promise.new()

	local conn
	promise:Finally(function()
		if conn then
			conn:Disconnect()
		end
	end)

	conn = instance:GetPropertyChangedSignal(propertyName):Connect(function()
		if instance[propertyName] then
			promise:Resolve(instance[propertyName])
		end
	end)

	return promise
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="200">
                  <Properties>
                    <string name="Name">promiseWait</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Wraps the task.delay() API in a promise

	@class promiseWait
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

return function(time: number): Promise.Promise<()>
	return Promise.new(function(resolve, _)
		task.delay(time, function()
			resolve()
		end)
	end)
end
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="201">
            <Properties>
              <string name="Name">promisemaid</string>
            </Properties>
            <Item class="Folder" referent="202">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="203">
                <Properties>
                  <string name="Name">PromiseMaidUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Helper functions for maids and promises

	@class PromiseMaidUtils
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Promise = require("Promise")

local PromiseMaidUtils = {}

--[=[
	Calls the callback with a maid for the lifetime of the promise.
]=]
function PromiseMaidUtils.whilePromise<T...>(promise: Promise.Promise<T...>, callback: (Maid.Maid) -> ()): Maid.Maid
	assert(Promise.isPromise(promise), "Bad promise")
	assert(type(callback) == "function", "Bad callback")

	local maid = Maid.new()

	if not promise:IsPending() then
		return maid
	end

	promise:Finally(function()
		maid:DoCleaning()
	end)

	callback(maid)

	-- Cleanup immediately if the callback resolves the promise immeidately
	if not promise:IsPending() then
		maid:DoCleaning()
	end

	return maid
end

return PromiseMaidUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="204">
            <Properties>
              <string name="Name">pseudolocalize</string>
            </Properties>
            <Item class="Folder" referent="205">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="206">
                <Properties>
                  <string name="Name">PseudoLocalize</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
    Pseudo localizes text. Useful for verifying translation without having
    actual translations available

    @class PseudoLocalize
]=]

local PseudoLocalize = {}

local DEFAULT_PSEUDO_LOCALE_ID = "qlp-pls"

--[=[
    Translates a line into pseudo text while maintaining params
    @param line string -- The line to translate
    @return string -- The translated line
]=]
function PseudoLocalize.pseudoLocalize(line: string): string
	local charMap = PseudoLocalize.PSEUDO_CHARACTER_MAP
	local out = ""
	local isParam = false

	for start, stop in utf8.graphemes(line) do
		local char = string.sub(line, start, stop)
		if char == "{" or char == "[" or char == "<" then
			isParam = true
			out ..= char
		elseif char == "}" or char == "]" or char == ">" then
			isParam = false
			out ..= char
		elseif not isParam and charMap[char] then
			out ..= charMap[char]
		else
			out ..= char
		end
	end

	return out
end

--[=[
    Gets the default pseudo locale string.
    @return string
]=]
function PseudoLocalize.getDefaultPseudoLocaleId(): string
	return DEFAULT_PSEUDO_LOCALE_ID
end

--[=[
    Parses a localization table and adds a pseudo localized locale to the table.

    @param localizationTable LocalizationTable -- LocalizationTable to add to.
    @param preferredLocaleId string? -- Preferred locale to use. Defaults to "qlp-pls"
    @param preferredFromLocale string? -- Preferred from locale. Defaults to "en-us"
    @return string -- The translated line
]=]
function PseudoLocalize.addToLocalizationTable(
	localizationTable: LocalizationTable,
	preferredLocaleId: string?,
	preferredFromLocale: string?
)
	local localeId = preferredLocaleId or DEFAULT_PSEUDO_LOCALE_ID
	local fromLocale = preferredFromLocale or "en"

	local entries = localizationTable:GetEntries()
	for _, entry in entries do
		if not entry.Values[localeId] then
			local line = entry.Values[fromLocale]
			if type(line) == "string" then
				entry.Values[localeId] = PseudoLocalize.pseudoLocalize(line)
			else
				warn(
					string.format(
						"[PseudoLocalize.addToLocalizationTable] - No entry in key %q for locale %q",
						entry.Key,
						fromLocale
					)
				)
			end
		end
	end

	localizationTable:SetEntries(entries)
end

--[=[
    Mapping of English characters to pseudo localized characters.

    @prop PSEUDO_CHARACTER_MAP { [string]: string }
    @within PseudoLocalize
]=]
PseudoLocalize.PSEUDO_CHARACTER_MAP = {
	["a"] = "á",
	["b"] = "β",
	["c"] = "ç",
	["d"] = "δ",
	["e"] = "è",
	["f"] = "ƒ",
	["g"] = "ϱ",
	["h"] = "λ",
	["i"] = "ï",
	["j"] = "J",
	["k"] = "ƙ",
	["l"] = "ℓ",
	["m"] = "₥",
	["n"] = "ñ",
	["o"] = "ô",
	["p"] = "ƥ",
	["q"] = "9",
	["r"] = "ř",
	["s"] = "ƨ",
	["t"] = "ƭ",
	["u"] = "ú",
	["v"] = "Ʋ",
	["w"] = "ω",
	["x"] = "ж",
	["y"] = "¥",
	["z"] = "ƺ",
	["A"] = "Â",
	["B"] = "ß",
	["C"] = "Ç",
	["D"] = "Ð",
	["E"] = "É",
	["F"] = "F",
	["G"] = "G",
	["H"] = "H",
	["I"] = "Ì",
	["J"] = "J",
	["K"] = "K",
	["L"] = "£",
	["M"] = "M",
	["N"] = "N",
	["O"] = "Ó",
	["P"] = "Þ",
	["Q"] = "Q",
	["R"] = "R",
	["S"] = "§",
	["T"] = "T",
	["U"] = "Û",
	["V"] = "V",
	["W"] = "W",
	["X"] = "X",
	["Y"] = "Ý",
	["Z"] = "Z",
}

return PseudoLocalize
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="207">
            <Properties>
              <string name="Name">remotefunctionutils</string>
            </Properties>
            <Item class="Folder" referent="208">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="209">
                <Properties>
                  <string name="Name">RemoteFunctionUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions to wrap invoking a remote function with a promise
	@class RemoteFunctionUtils
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

local RemoteFunctionUtils = {}

--[=[
	Invokes the server with the remote function call.
	@param remoteFunction RemoteFunction
	@param ... any
	@return Promise<T>
]=]
function RemoteFunctionUtils.promiseInvokeServer(remoteFunction: RemoteFunction, ...): Promise.Promise<any>
	assert(typeof(remoteFunction) == "Instance" and remoteFunction:IsA("RemoteFunction"), "Bad remoteFunction")

	local args = table.pack(...)

	return Promise.spawn(function(resolve, reject)
		local results
		local ok, err = pcall(function()
			results = table.pack(remoteFunction:InvokeServer(table.unpack(args, 1, args.n)))
		end)

		if not ok then
			return reject(err or "Failed to invoke server from RemoteFunction")
		end

		if not results then
			return reject("Failed to get results from RemoteFunction")
		end

		return resolve(table.unpack(results, 1, results.n))
	end)
end

--[=[
	Invokes the client with the remote function call.
	@param remoteFunction RemoteFunction
	@param player Instance
	@param ... any
	@return Promise<T>
]=]
function RemoteFunctionUtils.promiseInvokeClient(
	remoteFunction: RemoteFunction,
	player: Player,
	...
): Promise.Promise<any>
	assert(typeof(remoteFunction) == "Instance" and remoteFunction:IsA("RemoteFunction"), "Bad remoteFunction")

	local args = table.pack(...)

	return Promise.spawn(function(resolve, reject)
		local results
		local ok, err = pcall(function()
			results = table.pack(remoteFunction:InvokeClient(player, table.unpack(args, 1, args.n)))
		end)

		if not ok then
			return reject(err or "Failed to invoke clientfrom RemoteFunction")
		end

		if not results then
			return reject("Failed to get results from RemoteFunction")
		end

		return resolve(table.unpack(results, 1, results.n))
	end)
end

--[=[
	Invokes the server with the remote function call.
	@param bindableFunction RemoteFunction
	@param ... any
	@return Promise<T>
]=]
function RemoteFunctionUtils.promiseInvokeBindableFunction(
	bindableFunction: BindableFunction,
	...
): Promise.Promise<any>
	assert(typeof(bindableFunction) == "Instance" and bindableFunction:IsA("BindableFunction"), "Bad bindableFunction")

	local args = table.pack(...)

	return Promise.spawn(function(resolve, reject)
		local results
		local ok, err = pcall(function()
			results = table.pack(bindableFunction:Invoke(table.unpack(args, 1, args.n)))
		end)

		if not ok then
			return reject(err or "Failed to invoke from BindableFunction")
		end

		if not results then
			return reject("Failed to get results from BindableFunction")
		end

		return resolve(table.unpack(results, 1, results.n))
	end)
end

--[=[
	Converts a promise result into a promise

	@param ok boolean
	@param ... any
	@return Promise<T>
]=]
function RemoteFunctionUtils.fromPromiseYieldResult(ok: boolean, ...): Promise.Promise<any>
	if ok then
		return ...
	else
		local n = select("#", ...)
		if n == 0 then
			return Promise.rejected("Failed to get result from RemoteFunction")
		else
			return Promise.rejected(...)
		end
	end
end

return RemoteFunctionUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="210">
            <Properties>
              <string name="Name">remoting</string>
            </Properties>
            <Item class="Folder" referent="211">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="212">
                <Properties>
                  <string name="Name">GetRemoteEvent</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Provides getting named global [RemoteEvent] resources.
	@class GetRemoteEvent
]=]

--[=[
	Retrieves a global remote event from the store. On the server, it constructs a new one,
	and on the client, it waits for it to exist.

	:::tip
	Consider using [PromiseGetRemoteEvent] for a non-yielding version
	:::

	```lua
	-- server.lua
	local GetRemoteEvent = require("GetRemoteEvent")

	local remoteEvent = GetRemoteEvent("testing")
	remoteEvent.OnServerEvent:Connect(print)

	-- client.lua
	local GetRemoteEvent = require("GetRemoteEvent")

	local remoteEvent = GetRemoteEvent("testing")
	remoteEvent:FireServer("Hello") --> Hello (on the server)
	```

	:::info
	If the game is not running, then a mock remote event will be created
	for use in testing.
	:::

	@yields
	@function GetRemoteEvent
	@within GetRemoteEvent
	@param name string
	@return RemoteEvent
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local ResourceConstants = require("ResourceConstants")

if not RunService:IsRunning() then
	return function(name: string): RemoteEvent
		local event = Instance.new("RemoteEvent")
		event.Archivable = false
		event.Name = "Mock" .. name

		return event
	end
elseif RunService:IsServer() then
	local function getOrCreateStorage(): Instance
		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_EVENT_STORAGE_NAME)
		if storage then
			return storage
		end

		local created = Instance.new("Folder")
		created.Name = ResourceConstants.REMOTE_EVENT_STORAGE_NAME
		created.Archivable = false
		created.Parent = ReplicatedStorage
		return created
	end

	return function(name: string): RemoteEvent
		assert(type(name) == "string", "Bad name")

		local storage = getOrCreateStorage()

		local event = storage:FindFirstChild(name)
		if event and event:IsA("RemoteEvent") then
			return event
		end

		local created = Instance.new("RemoteEvent")
		created.Name = name
		created.Archivable = false
		created.Parent = storage

		return created
	end
else -- RunService:IsClient()
	return function(name: string): RemoteEvent
		assert(type(name) == "string", "Bad name")

		local found = ReplicatedStorage:WaitForChild(ResourceConstants.REMOTE_EVENT_STORAGE_NAME):WaitForChild(name)
		if found and found:IsA("RemoteEvent") then
			return found
		end

		error("Could not find remote event " .. name)
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="213">
                <Properties>
                  <string name="Name">GetRemoteFunction</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Provides getting named global [RemoteFunction] resources.

	@class GetRemoteFunction
]=]

--[=[
	Retrieves a global remote function from the store. On the server, it constructs a new one,
	and on the client, it waits for it to exist.

	:::tip
	Consider using [PromiseGetRemoteFunction] for a non-yielding version
	:::

	```lua
	-- server.lua
	local GetRemoteFunction = require("GetRemoteFunction")

	local remoteFunction = GetRemoteFunction("testing")
	remoteFunction.OnServerInvoke = function(_player, text)
		return "HI " .. tostring(text)
	end

	-- client.lua
	local GetRemoteFunction = require("GetRemoteFunction")

	local remoteFunction = GetRemoteFunction("testing")
	print(remoteFunction:InvokeServer("Bob")) --> HI Bob
	```

	:::info
	If the game is not running, then a mock remote function will be created
	for use in testing.
	:::

	@yields
	@function GetRemoteFunction
	@within GetRemoteFunction
	@param name string
	@return RemoteFunction
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local ResourceConstants = require("ResourceConstants")

if not RunService:IsRunning() then
	return function(name: string): RemoteFunction
		local func = Instance.new("RemoteFunction")
		func.Name = "Mock" .. name
		func.Archivable = false

		return func
	end
elseif RunService:IsServer() then
	local function getOrCreateStorage(): Instance
		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME)
		if storage then
			return storage
		end

		local created = Instance.new("Folder")
		created.Name = ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME
		created.Archivable = false
		created.Parent = ReplicatedStorage

		return created
	end

	return function(name: string): RemoteFunction
		assert(type(name) == "string", "Bad name")

		local storage = getOrCreateStorage()
		local func = storage:FindFirstChild(name)
		if func and func:IsA("RemoteFunction") then
			return func
		end

		local created = Instance.new("RemoteFunction")
		created.Name = name
		created.Archivable = false
		created.Parent = storage

		return created
	end
else -- RunService:IsClient()
	return function(name: string): RemoteFunction
		assert(type(name) == "string", "Bad name")

		local found = ReplicatedStorage:WaitForChild(ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME):WaitForChild(name)
		if found and found:IsA("RemoteFunction") then
			return found
		end

		error("Could not find remote function " .. name)
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="214">
                <Properties>
                  <string name="Name">Interface</string>
                </Properties>
                <Item class="ModuleScript" referent="215">
                  <Properties>
                    <string name="Name">Remoting</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Offers a thin wrapper around Roblox remoting instances and events. Designed to reduce
	the amount of code needed to construct a large set of RemoteFunction/RemoteEvent instances.

	@class Remoting
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local Promise = require("Promise")
local PromiseUtils = require("PromiseUtils")
local RemoteFunctionUtils = require("RemoteFunctionUtils")
local RemotingMember = require("RemotingMember")
local RemotingRealmUtils = require("RemotingRealmUtils")
local RemotingRealms = require("RemotingRealms")
local RxBrioUtils = require("RxBrioUtils")
local RxInstanceUtils = require("RxInstanceUtils")
local promiseChild = require("promiseChild")

local RAW_MEMBERS = {
	_name = true,
	_maid = true,
	_instance = true,
	_remoteObjects = true,
	_container = true,
	_defaultRemotingRealm = true,
}

local REMOTE_EVENT_SUFFIX = "Event"
local REMOTE_FUNCTION_SUFFIX = "Function"

local Remoting = {}
Remoting.ClassName = "Remoting"
Remoting.__index = Remoting

Remoting.Realms = RemotingRealms

Remoting.Server = {
	new = function(instance: Instance, name: string)
		return Remoting.new(instance, name, RemotingRealms.SERVER)
	end,
}

Remoting.Client = {
	new = function(instance: Instance, name: string)
		return Remoting.new(instance, name, RemotingRealms.CLIENT)
	end,
}

export type Remoting = typeof(setmetatable(
	{} :: {
		_maid: Maid.Maid,
		_instance: Instance,
		_name: string,
		_remoteObjects: { [string]: RemoteEvent | BindableEvent | RemoteFunction },
		_container: Folder?,
		_remotingRealm: RemotingRealms.RemotingRealm,
		_useDummyObject: boolean,
		_remoteFolderName: string,

		-- Public methods
		DeclareEvent: (self: Remoting, memberName: string) -> (),
		DeclareMethod: (self: Remoting, memberName: string) -> (),
		Connect: (self: Remoting, memberName: string, callback: (...any) -> ()) -> Maid.Maid,
		Bind: (self: Remoting, memberName: string, callback: (...any) -> ()) -> Maid.Maid,
		FireClient: (self: Remoting, memberName: string, player: Player, ...any) -> (),
		FireAllClients: (self: Remoting, memberName: string, ...any) -> (),
		FireAllClientsExcept: (self: Remoting, memberName: string, excludePlayer: Player, ...any) -> (),
		FireServer: (self: Remoting, memberName: string, ...any) -> (),
		PromiseFireServer: (self: Remoting, memberName: string, ...any) -> Promise.Promise<()>,
		PromiseInvokeServer: (self: Remoting, memberName: string, ...any) -> Promise.Promise<...any>,
		GetContainerClass: (self: Remoting) -> string,

		-- Private methods
		_getDummyMemberName: (self: Remoting, memberName: string, suffix: string) -> string,
		_getMemberName: (self: Remoting, memberName: string, objectType: string) -> string,
		_getDebugMemberName: (self: Remoting, memberName: string) -> string,
		_ensureContainer: (self: Remoting) -> Folder,
		_observeFolderBrio: (self: Remoting) -> Observable.Observable<Brio.Brio<Folder>>,
		_observeRemoteEventBrio: (
			self: Remoting,
			memberName: string
		) -> Observable.Observable<Brio.Brio<RemoteEvent>>,
		_observeRemoteFunctionBrio: (
			self: Remoting,
			memberName: string
		) -> Observable.Observable<Brio.Brio<RemoteFunction>>,
		_promiseContainer: (self: Remoting, maid: Maid.Maid) -> Promise.Promise<Folder>,
		_promiseRemoteEvent: (self: Remoting, maid: Maid.Maid, memberName: string) -> Promise.Promise<RemoteEvent>,
		_getOrCreateRemoteEvent: (self: Remoting, memberName: string) -> RemoteEvent | BindableEvent,
		_getOrCreateRemoteFunction: (self: Remoting, memberName: string) -> RemoteFunction | BindableFunction,
		_promiseRemoteFunction: (
			self: Remoting,
			maid: Maid.Maid,
			memberName: string
		) -> Promise.Promise<RemoteFunction>,
		_translateCallback: (
			self: Remoting,
			maid: Maid.Maid,
			memberName: string,
			callback: (...any) -> ...any
		) -> (...any) -> ...any,

		-- Public remoting member export
		[string]: RemotingMember.RemotingMember,
	},
	{} :: typeof({ __index = Remoting })
))

--[=[
	Creates a new remoting instance

	@param instance Instance
	@param name string
	@param remotingRealm RemotingRealm?
	@return Remoting
]=]
function Remoting.new(instance: Instance, name: string, remotingRealm: RemotingRealms.RemotingRealm?): Remoting
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(name) == "string", "Bad name")
	assert(RemotingRealmUtils.isRemotingRealm(remotingRealm) or remotingRealm == nil, "Bad remotingRealm")

	local self: Remoting = setmetatable({} :: any, Remoting)

	self._maid = Maid.new()

	self._instance = assert(instance, "No instance")
	self._name = assert(name, "No name")
	self._remotingRealm = remotingRealm or RemotingRealmUtils.inferRemotingRealm()
	self._useDummyObject = not RunService:IsRunning()

	self._remoteFolderName = string.format("%sRemotes", self._name)
	self._remoteObjects = {}

	return self
end

(Remoting :: any).__index = function(self, index)
	if Remoting[index] then
		return Remoting[index]
	elseif RAW_MEMBERS[index] then
		return rawget(self :: any, index)
	else
		return RemotingMember.new(self, index, self._remotingRealm)
	end
end

--[=[
	Connects to a given remote event.

	@param memberName string
	@param callback (...) -> ()
	@return MaidTask
]=]
function Remoting.Connect(self: Remoting, memberName: string, callback: (...any) -> ())
	assert(type(memberName) == "string", "Bad memberName")
	assert(type(callback) == "function", "Bad callback")

	local connectMaid = Maid.new()

	if self._remotingRealm == RemotingRealms.SERVER then
		if self._useDummyObject then
			self:DeclareEvent(memberName)

			self:_getOrCreateRemoteEvent(self:_getDummyMemberName(memberName, "OnClientEvent"))
			local bindableEvent: BindableEvent =
				self:_getOrCreateRemoteEvent(self:_getDummyMemberName(memberName, "OnServerEvent")) :: any
			connectMaid:GiveTask(bindableEvent.Event:Connect(callback))
		else
			local remoteEvent: RemoteEvent = self:_getOrCreateRemoteEvent(memberName) :: any
			connectMaid:GiveTask(remoteEvent.OnServerEvent:Connect(callback))
		end

		-- TODO: Cleanup if nothing else is expecting this
	elseif self._remotingRealm == RemotingRealms.CLIENT then
		connectMaid._warning = task.delay(5, function()
			warn(
				string.format(
					"[Remoting] - Failed to find RemoteEvent %q, event may never connect",
					self:_getDebugMemberName(memberName)
				)
			)
		end)

		if self._useDummyObject then
			connectMaid:GiveTask(
				self:_observeRemoteEventBrio(self:_getDummyMemberName(memberName, "OnClientEvent"))
					:Subscribe(function(brio)
						if brio:IsDead() then
							return
						end

						connectMaid._warning = nil

						local maid, bindableEvent: any = brio:ToMaidAndValue()
						maid:GiveTask((bindableEvent :: BindableEvent).Event:Connect(callback))
					end)
			)
		else
			connectMaid:GiveTask(self:_observeRemoteEventBrio(memberName):Subscribe(function(brio)
				if brio:IsDead() then
					return
				end

				connectMaid._warning = nil

				local maid, remoteEvent = brio:ToMaidAndValue()
				maid:GiveTask(remoteEvent.OnClientEvent:Connect(callback))
			end))
		end
	else
		error("[Remoting.Connect] - Unknown RunService state")
	end

	self._maid[connectMaid] = connectMaid
	connectMaid:GiveTask(function()
		self._maid[connectMaid] = nil
	end)

	return connectMaid
end

--[=[
	If on the server, creates a new [RemoteFunction] with the name `memberName` and binds the
	invoke. On the client, it waits for the event to exist and then binds to it.

	@param memberName string
	@param callback any
]=]
function Remoting.Bind(self: Remoting, memberName: string, callback: (...any) -> ...any): Maid.Maid
	assert(type(memberName) == "string", "Bad memberName")
	assert(type(callback) == "function", "Bad callback")

	local bindMaid: Maid.Maid = Maid.new()

	if self._remotingRealm == RemotingRealms.SERVER then
		if self._useDummyObject then
			self:DeclareMethod(memberName)

			local bindableFunction: BindableFunction =
				self:_getOrCreateRemoteFunction(self:_getDummyMemberName(memberName, "OnServerInvoke")) :: any
			bindableFunction.OnInvoke = self:_translateCallback(bindMaid, memberName, callback)
		else
			local remoteFunction: RemoteFunction = self:_getOrCreateRemoteFunction(memberName) :: any
			remoteFunction.OnServerInvoke = self:_translateCallback(bindMaid, memberName, callback)
		end

		-- TODO: Cleanup if nothing else is expecting this
	elseif self._remotingRealm == RemotingRealms.CLIENT then
		bindMaid._warning = task.delay(5, function()
			warn(
				string.format(
					"[Remoting] - Failed to find RemoteEvent %q, event may never fire",
					self:_getDebugMemberName(memberName)
				)
			)
		end)

		if self._useDummyObject then
			bindMaid:GiveTask(
				self:_observeRemoteFunctionBrio(self:_getDummyMemberName(memberName, "OnClientInvoke"))
					:Subscribe(function(brio)
						if brio:IsDead() then
							return
						end

						bindMaid._warning = nil

						local maid, remoteFunction: any = brio:ToMaidAndValue()
						remoteFunction.OnInvoke = self:_translateCallback(maid, memberName, callback)
					end)
			)
		else
			bindMaid:GiveTask(self:_observeRemoteFunctionBrio(memberName):Subscribe(function(brio)
				if brio:IsDead() then
					return
				end

				bindMaid._warning = nil

				local maid, remoteFunction = brio:ToMaidAndValue()
				remoteFunction.OnClientInvoke = self:_translateCallback(maid, memberName, callback)
			end))
		end

		-- TODO: Warn if remote function doesn't exist
	else
		error("[Remoting.Bind] - Unknown RunService state")
	end

	self._maid[bindMaid] = bindMaid
	bindMaid:GiveTask(function()
		self._maid[bindMaid] = nil
	end)

	return bindMaid
end

--[=[
	Forward declares an event on the remoting object

	@param memberName string
]=]
function Remoting.DeclareEvent(self: Remoting, memberName: string)
	assert(type(memberName) == "string", "Bad memberName")

	if self._remotingRealm == RemotingRealms.SERVER then
		if self._useDummyObject then
			self:_getOrCreateRemoteEvent(self:_getDummyMemberName(memberName, "OnClientEvent"))
			self:_getOrCreateRemoteEvent(self:_getDummyMemberName(memberName, "OnServerEvent"))
		else
			self:_getOrCreateRemoteEvent(memberName)
		end
	end
end

--[=[
	Forward declares an event on the remoting object

	@param memberName string
]=]
function Remoting.DeclareMethod(self: Remoting, memberName: string)
	assert(type(memberName) == "string", "Bad memberName")

	if self._remotingRealm == RemotingRealms.SERVER then
		if self._useDummyObject then
			self:_getOrCreateRemoteFunction(self:_getDummyMemberName(memberName, "OnServerInvoke"))
			self:_getOrCreateRemoteFunction(self:_getDummyMemberName(memberName, "OnClientInvoke"))
		else
			self:_getOrCreateRemoteFunction(memberName)
		end
	end
end

function Remoting._translateCallback(self: Remoting, maid: Maid.Maid, memberName: string, callback: (...any) -> ...any)
	local alive = true
	maid:GiveTask(function()
		alive = false
	end)

	return function(...)
		if not alive then
			error(
				string.format(
					"[Remoting] - Function for %s is disconnected and can't be called",
					self:_getDebugMemberName(memberName)
				)
			)
			return
		end

		local results = table.pack(callback(...))

		local hasPromise = false
		for i = 1, results.n do
			if Promise.isPromise(results[i]) then
				hasPromise = true
				break
			end
		end

		if hasPromise then
			local promise
			if results.n == 1 then
				promise = results[1]
			else
				local data = {}
				for i = 1, results.n do
					table.insert(data, results[i])
				end

				promise = PromiseUtils.combine(data)
			end

			promise = maid:GivePromise(promise)

			local yielded = table.pack(promise:Wait())
			return table.unpack(yielded, 1, yielded.n)
		else
			return table.unpack(results)
		end
	end
end

--[=[
	Fires the client with the individual request. Should consider this syntax instead.

	```lua
	local remoting = Remoting.new(workspace, "Test")
	remoting.Event:FireClient(otherPlayer, ...)
	```

	Equivalent of [RemoteFunction.FireClient].


	@param memberName string
	@param player Player
	@param ... any
]=]
function Remoting.FireClient(self: Remoting, memberName: string, player: Player, ...)
	assert(type(memberName) == "string", "Bad memberName")
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(self._remotingRealm == RemotingRealms.SERVER, "FireClient must be called on server")

	if self._useDummyObject then
		local bindableEvent: BindableEvent = self:_getOrCreateRemoteEvent(memberName) :: any
		bindableEvent:Fire(...)
		return
	end

	local remoteEvent: RemoteEvent = self:_getOrCreateRemoteEvent(memberName) :: any
	remoteEvent:FireClient(player, ...)
end

--[=[
	Invokes the client, yielding as needed

	Equivalent of [RemoteFunction.InvokeClient].

	@server
	@param memberName string
	@param player Player
	@param ... any
]=]
function Remoting.InvokeClient(self: Remoting, memberName: string, player: Player, ...)
	assert(type(memberName) == "string", "Bad memberName")
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(self._remotingRealm == RemotingRealms.SERVER, "InvokeClient must be called on server")

	if self._useDummyObject then
		local bindableFunction: BindableFunction =
			self:_getOrCreateRemoteFunction(self:_getDummyMemberName(memberName, "OnClientInvoke")) :: any
		bindableFunction:Invoke(...)
		return
	end

	local remoteFunction: RemoteFunction = self:_getOrCreateRemoteFunction(memberName) :: any
	remoteFunction:InvokeClient(player, ...)
end

--[=[
	Fires all clients with the event.

	Equivalent of [RemoteEvent.FireAllClients].

	@server
	@param memberName string
	@param ... any
]=]
function Remoting.FireAllClients(self: Remoting, memberName: string, ...)
	assert(type(memberName) == "string", "Bad memberName")
	assert(self._remotingRealm == RemotingRealms.SERVER, "FireAllClients must be called on server")

	if self._useDummyObject then
		local bindableEvent: BindableEvent =
			self:_getOrCreateRemoteEvent(self:_getDummyMemberName(memberName, "OnClientEvent")) :: any
		bindableEvent:Fire(...)
		return
	end

	local remoteEvent: RemoteEvent = self:_getOrCreateRemoteEvent(memberName) :: any
	remoteEvent:FireAllClients(...)
end

--[=[
	Fires all clients with the event except the excluded player. The excluded player may be nil to support
	NPC actions.

	@server
	@param memberName string
	@param excludePlayer Player | nil
	@param ... any
]=]
function Remoting.FireAllClientsExcept(self: Remoting, memberName: string, excludePlayer: Player, ...)
	assert(type(memberName) == "string", "Bad memberName")
	assert(
		typeof(excludePlayer) == "Instance" and excludePlayer:IsA("Player") or excludePlayer == nil,
		"Bad excludePlayer"
	)
	assert(self._remotingRealm == RemotingRealms.SERVER, "FireAllClientsExcept must be called on server")

	if self._useDummyObject then
		local bindableEvent: BindableEvent =
			self:_getOrCreateRemoteEvent(self:_getDummyMemberName(memberName, "OnClientEvent")) :: any
		bindableEvent:Fire(...)
		return
	end

	local remoteEvent: RemoteEvent = self:_getOrCreateRemoteEvent(memberName) :: any
	for _, player in Players:GetPlayers() do
		if player ~= excludePlayer then
			remoteEvent:FireClient(player, ...)
		end
	end
end

--[=[
	Fires the server

	@client
	@param memberName string
	@param ... any
]=]
function Remoting.FireServer(self: Remoting, memberName: string, ...)
	assert(type(memberName) == "string", "Bad memberName")
	assert(self._remotingRealm == RemotingRealms.CLIENT, "FireServer must be called on client")

	self:PromiseFireServer(memberName, ...)
end

--[=[
	Fires the server, resolving the promise once it is fired.

	@client
	@param memberName string
	@param ... any
	@return Promise
]=]
function Remoting.PromiseFireServer(self: Remoting, memberName: string, ...)
	assert(type(memberName) == "string", "Bad memberName")
	assert(self._remotingRealm == RemotingRealms.CLIENT, "PromiseFireServer must be called on client")

	local fireMaid = Maid.new()
	local args = table.pack(...)

	local promise
	if self._useDummyObject then
		promise = self:_promiseRemoteEvent(fireMaid, self:_getDummyMemberName(memberName, "OnServerEvent"))
			:Then(function(bindableEvent)
				bindableEvent:Fire(Players.LocalPlayer, table.unpack(args, 1, args.n))
			end)
	else
		promise = self:_promiseRemoteEvent(fireMaid, memberName):Then(function(remoteEvent)
			remoteEvent:FireServer(table.unpack(args, 1, args.n))
		end)
	end

	promise:Finally(function()
		self._maid[fireMaid] = nil
	end)
	self._maid[fireMaid] = fireMaid
	fireMaid:GiveTask(function()
		self._maid[fireMaid] = nil
	end)

	-- TODO: Warn if remote event doesn't exist

	return promise
end

--[=[
	Invokes the server from the client

	@client
	@param memberName string
	@param ... any
	@return any
]=]
function Remoting.InvokeServer(self: Remoting, memberName: string, ...): ...any
	assert(type(memberName) == "string", "Bad memberName")

	return self:PromiseInvokeServer(memberName, ...):Wait()
end

--[=[
	Invokes the server from the client

	@client
	@param memberName string
	@param ... any
	@return Promise<...any>
]=]
function Remoting.PromiseInvokeServer(self: Remoting, memberName: string, ...): Promise.Promise<...any>
	assert(type(memberName) == "string", "Bad memberName")

	local invokeMaid = Maid.new()
	local args = table.pack(...)

	local promise
	if self._useDummyObject then
		promise = self:_promiseRemoteFunction(invokeMaid, self:_getDummyMemberName(memberName, "OnServerInvoke"))
			:Then(function(remoteFunction)
				return invokeMaid:GivePromise(
					RemoteFunctionUtils.promiseInvokeBindableFunction(
						remoteFunction,
						Players.LocalPlayer,
						table.unpack(args, 1, args.n)
					)
				)
			end)
	else
		promise = self:_promiseRemoteFunction(invokeMaid, memberName):Then(function(remoteFunction)
			return invokeMaid:GivePromise(
				RemoteFunctionUtils.promiseInvokeServer(remoteFunction, table.unpack(args, 1, args.n))
			)
		end)
	end

	promise:Finally(function()
		self._maid[invokeMaid] = nil
	end)
	self._maid[invokeMaid] = invokeMaid
	invokeMaid:GiveTask(function()
		self._maid[invokeMaid] = nil
	end)

	-- TODO: Warn if remote function doesn't exist

	return promise
end

--[=[
	Invokes the client from the server

	@server
	@param memberName string
	@param player Player
	@param ... any
	@return Promise<any>
]=]
function Remoting.PromiseInvokeClient(self: Remoting, memberName: string, player: Player, ...)
	assert(type(memberName) == "string", "Bad memberName")
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	local invokeMaid: Maid.Maid = Maid.new()

	local promise
	if self._useDummyObject then
		local bindableFunction: BindableFunction =
			self:_getOrCreateRemoteFunction(self:_getDummyMemberName(memberName, "OnClientInvoke")) :: any
		promise = invokeMaid:GivePromise(RemoteFunctionUtils.promiseInvokeBindableFunction(bindableFunction, ...))
	else
		local remoteFunction: RemoteFunction = self:_getOrCreateRemoteFunction(memberName) :: any
		promise = invokeMaid:GivePromise(RemoteFunctionUtils.promiseInvokeClient(remoteFunction, player, ...))
	end

	promise:Finally(function()
		self._maid[invokeMaid] = nil
	end)

	self._maid[invokeMaid] = invokeMaid
	invokeMaid:GiveTask(function()
		self._maid[invokeMaid] = nil
	end)

	return promise
end

function Remoting.GetContainerClass(_self: Remoting): string
	return "Configuration"
end

function Remoting._ensureContainer(self: Remoting): Folder
	assert(self._remotingRealm == RemotingRealms.SERVER, "Folder should only be created on server")

	if self._container then
		return self._container
	end

	local created: Folder = self._maid:Add(Instance.new(self:GetContainerClass())) :: any
	created.Name = self._remoteFolderName
	created.Archivable = false
	created.Parent = self._instance

	self._maid:GiveTask(created)
	self._container = created

	return created
end

function Remoting._observeRemoteFunctionBrio(self: Remoting, memberName: string)
	assert(type(memberName) == "string", "Bad memberName")

	local remoteFunctionName = self:_getMemberName(memberName, REMOTE_FUNCTION_SUFFIX)

	return self:_observeFolderBrio():Pipe({
		RxBrioUtils.switchMapBrio(function(item)
			if self._useDummyObject then
				return RxInstanceUtils.observeLastNamedChildBrio(item, "BindableFunction", remoteFunctionName)
			else
				return RxInstanceUtils.observeLastNamedChildBrio(item, "RemoteFunction", remoteFunctionName)
			end
		end) :: any,
	})
end

function Remoting._observeRemoteEventBrio(self: Remoting, memberName: string)
	assert(type(memberName) == "string", "Bad memberName")

	local remoteFunctionName = self:_getMemberName(memberName, REMOTE_EVENT_SUFFIX)

	return self:_observeFolderBrio():Pipe({
		RxBrioUtils.switchMapBrio(function(item)
			if self._useDummyObject then
				return RxInstanceUtils.observeLastNamedChildBrio(item, "BindableEvent", remoteFunctionName)
			else
				return RxInstanceUtils.observeLastNamedChildBrio(item, "RemoteEvent", remoteFunctionName)
			end
		end) :: any,
	})
end

function Remoting._promiseContainer(self: Remoting, maid: Maid.Maid): Promise.Promise<Folder>
	return maid:GivePromise(promiseChild(self._instance, self._remoteFolderName, 5))
end

function Remoting._promiseRemoteEvent(self: Remoting, maid: Maid.Maid, memberName: string): Promise.Promise<RemoteEvent>
	local remoteEventName = self:_getMemberName(memberName, REMOTE_EVENT_SUFFIX)
	return self:_promiseContainer(maid):Then(function(container)
		return maid:GivePromise(promiseChild(container, remoteEventName, 5))
	end)
end

function Remoting._promiseRemoteFunction(
	self: Remoting,
	maid: Maid.Maid,
	memberName: string
): Promise.Promise<RemoteFunction>
	local remoteEventName = self:_getMemberName(memberName, REMOTE_FUNCTION_SUFFIX)
	return self:_promiseContainer(maid):Then(function(container)
		return maid:GivePromise(promiseChild(container, remoteEventName, 5))
	end)
end

function Remoting._observeFolderBrio(self: Remoting): Observable.Observable<Brio.Brio<Folder>>
	assert(self._instance, "Not initialized")

	return RxInstanceUtils.observeLastNamedChildBrio(
			self._instance,
			self:GetContainerClass(),
			self._remoteFolderName
		) :: any
end

function Remoting._getOrCreateRemoteFunction(self: Remoting, memberName: string): RemoteFunction | BindableFunction
	assert(type(memberName) == "string", "Bad memberName")

	local remoteFunctionName = self:_getMemberName(memberName, REMOTE_FUNCTION_SUFFIX)

	if self._remoteObjects[remoteFunctionName] then
		return self._remoteObjects[remoteFunctionName] :: any
	end

	local container = self:_ensureContainer()

	local remoteFunction: Instance
	if self._useDummyObject then
		remoteFunction = Instance.new("BindableFunction")
	else
		remoteFunction = Instance.new("RemoteFunction")
	end

	remoteFunction.Name = remoteFunctionName
	remoteFunction.Archivable = false
	remoteFunction.Parent = container

	self._remoteObjects[remoteFunctionName] = remoteFunction :: any
	self._maid[remoteFunction] = remoteFunction

	return remoteFunction :: any
end

function Remoting._getOrCreateRemoteEvent(self: Remoting, memberName: string): RemoteEvent | BindableEvent
	assert(type(memberName) == "string", "Bad memberName")

	local remoteEventName = self:_getMemberName(memberName, REMOTE_EVENT_SUFFIX)

	if self._remoteObjects[remoteEventName] then
		return self._remoteObjects[remoteEventName] :: any
	end

	local container = self:_ensureContainer()

	local remoteEvent: Instance
	if self._useDummyObject then
		remoteEvent = Instance.new("BindableEvent")
	else
		remoteEvent = Instance.new("RemoteEvent")
	end

	remoteEvent.Name = remoteEventName
	remoteEvent.Archivable = false
	remoteEvent.Parent = container

	self._maid[remoteEvent] = remoteEvent
	self._remoteObjects[remoteEventName] = remoteEvent :: any

	return remoteEvent :: any
end

function Remoting._getMemberName(_self: Remoting, memberName: string, objectType: string): string
	return memberName .. objectType
end

function Remoting._getDummyMemberName(self: Remoting, memberName: string, suffix: string): string
	assert(self._useDummyObject, "Not dummy mode")

	return memberName .. "_" .. suffix .. "_"
end

function Remoting._getDebugMemberName(self: Remoting, memberName: string): string
	return string.format("%s.%s", self._name, memberName)
end

--[=[
	Cleans up the remoting object
]=]
function Remoting.Destroy(self: Remoting)
	self._maid:DoCleaning()
	setmetatable(self :: any, nil)
end

return Remoting
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="216">
                  <Properties>
                    <string name="Name">RemotingMember</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	Helper class for the [Remoting] object which allows more natural syntax
	to be used against the remoting API surface.

	@class RemotingMember
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Promise = require("Promise")
local RemotingRealms = require("RemotingRealms")

local RemotingMember = {}
RemotingMember.ClassName = "RemotingMember"
RemotingMember.__index = RemotingMember

export type RemotingMember = typeof(setmetatable(
	{} :: {
		_remoting: any,
		_memberName: string,
		_remotingRealm: RemotingRealms.RemotingRealm,
	},
	{} :: typeof({ __index = RemotingMember })
))

--[=[
	Constructs a new RemotingMember

	@param remoting Remoting
	@param memberName string
	@param remotingRealm RemotingRealms
	@return RemotingMember
]=]
function RemotingMember.new(
	remoting: any,
	memberName: string,
	remotingRealm: RemotingRealms.RemotingRealm
): RemotingMember
	local self: RemotingMember = setmetatable({} :: any, RemotingMember)

	self._remoting = assert(remoting, "No remoting")
	self._memberName = assert(memberName, "No memberName")
	self._remotingRealm = assert(remotingRealm, "Bad remotingRealm")

	return self
end

--[=[
	Binds to the member.

	On the server this will create the remote function. On the client
	this will connect to the remote event once it's created.

	@param callback function
	@return MaidTask
]=]
function RemotingMember.Bind(self: RemotingMember, callback: (...any) -> ...any): Maid.Maid
	assert(type(callback) == "function", "Bad callback")

	return self._remoting:Bind(self._memberName, callback)
end

--[=[
	Connects to the equivalent of a RemoteEvent for this member.

	On the server this will create the remote event. On the client
	this will connect to the remote event once it's created.

	See [Remoting.Connect] for additional details.

	@param callback function
	@return MaidTask
]=]
function RemotingMember.Connect(self: RemotingMember, callback: (...any) -> ())
	assert(type(callback) == "function", "Bad callback")

	return self._remoting:Connect(self._memberName, callback)
end

--[=[
	Forward declares an event on the remoting object
]=]
function RemotingMember.DeclareEvent(self: RemotingMember): ()
	return self._remoting:DeclareEvent(self._memberName)
end

--[=[
	Forward declares a method on the remoting object
]=]
function RemotingMember.DeclareMethod(self: RemotingMember): ()
	return self._remoting:DeclareMethod(self._memberName)
end

--[=[
	Fires the remote event on the server

	@client
	@param ... any
]=]
function RemotingMember.FireServer(self: RemotingMember, ...)
	assert(self._remotingRealm == RemotingRealms.CLIENT, "FireServer must be called on client")
	self._remoting:FireServer(self._memberName, ...)
end

--[=[
	Invokes the server from the client

	@client
	@param ... any
]=]
function RemotingMember.InvokeServer(self: RemotingMember, ...): Promise.Promise<...any>
	assert(self._remotingRealm == RemotingRealms.CLIENT, "InvokeServer must be called on client")

	return self._remoting:InvokeServer(self._memberName, ...)
end

--[=[
	Invokes the client from the server.

	@client
	@param ... any
]=]
function RemotingMember.PromiseInvokeServer(self: RemotingMember, ...): Promise.Promise<...any>
	assert(self._remotingRealm == RemotingRealms.CLIENT, "PromiseInvokeServer must be called on client")

	return self._remoting:PromiseInvokeServer(self._memberName, ...)
end

--[=[
	Fires the server from the client. Promise resolves once the event is sent.

	@client
	@param ... any
	@return Promise
]=]
function RemotingMember.PromiseFireServer(self: RemotingMember, ...): Promise.Promise<...any>
	assert(self._remotingRealm == RemotingRealms.CLIENT, "PromiseInvokeServer must be called on client")

	return self._remoting:PromiseFireServer(self._memberName, ...)
end

--[=[
	Invokes the client from the server.

	See [Remoting.PromiseInvokeClient].

	@server
	@param player Player
	@param ... any
	@return Promise<any>
]=]
function RemotingMember.PromiseInvokeClient(self: RemotingMember, player: Player, ...): Promise.Promise<...any>
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(self._remotingRealm == RemotingRealms.SERVER, "PromiseInvokeClient must be called on client")

	return self._remoting:PromiseInvokeClient(self._memberName, player, ...)
end

--[=[
	Invokes the client from the server

	See [Remoting.InvokeClient].

	@server
	@param player Player
	@param ... any
	@return ... any
]=]
function RemotingMember.InvokeClient(self: RemotingMember, player: Player, ...): ...any
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")
	assert(self._remotingRealm == RemotingRealms.SERVER, "InvokeClient must be called on client")

	return self._remoting:InvokeClient(self._memberName, player, ...)
end

--[=[
	Fires all clients.

	See [Remoting.FireAllClients].

	@server
	@param ... any
]=]
function RemotingMember.FireAllClients(self: RemotingMember, ...)
	assert(self._remotingRealm == RemotingRealms.SERVER, "FireAllClients must be called on client")

	self._remoting:FireAllClients(self._memberName, ...)
end

--[=[
	Fires all clients with the event except the excluded player. The excluded player may be nil to support
	NPC actions.

	@server
	@param excludePlayer Player | nil
	@param ... any
]=]
function RemotingMember.FireAllClientsExcept(self: RemotingMember, excludePlayer: Player, ...)
	assert(
		typeof(excludePlayer) == "Instance" and excludePlayer:IsA("Player") or excludePlayer == nil,
		"Bad excludePlayer"
	)
	assert(self._remotingRealm == RemotingRealms.SERVER, "FireAllClientsExcept must be called on server")

	self._remoting:FireAllClientsExcept(self._memberName, excludePlayer, ...)
end

--[=[
	Fires the client with the data

	See [Remoting.FireClient].

	@server
	@param player Instance
	@param ... any
]=]
function RemotingMember.FireClient(self: RemotingMember, player: Player, ...)
	assert(self._remotingRealm == RemotingRealms.SERVER, "FireClient must be called on client")
	assert(typeof(player) == "Instance" and player:IsA("Player"), "Bad player")

	self._remoting:FireClient(self._memberName, player, ...)
end

return RemotingMember
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="217">
                <Properties>
                  <string name="Name">PromiseGetRemoteEvent</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Retrieves a remote event as a promise
	@class PromiseGetRemoteEvent
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local GetRemoteEvent = require("GetRemoteEvent")
local Promise = require("Promise")
local ResourceConstants = require("ResourceConstants")

--[=[
	Like [GetRemoteEvent] but in promise form.

	@function PromiseGetRemoteEvent
	@within PromiseGetRemoteEvent
	@param name string
	@return Promise<RemoteEvent>
]=]
if not RunService:IsRunning() then
	-- Handle testing
	return function(name)
		return Promise.resolved(GetRemoteEvent(name))
	end
elseif RunService:IsServer() then
	return function(name)
		return Promise.resolved(GetRemoteEvent(name))
	end
else -- RunService:IsClient()
	return function(name)
		assert(type(name) == "string", "Bad name")

		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_EVENT_STORAGE_NAME)
		if storage then
			local obj = storage:FindFirstChild(name)
			if obj then
				return Promise.resolved(obj)
			end
		end

		return Promise.spawn(function(resolve, _)
			resolve(GetRemoteEvent(name))
		end)
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="218">
                <Properties>
                  <string name="Name">PromiseGetRemoteFunction</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Retrieves a remote function as a promise
	@class PromiseGetRemoteFunction
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local GetRemoteFunction = require("GetRemoteFunction")
local Promise = require("Promise")
local ResourceConstants = require("ResourceConstants")

--[=[
	Like [GetRemoteFunction] but in promise form.

	@function PromiseGetRemoteFunction
	@within PromiseGetRemoteFunction
	@param name string
	@return Promise<RemoteFunction>
]=]

if not RunService:IsRunning() then
	-- Handle testing
	return function(name)
		return Promise.resolved(GetRemoteFunction(name))
	end
elseif RunService:IsServer() then
	return function(name)
		return Promise.resolved(GetRemoteFunction(name))
	end
else -- RunService:IsClient()
	return function(name)
		assert(type(name) == "string", "Bad name")

		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME)
		if storage then
			local obj = storage:FindFirstChild(name)
			if obj then
				return Promise.resolved(obj)
			end
		end

		return Promise.spawn(function(resolve, _)
			resolve(GetRemoteFunction(name))
		end)
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="219">
                <Properties>
                  <string name="Name">PromiseRemoteEventMixin</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Intended for classes that extend BaseObject only
	@class PromiseRemoteEventMixin
]=]

local require = require(script.Parent.loader).load(script)

local promiseChild = require("promiseChild")

local PromiseRemoteEventMixin = {}

--[=[
	Adds the remote function mixin to a class

	```lua
	local BaseObject = require("BaseObject")

	local Bird = setmetatable({}, BaseObject)
	Bird.ClassName = "Bird"
	Bird.__index = Bird

	require("PromiseRemoteEventMixin"):Add(Bird, "BirdRemoteEvent")

	function Bird.new(inst)
		local self = setmetatable(BaseObject.new(inst), Bird)

		self:PromiseRemoteEvent():Then(function(remoteEvent)
			self._maid:GiveTask(remoteEvent.OnClientEvent:Connect(function(...)
				self:_handleRemoteEvent(...)
			end)
		end)

		return self
	end
	```

	@param class { _maid: Maid }
	@param remoteEventName string
]=]
function PromiseRemoteEventMixin:Add(class, remoteEventName)
	assert(type(class) == "table", "Bad class")
	assert(type(remoteEventName) == "string", "Bad remoteEventName")
	assert(not class.PromiseRemoteEventMixin, "Class already has PromiseRemoteEventMixin defined")
	assert(not class._remoteEventName, "Class already has _remoteEventName defined")

	class.PromiseRemoteEvent = self.PromiseRemoteEvent
	class._remoteEventName = remoteEventName
end

--[=[
	Returns a promise that returns a remote event
	@return Promise<RemoteEvent>
]=]
function PromiseRemoteEventMixin:PromiseRemoteEvent()
	return self._maid:GivePromise(promiseChild(self._obj, self._remoteEventName))
end

return PromiseRemoteEventMixin
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="220">
                <Properties>
                  <string name="Name">PromiseRemoteFunctionMixin</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Intended for classes that extend BaseObject only
	@class PromiseRemoteFunctionMixin
]=]

local require = require(script.Parent.loader).load(script)

local promiseChild = require("promiseChild")

local PromiseRemoteFunctionMixin = {}

--[=[
	Adds the remote function mixin to a class

	```lua
	local BaseObject = require("BaseObject")

	local Bird = setmetatable({}, BaseObject)
	Bird.ClassName = "Bird"
	Bird.__index = Bird

	require("PromiseRemoteFunctionMixin"):Add(Bird, "BirdRemoteFunction")

	function Bird.new(inst)
		local self = setmetatable(BaseObject.new(inst), Bird)

		self:PromiseRemoteFunction():Then(function(remoteFunction)
			task.spawn(function()
				remoteFunction:InvokeServer() -- or whatever
			end)
		end)

		return self
	end
	```

	@param class { _maid: Maid }
	@param remoteFunctionName string
]=]
function PromiseRemoteFunctionMixin:Add(class, remoteFunctionName)
	assert(type(class) == "table", "Bad class")
	assert(type(remoteFunctionName) == "string", "Bad remoteFunctionName")
	assert(not class.PromiseRemoteFunctionMixin, "Class already has PromiseRemoteFunctionMixin defined")
	assert(not class._remoteFunctionName, "Class already has _remoteFunctionName defined")

	class.PromiseRemoteFunction = self.PromiseRemoteFunction
	class._remoteFunctionName = remoteFunctionName
end

--[=[
	Returns a promise that returns a remote function
	@return Promise<RemoteFunction>
]=]
function PromiseRemoteFunctionMixin:PromiseRemoteFunction()
	return self._maid:GivePromise(promiseChild(self._obj, self._remoteFunctionName))
end

return PromiseRemoteFunctionMixin
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="221">
                <Properties>
                  <string name="Name">Realm</string>
                </Properties>
                <Item class="ModuleScript" referent="222">
                  <Properties>
                    <string name="Name">RemotingRealmUtils</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	@class RemotingRealmUtils
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local RemotingRealms = require("RemotingRealms")

local RemotingRealmUtils = {}

function RemotingRealmUtils.isRemotingRealm(realm: any): boolean
	return realm == RemotingRealms.SERVER or realm == RemotingRealms.CLIENT
end

function RemotingRealmUtils.inferRemotingRealm(): RemotingRealms.RemotingRealm
	if RunService:IsServer() then
		return RemotingRealms.SERVER
	elseif RunService:IsClient() then
		return RemotingRealms.CLIENT
	else
		error("[RemotingRealmUtils.inferRemotingRealm] - Unknown RunService state")
	end
end

return RemotingRealmUtils
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="223">
                  <Properties>
                    <string name="Name">RemotingRealms</string>
                    <string name="Source"><![CDATA[--!strict
--[=[
	@class RemotingRealms
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

export type RemotingRealm = "server" | "client"

export type RemotingRealms = {
	SERVER: "server",
	CLIENT: "client",
}

return Table.readonly({
	SERVER = "server",
	CLIENT = "client",
} :: RemotingRealms)
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="224">
                <Properties>
                  <string name="Name">ResourceConstants</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Holds constants for resource retrieval.
	@class ResourceConstants
	@private
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

return Table.readonly({
	REMOTE_EVENT_STORAGE_NAME = "RemoteEvents" :: "RemoteEvents",
	REMOTE_FUNCTION_STORAGE_NAME = "RemoteFunctions" :: "RemoteFunctions",
})
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="225">
            <Properties>
              <string name="Name">rx</string>
            </Properties>
            <Item class="Folder" referent="226">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="227">
                <Properties>
                  <string name="Name">Observable</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Observables are like an [signal](/api/Signal), except they do not execute code
	until the observable is subscribed to. This follows the standard
	Rx API surface for an observable.

	Observables use a [Subscription](/api/Subscription) to emit values.

	```lua
	-- Constucts an observable which will emit a, b, c via a subscription
	local observable = Observable.new(function(sub)
		print("Connected")
		sub:Fire("a")
		sub:Fire("b")
		sub:Fire("c")
		sub:Complete() -- ends stream
	end)

	local sub1 = observable:Subscribe() --> Connected
	local sub2 = observable:Subscribe() --> Connected
	local sub3 = observable:Subscribe() --> Connected

	sub1:Destroy()
	sub2:Destroy()
	sub3:Destroy()
	```

	Note that emitted values may be observed like this

	```lua
	observable:Subscribe(function(value)
		print("Got ", value)
	end)

	--> Got a
	--> Got b
	--> Got c
	```

	Note that also, observables return a [MaidTask](/api/MaidTask) which
	should be used to clean up the resulting subscription.

	```lua
	maid:GiveTask(observable:Subscribe(function(value)
		-- do work here!
	end))
	```

	Observables over signals are nice because observables may be chained and manipulated
	via the Pipe operation.

	:::tip
	You should always clean up the subscription using a [Maid](/api/Maid), otherwise
	you may memory leak.
	:::
	@class Observable
]=]

local require = require(script.Parent.loader).load(script)

local DuckTypeUtils = require("DuckTypeUtils")
local MaidTaskUtils = require("MaidTaskUtils")
local Subscription = require("Subscription")

local ENABLE_STACK_TRACING = false

local Observable = {}
Observable.ClassName = "Observable"
Observable.__index = Observable

export type OnSubscribe<T...> = (subscription: Subscription.Subscription<T...>) -> MaidTaskUtils.MaidTask?

export type Transformer<T..., U...> = (observable: Observable<T...>) -> Observable<U...>

export type Observable<T...> = typeof(setmetatable(
	{} :: {
		_source: string?,
		_onSubscribe: OnSubscribe<T...>,
	},
	{} :: typeof({ __index = Observable })
))

--[=[
	Returns whether or not a value is an observable.
	@param item any
	@return boolean
]=]
function Observable.isObservable(item: any): boolean
	return DuckTypeUtils.isImplementation(Observable, item)
end

--[=[
	Constructs a new Observable

	```lua
	local function observeAllChildren(parent)
		return Observable.new(function(sub)
			local maid = Maid.new()

			for _, item in parent:GetChildren() do
				sub:Fire(item)
			end
			maid:GiveTask(parent.ChildAdded:Connect(function(child)
				sub:Fire(child)
			end))

			return maid
		end)
	end

	-- Prints out all current children, and whenever a new
	-- child is added to workspace
	local maid = Maid.new()
	maid:GiveTask(observeAllChildren(workspace):Subscribe(print))
	```

	@param onSubscribe (subscription: Subscription<T>) -> MaidTask
	@return Observable<T>
]=]
function Observable.new<T...>(onSubscribe: OnSubscribe<T...>): Observable<T...>
	assert(type(onSubscribe) == "function", "Bad onSubscribe")

	return setmetatable({
		_source = if ENABLE_STACK_TRACING then debug.traceback("Observable.new()", 2) else nil,
		_onSubscribe = onSubscribe,
	}, Observable)
end

--[=[
	Transforms the observable with the following transformers

	```lua
	Rx.of(1, 2, 3):Pipe({
		Rx.map(function(result)
			return result + 1
		end);
		Rx.map(function(value)
			return string.format("%0.2f", value)
		end);
	}):Subscribe(print)

	--> 2.00
	--> 3.00
	--> 4.00
	```
	@param transformers { (observable: Observable<T>) -> Observable<T> }
	@return Observable<T>
]=]
function Observable.Pipe<T...>(self: Observable<T...>, transformers: { Transformer<T..., ...any> }): Observable<...any>
	assert(type(transformers) == "table", "Bad transformers")

	local current: any = self
	for _, transformer in transformers do
		assert(type(transformer) == "function", "Bad transformer")
		current = transformer(current)
		assert(Observable.isObservable(current), "Transformer must return an observable")
	end

	return current
end

--[=[
	Subscribes immediately, fireCallback may return a maid (or a task a maid can handle)
	to clean up

	@param fireCallback function?
	@param failCallback function?
	@param completeCallback function?
	@return MaidTask
]=]
function Observable.Subscribe<T...>(
	self: Observable<T...>,
	fireCallback: Subscription.FireCallback<T...>?,
	failCallback: Subscription.FailCallback?,
	completeCallback: Subscription.CompleteCallback?
): Subscription.Subscription<T...>
	local sub = Subscription.new(fireCallback, failCallback, completeCallback, self._source)

	sub:_assignCleanup(self._onSubscribe(sub))

	return sub :: any
end

return Observable
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="228">
                <Properties>
                  <string name="Name">ObservablePerformance.story</string>
                  <string name="Source"><![CDATA[--[[
	@class ObservablePerformance.story
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Observable = require("Observable")

return function(_target)
	local startTime = tick()

	for _ = 1, 1000000 do
		local observable = Observable.new(function(sub)
			sub:Fire()
		end)

		local sub = observable:Subscribe(function()
			-- nooopt
		end)

		sub:Destroy()
	end

	print((tick() - startTime) * 1000 .. " ms for 1,000,000")

	return function() end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="229">
                <Properties>
                  <string name="Name">ObservableSubscriptionTable</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	This allows the storage of subscriptions for keys, such that something
	can subscribe onto a key, and events can be invoked onto keys.
	@class ObservableSubscriptionTable
]=]

local require = require(script.Parent.loader).load(script)

local Observable = require("Observable")
local Subscription = require("Subscription")

local ObservableSubscriptionTable = {}
ObservableSubscriptionTable.ClassName = "ObservableSubscriptionTable"
ObservableSubscriptionTable.__index = ObservableSubscriptionTable

export type ObservableSubscriptionTable<T...> = typeof(setmetatable(
	{} :: {
		_subMap: { [any]: { Subscription.Subscription<T...> } },
	},
	{} :: typeof({ __index = ObservableSubscriptionTable })
))

function ObservableSubscriptionTable.new<T...>(): ObservableSubscriptionTable<T...>
	local self: ObservableSubscriptionTable<T...> = setmetatable({} :: any, ObservableSubscriptionTable)

	self._subMap = {} -- { TKey: Subscription<TEmit> }

	return self
end

--[=[
	Fires for the current key the given value
	@param key TKey
	@param ... TEmit
]=]
function ObservableSubscriptionTable.Fire<T...>(self: ObservableSubscriptionTable<T...>, key: any, ...)
	assert(key ~= nil, "Bad key")

	local subs = self._subMap[key]
	if not subs then
		return
	end

	-- Make a copy so we don't have to worry about our last changing
	for _, sub: any in table.clone(subs) do
		if sub:IsPending() then
			-- TODO: Use connection here
			task.spawn(sub.Fire, sub, ...)
		end
	end
end

--[=[
	Returns true if subscription exists

	@param key TKey
	@return boolean
]=]
function ObservableSubscriptionTable.HasSubscriptions<T...>(self: ObservableSubscriptionTable<T...>, key: any): boolean
	return self._subMap[key] ~= nil
end

--[=[
	Completes the subscription

	@param key TKey
]=]
function ObservableSubscriptionTable.Complete<T...>(self: ObservableSubscriptionTable<T...>, key: any): ()
	local subs = self._subMap[key]
	if not subs then
		return
	end

	local subsToComplete = table.clone(subs)
	self._subMap[key] = nil

	for _, sub: any in subsToComplete do
		if sub:IsPending() then
			task.spawn(sub.Complete, sub)
		end
	end
end

--[=[
	Fails the subscription

	@param key TKey
]=]
function ObservableSubscriptionTable.Fail<T...>(self: ObservableSubscriptionTable<T...>, key: any): ()
	local subs = self._subMap[key]
	if not subs then
		return
	end

	local subsToFail = table.clone(subs)
	self._subMap[key] = nil

	for _, sub: any in subsToFail do
		if sub:IsPending() then
			task.spawn(sub.Fail, sub)
		end
	end
end

export type RetrieveInitialValue<T...> = (sub: Subscription.Subscription<T...>) -> ()

--[=[
	Observes for the key
	@param key TKey
	@param retrieveInitialValue callback -- Optional
	@return Observable<TEmit>
]=]
function ObservableSubscriptionTable.Observe<T...>(
	self: ObservableSubscriptionTable<T...>,
	key: any,
	retrieveInitialValue: RetrieveInitialValue<T...>?
): Observable.Observable<T...>
	assert(key ~= nil, "Bad key")

	return Observable.new(function(sub)
		if not self._subMap[key] then
			self._subMap[key] = { sub }
		else
			table.insert(self._subMap[key], sub)
		end

		if retrieveInitialValue then
			retrieveInitialValue(sub)
		end

		return function()
			local current = self._subMap[key]
			if not current then
				return
			end

			-- TODO: Linked list
			local index = table.find(current, sub)
			if not index then
				return
			end

			table.remove(current, index)
			if #current == 0 then
				self._subMap[key] = nil
			end

			-- Complete the subscription
			if sub:IsPending() then
				task.spawn(sub.Complete, sub)
			end
		end
	end)
end

--[=[
	Completes all subscriptions and removes them from the list.
]=]
function ObservableSubscriptionTable.Destroy<T...>(self: ObservableSubscriptionTable<T...>): ()
	while next(self._subMap) do
		local key, list = next(self._subMap)
		assert(key, "Key should not be nil")

		self._subMap[key] = nil

		for _, sub: any in list do
			if sub:IsPending() then
				task.spawn(sub.Complete, sub)
			end
		end
	end
end

return ObservableSubscriptionTable
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="230">
                <Properties>
                  <string name="Name">Rx</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Observable rx library for Roblox by Quenty. This provides a variety of
	composition classes to be used, and is the primary entry point for an
	observable.

	Most of these functions return either a function that takes in an
	observable (curried for piping) or an [Observable](/api/Observable)
	directly.

	@class Rx
]=]

local require = require(script.Parent.loader).load(script)

local CancelToken = require("CancelToken")
local Maid = require("Maid")
local MaidTaskUtils = require("MaidTaskUtils")
local Observable = require("Observable")
local Promise = require("Promise")
local Signal = require("Signal")
local Subscription = require("Subscription")
local Symbol = require("Symbol")
local ThrottledFunction = require("ThrottledFunction")
local cancellableDelay = require("cancellableDelay")

export type Map<Key, Value> = { [Key]: Value }
export type Set<T> = { [T]: true }
export type Predicate<T...> = (T...) -> boolean

local UNSET_VALUE = Symbol.named("unsetValue")
local function identity(...)
	return ...
end

--[=[
	An empty observable that completes immediately
	@prop EMPTY Observable<()>
	@readonly
	@within Rx
]=]

--[=[
	An observable that never completes.
	@prop NEVER Observable<()>
	@readonly
	@within Rx
]=]
local Rx = {
	EMPTY = Observable.new(function(sub)
		sub:Complete()
		return
	end),
	NEVER = Observable.new(function(_)
		return
	end),
}

--[=[
	Pipes the tranformers through each other
	https://rxjs-dev.firebaseapp.com/api/index/function/pipe

	@param transformers { Observable<any> }
	@return (source: Observable<T>) -> Observable<U>
]=]
function Rx.pipe(transformers)
	assert(type(transformers) == "table", "Bad transformers")
	for index, transformer in transformers do
		if type(transformer) ~= "function" then
			error(
				string.format(
					"[Rx.pipe] Bad pipe value of type %q at index %q, expected function",
					type(transformer),
					tostring(index)
				)
			)
		end
	end

	return function(source)
		assert(source, "Bad source")

		local current = source
		for key, transformer in transformers do
			current = transformer(current)

			if not (type(current) == "table" and current.ClassName == "Observable") then
				error(
					string.format(
						"[Rx.pipe] - Failed to transform %q in pipe, made %q (%s)",
						tostring(key),
						tostring(current),
						tostring(type(current) == "table" and current.ClassName or "")
					)
				)
			end
		end

		return current
	end
end

--[=[
	http://reactivex.io/documentation/operators/just.html

	```lua
	Rx.of(1, 2, 3):Subscribe(print, function()
		print("Complete")
	end)) --> 1, 2, 3, "Complete"
	```

	@param ... any -- Arguments to emit
	@return Observable
]=]
function Rx.of<T...>(...: T...): Observable.Observable<T...>
	local args = table.pack(...)

	return Observable.new(function(sub)
		for i = 1, args.n do
			sub:Fire(args[i])
		end

		sub:Complete()
		return
	end)
end

--[=[
	Returns a failed observable

	@param ... any -- Failure args
	@return Observable
]=]
function Rx.failed(...)
	local args = table.pack(...)

	return Observable.new(function(sub)
		sub:Fail(table.unpack(args, 1, args.n))
		return
	end)
end

--[=[
	Converts an item
	http://reactivex.io/documentation/operators/from.html

	@param item Promise | table
	@return Observable
]=]
function Rx.from(item)
	if Promise.isPromise(item) then
		return Rx.fromPromise(item)
	elseif type(item) == "table" then
		return Rx.of(unpack(item))
	else
		-- TODO: Iterator?
		error("[Rx.from] - cannot convert")
	end
end

--[=[
	Converts a promise to an observable.
	@param observable Observable<T>
	@param cancelToken CancelToken?
	@return Promise<T>
]=]
function Rx.toPromise<T...>(
	observable: Observable.Observable<T...>,
	cancelToken: CancelToken.CancelToken?
): Promise.Promise<T...>
	assert(Observable.isObservable(observable), "Bad observable")

	local maid = Maid.new()

	local newCancelToken = CancelToken.new(function(cancel)
		maid:GiveTask(cancel)
		if cancelToken then
			if cancelToken:IsCancelled() then
				cancel()
			else
				maid:GiveTask(cancelToken.Cancelled:Connect(cancel))
			end
		end
	end)

	local promise = Promise.new(function(resolve, reject)
		if newCancelToken:IsCancelled() then
			reject()
			return
		end

		maid:GiveTask(newCancelToken.Cancelled:Connect(function()
			reject()
		end))

		maid:GiveTask(observable:Subscribe(resolve, reject, reject))
	end)

	promise:Finally(function()
		maid:DoCleaning()
	end)

	return promise
end

--[=[
	https://rxjs-dev.firebaseapp.com/api/operators/merge

	@param observables { Observable }
	@return Observable
]=]
function Rx.merge<T...>(observables: { Observable.Observable<T...> }): Observable.Observable<T...>
	assert(type(observables) == "table", "Bad observables")

	local totalCount = 0
	for _, item in observables do
		assert(Observable.isObservable(item), "Not an observable")
		totalCount = totalCount + 1
	end

	return Observable.new(function(sub)
		local maid = Maid.new()
		local pendingCount = totalCount

		for _, observable: any in observables do
			maid:GiveTask(observable:Subscribe(function(...)
				sub:Fire(...)
			end, function(...)
				pendingCount = pendingCount - 1
				sub:Fail(...)
			end, function()
				-- Only complete once all are complete
				pendingCount = pendingCount - 1
				if pendingCount == 0 then
					sub:Complete()
				end
			end))
		end

		return maid
	end)
end

--[=[
	Converts a Signal into an observable.
	https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent

	@param event Signal<T>
	@return Observable<T>
]=]
function Rx.fromSignal<T...>(event: Signal.Signal<T...> | RBXScriptSignal<T...>): Observable.Observable<T...>
	return Observable.new(function(sub)
		-- This stream never completes or fails!
		return (event :: any):Connect(function(...)
			sub:Fire(...)
		end)
	end)
end

--[=[
	Converts a Promise into an observable.
	https://rxjs-dev.firebaseapp.com/api/index/function/from

	@param promise Promise<T>
	@return Observable<T>
]=]
function Rx.fromPromise<T...>(promise: Promise.Promise<T...>): Observable.Observable<T...>
	assert(Promise.isPromise(promise), "Bad promise")

	return Observable.new(function(sub)
		-- Save a task.spawn call
		if not promise:IsPending() then
			local results = table.pack(promise:GetResults())

			if results[1] then
				sub:Fire(table.unpack(results, 2, results.n))
				sub:Complete()
			else
				sub:Fail(table.unpack(results, 2, results.n))
			end
		end

		return task.spawn(function()
			local results = table.pack(promise:Yield())

			if results[1] then
				sub:Fire(table.unpack(results, 2, results.n))
				sub:Complete()
			else
				sub:Fail(table.unpack(results, 2, results.n))
			end
		end)
	end)
end

--[=[
	Taps into the observable and executes the onFire/onError/onComplete
	commands.

	https://rxjs-dev.firebaseapp.com/api/operators/tap

	@param onFire function?
	@param onError function?
	@param onComplete function?
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.tap<T...>(
	onFire: Subscription.FireCallback<T...>?,
	onError: Subscription.FailCallback?,
	onComplete: Subscription.CompleteCallback?
): Observable.Transformer<T..., T...>
	assert(type(onFire) == "function" or onFire == nil, "Bad onFire")
	assert(type(onError) == "function" or onError == nil, "Bad onError")
	assert(type(onComplete) == "function" or onComplete == nil, "Bad onComplete")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(function(...)
				if onFire then
					onFire(...)
				end
				if sub:IsPending() then
					sub:Fire(...)
				end
			end, function(...)
				if onError then
					onError(...)
				end
				sub:Fail(...)
			end, function(...)
				if onComplete then
					onComplete(...)
				end
				sub:Complete(...)
			end)
		end) :: any
	end
end

--[=[
	Starts the observable with the given value from the callback

	http://reactivex.io/documentation/operators/start.html

	@param callback function
	@return (source: Observable) -> Observable
]=]
function Rx.start<T...>(callback: () -> T...): Observable.Transformer<T..., T...>
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			sub:Fire(callback())

			return source:Subscribe(sub:GetFireFailComplete())
		end) :: any
	end
end

--[=[
	Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one Subscriber this Observable will be subscribed and emitting data.
	When all subscribers have unsubscribed it will unsubscribe from the source Observable.

	https://rxjs.dev/api/operators/share

	@return (source: Observable) -> Observable
]=]
function Rx.share<T...>(): Observable.Transformer<T..., T...>
	return function(source)
		local shareMaid = Maid.new()
		local subs: { Subscription.Subscription<T...> } = {}

		local lastFail = UNSET_VALUE
		local lastComplete = UNSET_VALUE

		local function connectToSourceIfNeeded()
			if not shareMaid._currentSub then
				lastFail = UNSET_VALUE
				lastComplete = UNSET_VALUE

				shareMaid._currentSub = source:Subscribe(function(...)
					for _, sub: any in subs do
						sub:Fire(...)
					end
				end, function(...)
					lastFail = table.pack(...)
					for _, sub: any in subs do
						sub:Fail(...)
					end
				end, function(...)
					lastComplete = table.pack(...)
					for _, sub: any in subs do
						sub:Complete(...)
					end
				end)
			end
		end

		local function disconnectFromSource()
			shareMaid._currentSub = nil

			lastFail = UNSET_VALUE
			lastComplete = UNSET_VALUE
		end

		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			if lastFail ~= UNSET_VALUE then
				sub:Fail(table.unpack(lastFail, 1, lastFail.n))
				return
			end

			if lastComplete ~= UNSET_VALUE then
				sub:Fail(table.unpack(lastComplete, 1, lastComplete.n))
				return
			end

			table.insert(subs, sub)
			connectToSourceIfNeeded()

			return function()
				local index = table.find(subs, sub)
				if index then
					table.remove(subs, index)

					if #subs == 0 then
						disconnectFromSource()
					end
				end
			end
		end) :: any
	end
end

--[=[
	Same as [Rx.share] except it also replays the value

	@param bufferSize number? -- Number of entries to cache
	@param windowTimeSeconds number? -- Time
	@return (source: Observable) -> Observable
]=]
function Rx.shareReplay<T...>(bufferSize: number?, windowTimeSeconds: number?): Observable.Transformer<T..., T...>
	assert(type(bufferSize) == "number" or bufferSize == nil, "Bad bufferSize")
	assert(type(windowTimeSeconds) == "number" or windowTimeSeconds == nil, "Bad windowTimeSeconds")

	local maxBufferSize = bufferSize or math.huge
	local windowTime = windowTimeSeconds or math.huge

	return function(source)
		local shareMaid = Maid.new()
		local subs: { Subscription.Subscription<T...> } = {}

		type Event = {
			n: number,
			timestamp: number,
		}

		local buffer: { Event } = {}
		local lastFail = UNSET_VALUE
		local lastComplete = UNSET_VALUE

		local function getEventsCopy(): { Event }
			local now = os.clock()
			local events = {}

			for _, event in buffer do
				if (now - event.timestamp) <= windowTime then
					table.insert(events, event)
				end
			end

			return events
		end

		local function connectToSourceIfNeeded()
			if not shareMaid._currentSub then
				buffer = {}
				lastFail = UNSET_VALUE
				lastComplete = UNSET_VALUE

				shareMaid._currentSub = source:Subscribe(function(...)
					-- TODO: also prune events by timestamp

					if #buffer + 1 > maxBufferSize then
						table.remove(buffer, 1) -- O(n), not great.
					end

					-- Queue before we start
					local event: any = table.pack(...)
					event.timestamp = os.clock()
					table.insert(buffer, event)

					-- Copy subs so removal doesn't affect replay
					for _, sub: any in table.clone(subs) do
						if sub:IsPending() then
							sub:Fire(table.unpack(event, 1, event.n))
						end
					end
				end, function(...)
					lastFail = table.pack(...)

					-- Copy subs so removal doesn't affect replay
					for _, sub: any in table.clone(subs) do
						if sub:IsPending() then
							sub:Fail(...)
						end
					end
				end, function(...)
					lastComplete = table.pack(...)

					-- Copy subs so removal doesn't affect replay
					for _, sub: any in table.clone(subs) do
						if sub:IsPending() then
							sub:Complete(...)
						end
					end
				end)
			end
		end

		local function disconnectFromSource()
			shareMaid._currentSub = nil

			buffer = {}
			lastFail = UNSET_VALUE
			lastComplete = UNSET_VALUE
		end

		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			if lastFail ~= UNSET_VALUE then
				sub:Fail(table.unpack(lastFail, 1, lastFail.n))
				return
			end

			if lastComplete ~= UNSET_VALUE then
				sub:Fail(table.unpack(lastComplete, 1, lastComplete.n))
				return
			end

			table.insert(subs, sub)

			-- Firing could lead to re-entrance. Lets just use the buffer as-is.
			for _, item in getEventsCopy() do
				sub:Fire(table.unpack(item, 1, item.n))
			end

			connectToSourceIfNeeded()

			return function()
				local index = table.find(subs, sub)
				if index then
					table.remove(subs, index)

					if #subs == 0 then
						disconnectFromSource()
					end
				end
			end
		end) :: any
	end
end

--[=[
	Caches the current value

	@return (source: Observable) -> Observable
]=]
function Rx.cache<T...>(): Observable.Transformer<T..., T...>
	return Rx.shareReplay(1)
end

--[=[
	Like start, but also from (list!)

	@param callback () -> { T }
	@return (source: Observable) -> Observable
]=]
function Rx.startFrom<T, U>(callback: () -> { U }): Observable.Transformer<(T), (U | T)>
	assert(type(callback) == "function", "Bad callback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			for _, value in callback() do
				sub:Fire(value)
			end

			return source:Subscribe(sub:GetFireFailComplete())
		end) :: any
	end
end

--[=[
	Starts with the given values
	https://rxjs-dev.firebaseapp.com/api/operators/startWith

	@param values { T }
	@return (source: Observable) -> Observable
]=]
function Rx.startWith<T, U>(values: { U }): Observable.Transformer<(T), (T | U)>
	assert(type(values) == "table", "Bad values")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			for _, item in values do
				sub:Fire(item)
			end

			return source:Subscribe(sub:GetFireFailComplete())
		end) :: any
	end
end

--[=[
	The Scan operator applies a function to the first item emitted by the source Observable and then
	emits the result of that function as its own first emission. It also feeds the result of the function
	back into the function along with the second item emitted by the source Observable in order to generate
	its second emission. It continues to feed back its own subsequent emissions along with the subsequent
	emissions from the source Observable in order to create the rest of its sequence.

	https://reactivex.io/documentation/operators/scan.html

	@param accumulator (T, U...) -> T
	@param seed T?
	@return (source: Observable) -> Observable
]=]
function Rx.scan<T, U...>(accumulator: (T?, U...) -> T, seed: T?): Observable.Transformer<(U...), (T)>
	assert(type(accumulator) == "function", "Bad accumulator")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local current: T? = seed

			return source:Subscribe(function(...)
				current = accumulator(current, ...)
				sub:Fire(current)
			end, sub:GetFailComplete())
		end) :: any
	end
end

--[=[
	The Reduce operator applies a function to the first item emitted by the source Observable and
	then feeds the result of the function back into the function along with the second item emitted
	by the source Observable, continuing this process until the source Observable emits its final
	item and completes, whereupon the Observable returned from Reduce emits the final value returned
	from the function.

	https://reactivex.io/documentation/operators/reduce.html

	@param reducer function
	@param seed any | nil
	@return (source: Observable) -> Observable
]=]
function Rx.reduce(reducer, seed)
	assert(type(reducer) == "function", "Bad reducer")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()
			local current = seed

			maid:GiveTask(source:Subscribe(function(...)
				current = reducer(current, ...)
			end, function(...)
				sub:Fail(...)
			end, function()
				-- On complete emit the result.
				sub:Fire(current)
			end))

			return maid
		end)
	end
end

--[=[
	Defaults the observable to a value if it isn't fired immediately

	```lua
	Rx.NEVER:Pipe({
		Rx.defaultsTo("Hello")
	}):Subscribe(print) --> Hello
	```

	If empty (or failed) the the sub will fire with the value before it completes.

	@param value any
	@return (source: Observable) -> Observable
]=]
function Rx.defaultsTo(value)
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local fired = false

			maid:GiveTask(source:Subscribe(function(...)
				fired = true
				sub:Fire(...)
			end, function(...)
				if not fired then
					fired = true
					sub:Fire(value)
				end
				sub:Fail(...)
			end, function(...)
				if not fired then
					fired = true
					sub:Fire(value)
				end
				sub:Complete(...)
			end))

			if not fired then
				fired = true
				sub:Fire(value)
			end

			return maid
		end)
	end
end

--[=[
	Defaults the observable value to nil

	```lua
	Rx.NEVER:Pipe({
		Rx.defaultsToNil
	}):Subscribe(print) --> nil
	```

	Great for defaulting Roblox attributes and objects

	@function defaultsToNil
	@param source Observable
	@return Observable
	@within Rx
]=]
Rx.defaultsToNil = Rx.defaultsTo(nil)

--[=[
	Ends the observable with these values before cancellation
	https://www.learnrxjs.io/learn-rxjs/operators/combination/endwith

	@param values { T }
	@return (source: Observable) -> Observable
]=]
function Rx.endWith(values)
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(...)
				sub:Fire(...)
			end, function(...)
				for _, item in values do
					sub:Fire(item)
				end
				sub:Fail(...)
			end, function()
				for _, item in values do
					sub:Fire(item)
				end
				sub:Complete()
			end))

			return maid
		end)
	end
end

--[=[
	http://reactivex.io/documentation/operators/filter.html

	Filters out values

	```lua
	Rx.of(1, 2, 3, 4, 5):Pipe({
		Rx.where(function(value)
			return value % 2 == 0;
		end)
	}):Subscribe(print) --> 2, 4
	```
	@param predicate (value: T) -> boolean
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.where<T...>(predicate: Predicate<T...>): Observable.Transformer<T..., T...>
	assert(type(predicate) == "function", "Bad predicate callback")

	return function(source: Observable.Observable<T...>)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(function(...)
				if predicate(...) then
					sub:Fire(...)
				end
			end, sub:GetFailComplete())
		end) :: any
	end
end

--[=[
	Only takes distinct values from the observable stream.

	http://reactivex.io/documentation/operators/distinct.html

	```lua
	Rx.of(1, 1, 2, 3, 3, 1):Pipe({
		Rx.distinct();
	}):Subscribe(print) --> 1, 2, 3, 1
	```
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.distinct<T...>(): Observable.Transformer<T..., T...>
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local last = UNSET_VALUE

			return source:Subscribe(function(value)
				-- TODO: Support tuples
				if last == value then
					return
				end

				last = value
				sub:Fire(last)
			end, sub:GetFailComplete())
		end) :: any
	end
end

--[=[
	https://rxjs.dev/api/operators/mapTo
	@param ... any -- The value to map each source value to.
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.mapTo(...)
	local args = table.pack(...)
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(function()
				sub:Fire(table.unpack(args, 1, args.n))
			end, sub:GetFailComplete())
		end)
	end
end

--[=[
	http://reactivex.io/documentation/operators/map.html

	Maps one value to another

	```lua
	Rx.of(1, 2, 3, 4, 5):Pipe({
		Rx.map(function(x)
			return x + 1
		end)
	}):Subscribe(print) -> 2, 3, 4, 5, 6
	```

	@param project (T) -> U
	@return (source: Observable<T>) -> Observable<U>
]=]
function Rx.map<T..., U...>(project: (T...) -> U...): Observable.Transformer<T..., U...>
	assert(type(project) == "function", "Bad project callback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(function(...)
				sub:Fire(project(...))
			end, sub:GetFailComplete())
		end) :: any
	end
end

--[=[
	Merges higher order observables together.

	Basically, if you have an observable that is emitting an observable,
	this subscribes to each emitted observable and combines them into a
	single observable.

	```lua
	Rx.of(Rx.of(1, 2, 3), Rx.of(4))
		:Pipe({
			Rx.mergeAll();
		})
		:Subscribe(print) -> 1, 2, 3, 4
	```

	@return (source: Observable<Observable<T>>) -> Observable<T>
]=]
function Rx.mergeAll<T...>(): Observable.Transformer<Observable.Observable<T...>, T...>
	return Rx.flatMap(identity)
end

--[=[
	Merges higher order observables together

	https://rxjs.dev/api/operators/switchAll

	Works like mergeAll, where you subscribe to an observable which is
	emitting observables. However, when another observable is emitted it
	disconnects from the other observable and subscribes to that one.

	@return (source: Observable<Observable<T>>) -> Observable<T>
]=]
function Rx.switchAll<T...>(): Observable.Transformer<Observable.Observable<T...>, T...>
	return Rx.switchMap(identity)
end

--[=[
	Sort of equivalent of promise.then()

	This takes a stream of observables

	@param project (value: T) -> Observable<U>
	@return (source: Observable<T>) -> Observable<U>
]=]
function Rx.flatMap<T..., U...>(project: (T...) -> Observable.Observable<U...>): Observable.Transformer<(T...), (U...)>
	assert(type(project) == "function", "Bad project")

	return function(source: Observable.Observable<T...>)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub: Subscription.Subscription<U...>)
			local isComplete: boolean = false
			local pendingCount: number = 0
			local subscriptions: Set<Subscription.Subscription<U...>> = {}

			local function checkComplete()
				if isComplete and pendingCount == 0 then
					sub:Complete()
				end
			end

			local function onNextObservable(...: T...)
				local observable: Observable.Observable<U...> = project(...)
				assert(Observable.isObservable(observable), "Bad observable returned from subscription project call")

				if not sub:IsPending() then
					-- Projecting last subscription cancelled us
					return
				end

				local innerCompleteOrFail = false
				local subscription: Subscription.Subscription<U...>? = nil

				local function onNext(...: U...)
					if innerCompleteOrFail or pendingCount == 0 then
						return
					end

					sub:Fire(...)
				end

				local function onFail(...)
					if innerCompleteOrFail or pendingCount == 0 then
						return
					end

					if subscription then
						-- Trust subscription to clean itself up in this scenario
						subscriptions[subscription] = nil
						subscription = nil
					end

					pendingCount = 0
					sub:Fail(...)
				end

				local function onComplete()
					if innerCompleteOrFail or pendingCount == 0 then
						return
					end

					innerCompleteOrFail = true
					pendingCount -= 1

					if subscription then
						-- Trust subscription to clean itself up in this scenario
						subscriptions[subscription] = nil
						subscription = nil
					end

					checkComplete()
				end

				pendingCount += 1
				local newSub = observable:Subscribe(onNext, onFail, onComplete)
				subscription = newSub

				if innerCompleteOrFail or not sub:IsPending() then
					-- Subscribing cancelled ourselves in some way
					newSub:Destroy()
					return
				end

				subscriptions[newSub] = true
			end

			local outerSubscription = source:Subscribe(onNextObservable, function(...)
				sub:Fail(...)
			end, function()
				isComplete = true
				checkComplete()
			end)

			return function()
				pendingCount = 0

				for subscription: any in subscriptions do
					subscription:Destroy()
				end

				outerSubscription:Destroy()
			end
		end) :: any
	end
end

--[=[
	Switches to a new observable from the current observable

	https://rxjs.dev/api/operators/switchMap

	As each observable shows up, a new observable is mapped from that observable.

	The old observable is disconnected.

	Use Rx.switchMap to switch to a new RunService event

	```lua
	Rx.of(1, 2, 3):Pipe({
		Rx.switchMap(function(value)
			local startTime = os.clock()

			-- Only the last observable returned will continue to emit,
			-- others are disconnected.
			return Rx.of(RunService.RenderStepped):Pipe({
				Rx.map(function()
					return os.clock() - startTime, value
				end);
			});
		end);
	}):Subscribe(print) --> 0.002352342, 3
	```

	Use Rx.switchMap() as a simple map...

	```lua
	Rx.of(1, 2, 3):Pipe({
		Rx.switchMap(function(value)
			print(value) --> 1 (and then 2, and then 3)

			return Rx.of(value*2)
		end);
	}):Subscribe(print) --> 2, 4, 6

	```

	Use Rx.switchMap() with delayed input (to swap to a new one)

	```lua
	Rx.of(1, 2, 3):Pipe({
		Rx.switchMap(function(value)
			-- Emit 1 second later
			return Rx.of(value*2):Pipe({
				Rx.delay(1); -- These will each get cancelled
			})
		end);
	}):Subscribe(print) --> 6 (other results were cancelled)
	```

	@param project function
	@return Observable
]=]
function Rx.switchMap<T..., U...>(project: (T...) -> Observable.Observable<U...>): Observable.Transformer<(T...), (U...)>
	assert(type(project) == "function", "Bad project")

	return function(source: Observable.Observable<T...>)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub: Subscription.Subscription<U...>)
			local isComplete: boolean = false
			local insideComplete: boolean = false
			local insideSubscription: Subscription.Subscription<T...>? = nil
			local outerIndex: number? = 0

			local function checkComplete()
				if isComplete and insideComplete then
					outerIndex = nil
					sub:Complete()
				end
			end

			local function onNextObservable(...)
				insideComplete = false

				local observable: Observable.Observable<U...> = project(...)
				assert(Observable.isObservable(observable), "Bad observable returned from subscription project call")

				-- Handle cancellation when external callers do weird state stuff
				if not outerIndex then
					return
				end

				local index = outerIndex + 1
				outerIndex = index

				-- Cancel previous subscription
				if insideSubscription then
					insideSubscription:Destroy()
					insideSubscription = nil
				end

				if not sub:IsPending() or index ~= outerIndex then
					-- Cancelling last subscription cancelled us
					return
				end

				local function onNext(...: U...)
					if index ~= outerIndex then
						return
					end

					sub:Fire(...)
				end

				local function onFail(...)
					if index ~= outerIndex then
						return
					end

					insideSubscription = nil -- trust subscription to clean itself up
					outerIndex = nil
					sub:Fail(...)
				end

				local function onComplete()
					if index ~= outerIndex then
						return
					end

					insideSubscription = nil -- trust subscription to clean itself up
					insideComplete = true
					checkComplete()
				end

				local subscription = observable:Subscribe(onNext, onFail, onComplete)

				if not sub:IsPending() or index ~= outerIndex then
					-- Subscribing cancelled ourselves
					subscription:Destroy()
					return
				end

				insideSubscription = subscription :: any
			end

			local outerSubscription = source:Subscribe(onNextObservable, function(...)
				outerIndex = nil
				sub:Fail(...)
			end, function()
				isComplete = true
				checkComplete()
			end)

			return function()
				outerIndex = nil

				if insideSubscription then
					insideSubscription:Destroy()
					insideSubscription = nil
				end

				outerSubscription:Destroy()
			end
		end) :: any
	end
end

function Rx.takeUntil(notifier)
	assert(Observable.isObservable(notifier))

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()
			local cancelled = false

			local function cancel()
				maid:DoCleaning()
				cancelled = true
			end

			-- Any value emitted will cancel (complete without any values allows all values to pass)
			maid:GiveTask(notifier:Subscribe(cancel, cancel, nil))

			-- Cancelled immediately? Oh boy.
			if cancelled then
				maid:DoCleaning()
				return nil
			end

			-- Subscribe!
			maid:GiveTask(source:Subscribe(sub:GetFireFailComplete()))

			return maid
		end)
	end
end

--[=[
	Returns an observable that takes in a tuple, and emits that tuple, then
	completes.

	```lua
	Rx.packed("a", "b")
		:Subscribe(function(first, second)
			print(first, second) --> a, b
		end)
	```

	@param ... any
	@return Observable
]=]
function Rx.packed<T...>(...: T...): Observable.Observable<T...>
	local args = table.pack(...)

	return Observable.new(function(sub)
		sub:Fire(unpack(args, 1, args.n))
		sub:Complete()
		return
	end) :: any
end

--[=[
	Unpacks the observables value if a table is received
	@param observable Observable<{T}>
	@return Observable<T>
]=]
function Rx.unpacked(observable)
	assert(Observable.isObservable(observable), "Bad observable")

	return Observable.new(function(sub)
		return observable:Subscribe(function(value)
			if type(value) == "table" then
				sub:Fire(unpack(value))
			else
				warn(string.format("[Rx.unpacked] - Observable didn't return a table got type %q", type(value)))
			end
		end, sub:GetFailComplete())
	end)
end

--[=[
	Acts as a finalizer callback once the subscription is unsubscribed.

	```lua
		Rx.of("a", "b"):Pipe({
			Rx.finalize(function()
				print("Subscription done!")
			end);
		})
	```

	http://reactivex.io/documentation/operators/do.html
	https://rxjs-dev.firebaseapp.com/api/operators/finalize
	https://github.com/ReactiveX/rxjs/blob/master/src/internal/operators/finalize.ts

	@param finalizerCallback () -> ()
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.finalize(finalizerCallback)
	assert(type(finalizerCallback) == "function", "Bad finalizerCallback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(sub:GetFireFailComplete()))
			maid:GiveTask(finalizerCallback)

			return maid
		end)
	end
end

--[=[
	Given an observable that emits observables, emit an
	observable that once the initial observable completes,
	the latest values of each emitted observable will be
	combined into an array that will be emitted.

	https://rxjs.dev/api/operators/combineLatestAll

	@return (source: Observable<Observable<T>>) -> Observable<{ T }>
]=]
function Rx.combineLatestAll()
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local observables = {}
			local maid = Maid.new()

			local alive = true
			maid:GiveTask(function()
				alive = false
			end)

			maid:GiveTask(source:Subscribe(function(value)
				assert(Observable.isObservable(value))

				table.insert(observables, value)
			end, function(...)
				sub:Fail(...)
			end, function()
				if not alive then
					return
				end

				maid:GiveTask(Rx.combineLatest(observables):Subscribe(sub:GetFireFailComplete()))
			end))

			return maid
		end)
	end
end

--[=[
	The same as combineLatestAll.

	This is for backwards compatability, and is deprecated.

	@function combineAll
	@deprecated 1.0.0 -- Use Rx.combineLatestAll
	@within Rx
	@return (source: Observable<Observable<T>>) -> Observable<{ T }>
]=]
Rx.combineAll = Rx.combineLatestAll

--[=[
	Catches an error, and allows another observable to be subscribed
	in terms of handling the error.

	:::warning
	This method is not yet tested
	:::

	@param callback (error: TError) -> Observable<TErrorResult>
	@return (source: Observable<T>) -> Observable<T | TErrorResult>
]=]
function Rx.catchError(callback)
	assert(type(callback) == "function", "Bad callback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			-- Yikes, let's hope event ordering is good
			local alive = true
			maid:GiveTask(function()
				alive = false
			end)

			maid:GiveTask(source:Subscribe(function(...)
				sub:Fire(...)
			end, function(...)
				if not alive then
					-- if we failed because maid was cancelled, then we'll get called here?
					-- I think.
					return
				end

				-- at this point, we can only have one error, so we need to subscribe to the result
				-- and continue the observiable
				local observable = callback(...)
				assert(Observable.isObservable(observable), "Bad observable")

				maid:GiveTask(observable:Subscribe(sub:GetFireFailComplete()))
			end, function()
				sub:Complete()
			end))

			return maid
		end)
	end
end

--[=[
	One of the most useful functions this combines the latest values of
	observables at each chance!

	```lua
	Rx.combineLatest({
		child = Rx.fromSignal(Workspace.ChildAdded);
		lastChildRemoved = Rx.fromSignal(Workspace.ChildRemoved);
		value = 5;

	}):Subscribe(function(data)
		print(data.child) --> last child
		print(data.lastChildRemoved) --> other value
		print(data.value) --> 5
	end)

	```

	:::tip
	Note that the resulting observable will not emit until all input
	observables are emitted.
	:::

	@param observables { [TKey]: Observable<TEmitted> | TEmitted }
	@return Observable<{ [TKey]: TEmitted }>
]=]
function Rx.combineLatest<K, V>(observables: Map<K, Observable.Observable<V> | V>): Observable.Observable<Map<K, V>>
	assert(type(observables) == "table", "Bad observables")

	return Observable.new(function(sub)
		local unset = 0
		local latest: Map<K, V> = {}

		-- Instead of caching this, use extra compute here
		for key, value in observables do
			if Observable.isObservable(value) then
				unset += 1
				latest[key] = UNSET_VALUE
			else
				latest[key] = value :: V
			end
		end

		if unset == 0 then
			sub:Fire(latest)
			sub:Complete()
			return
		end

		local pending = unset
		local maid = Maid.new()

		local function failOnFirst(...)
			pending -= 1
			latest = nil :: any
			sub:Fail(...)
		end

		local function completeOnAllPendingDone()
			pending -= 1
			if pending == 0 then
				latest = nil :: any
				sub:Complete()
			end
		end

		for key, observer: any in observables do
			if not Observable.isObservable(observer) then
				continue
			end

			maid:GiveTask(observer:Subscribe(function(value)
				if latest[key] == UNSET_VALUE then
					unset -= 1
				end

				latest[key] = value

				if unset == 0 then
					sub:Fire(table.freeze(table.clone(latest)))
				end
			end, failOnFirst, completeOnAllPendingDone))
		end

		return maid
	end) :: any
end

--[=[
	Equivalent of [Rx.combineLatest] and [Rx.throttleDefer] but avoids copying and emitting a new table
	until after the frame ends. Helpful in scenarios where we write multiple times to a single value in a
	frame, and we don't want to create a lot of work for the garbage collector.

	@param observables { [TKey]: Observable<TEmitted> | TEmitted }
	@return Observable<{ [TKey]: TEmitted }>
]=]
function Rx.combineLatestDefer(observables)
	assert(type(observables) == "table", "Bad observables")

	return Observable.new(function(sub)
		local pending = 0
		local unset = 0
		local latest: any = {}

		-- Instead of caching this, use extra compute here
		for key, value in observables do
			if Observable.isObservable(value) then
				pending += 1
				unset += 1
				latest[key] = UNSET_VALUE
			else
				latest[key] = value
			end
		end

		if pending == 0 then
			sub:Fire(latest)
			sub:Complete()
			return
		end

		local maid = Maid.new()

		local function failOnFirst(...)
			pending -= 1
			latest = nil
			sub:Fail(...)
		end

		local function completeOnAllPendingDone()
			pending -= 1
			if pending == 0 then
				latest = nil
				sub:Complete()
			end
		end

		local queueThread: thread? = nil
		maid:GiveTask(function()
			if queueThread then
				MaidTaskUtils.doTask(queueThread)
			end
		end)

		for key, observer in observables do
			if not Observable.isObservable(observer) then
				continue
			end

			maid:GiveTask(observer:Subscribe(function(value)
				if latest[key] == UNSET_VALUE then
					unset -= 1
				end

				latest[key] = value

				if unset == 0 and not queueThread then
					queueThread = task.defer(function()
						queueThread = nil
						sub:Fire(table.freeze(table.clone(latest)))
					end)
				end
			end, failOnFirst, completeOnAllPendingDone))
		end

		return maid
	end)
end

--[=[
	http://reactivex.io/documentation/operators/using.html

	Each time a subscription occurs, the resource is constructed
	and exists for the lifetime of the observation. The observableFactory
	uses the resource for subscription.

	:::note
	Note from Quenty: I haven't found this that useful.
	:::

	@param resourceFactory () -> MaidTask
	@param observableFactory (MaidTask) -> Observable<T>
	@return Observable<T>
]=]
function Rx.using(resourceFactory, observableFactory)
	return Observable.new(function(sub)
		local maid = Maid.new()

		local resource = resourceFactory()
		maid:GiveTask(resource)

		local observable = observableFactory(resource)
		assert(Observable.isObservable(observable), "Bad observable")

		maid:GiveTask(observable:Subscribe(sub:GetFireFailComplete()))

		return maid
	end)
end

--[=[
	Takes the first entry and terminates the observable. Equivalent to the following:

	```lua
	Rx.take(1)
	```

	https://reactivex.io/documentation/operators/first.html
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.first()
	return Rx.take(1)
end

--[=[
	Takes n entries and then completes the observation.

	https://rxjs.dev/api/operators/take
	@param number number
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.take<T...>(number: number): Observable.Transformer<T..., T...>
	assert(type(number) == "number", "Bad number")
	assert(number > 0, "Bad number")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local taken = 0
			local maid = Maid.new()

			maid._sub = source:Subscribe(function(...)
				if taken >= number then
					warn("[Rx.take] - Still getting values past subscription")
					return
				end

				taken = taken + 1
				sub:Fire(...)

				if taken >= number then
					sub:Complete()

					-- Paranoid disconnect, even though our parent should also disconnect
					maid._sub = nil
				end
			end, sub:GetFailComplete())

			return maid
		end) :: any
	end
end

--[=[
	Takes n entries and then completes the observation.

	https://rxjs.dev/api/operators/take
	@param toSkip number
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.skip<T...>(toSkip: number): Observable.Transformer<T..., T...>
	assert(type(toSkip) == "number", "Bad toSkip")
	assert(toSkip > 0, "Bad toSkip")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local skipped = 0
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(...)
				if skipped < toSkip then
					skipped = skipped + 1
					return
				end

				sub:Fire(...)
			end, sub:GetFailComplete()))

			return maid
		end) :: any
	end
end

--[=[
	Defers the subscription and creation of the observable until the
	actual subscription of the observable.

	https://rxjs-dev.firebaseapp.com/api/index/function/defer
	https://netbasal.com/getting-to-know-the-defer-observable-in-rxjs-a16f092d8c09

	@param observableFactory () -> Observable<T>
	@return Observable<T>
]=]
function Rx.defer<T>(observableFactory: () -> Observable.Observable<T>): Observable.Observable<T>
	return Observable.new(function(sub)
		local observable
		local ok, err = pcall(function()
			observable = observableFactory()
		end)

		if not ok then
			sub:Fail(err)
			return
		end

		if not Observable.isObservable(observable) then
			sub:Fail("Not an observable")
			return
		end

		return observable:Subscribe(sub:GetFireFailComplete())
	end) :: any
end

--[=[
	Shift the emissions from an Observable forward in time by a particular amount.

	@param seconds number
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.delay<T...>(seconds: number): Observable.Transformer<T..., T...>
	assert(type(seconds) == "number", "Bad seconds")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub: Subscription.Subscription<T...>)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(...)
				local args = table.pack(...)

				maid[args] = cancellableDelay(seconds, function()
					maid[args] = nil
					sub:Fire(table.unpack(args, 1, args.n))
				end)
			end, sub:GetFailComplete()))

			return maid
		end) :: any
	end
end

--[=[
	Creates an observable that will emit N seconds later.

	@param seconds number
	@return Observable<()>
]=]
function Rx.delayed(seconds: number)
	assert(type(seconds) == "number", "Bad seconds")

	return Observable.new(function(sub)
		return task.delay(seconds, function()
			sub:Fire()
		end)
	end)
end

--[=[
	Emits output every `n` seconds

	@param initialDelaySeconds number
	@param seconds number
	@return (source: Observable<number>) -> Observable<number>
]=]
function Rx.timer(initialDelaySeconds: number, seconds: number)
	assert(type(initialDelaySeconds) == "number" or initialDelaySeconds == nil, "Bad initialDelaySeconds")
	assert(type(seconds) == "number", "Bad seconds")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local number = -1

		maid:GiveTask(task.spawn(function()
			if initialDelaySeconds and initialDelaySeconds > 0 then
				task.wait(initialDelaySeconds)
			end

			while true do
				number += 1
				sub:Fire(number)
				task.wait(seconds)
			end
		end))

		return maid
	end)
end

--[=[
	https://www.learnrxjs.io/learn-rxjs/operators/creation/interval

	@param seconds number
	@return (source: Observable<number>) -> Observable<number>
]=]
function Rx.interval(seconds: number)
	assert(type(seconds) == "number", "Bad seconds")

	return Rx.timer(0, seconds)
end

--[=[
	Honestly, I have not used this one much.

	https://rxjs-dev.firebaseapp.com/api/operators/withLatestFrom
	https://medium.com/js-in-action/rxjs-nosy-combinelatest-vs-selfish-withlatestfrom-a957e1af42bf

	@param inputObservables {Observable<TInput>}
	@return (source: Observable<T>) -> Observable<{T, ...TInput}>
]=]
function Rx.withLatestFrom(inputObservables)
	assert(inputObservables, "Bad inputObservables")

	for _, observable in inputObservables do
		assert(Observable.isObservable(observable), "Bad observable")
	end

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local latest = {}

			for key, observable in inputObservables do
				latest[key] = UNSET_VALUE

				maid:GiveTask(observable:Subscribe(function(value)
					latest[key] = value
				end, nil, nil))
			end

			maid:GiveTask(source:Subscribe(function(value)
				for _, item in latest do
					if item == UNSET_VALUE then
						return
					end
				end

				sub:Fire({ value, unpack(latest) })
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Throttles emission of observables.

	https://rxjs-dev.firebaseapp.com/api/operators/throttleTime

	:::note
	Note that on complete, the last item is not included, for now, unlike the existing version in rxjs.
	:::

	@param duration number
	@param throttleConfig { leading = true; trailing = true; }
	@return (source: Observable) -> Observable
]=]
function Rx.throttleTime(duration: number, throttleConfig: ThrottledFunction.ThrottleConfig)
	assert(type(duration) == "number", "Bad duration")
	assert(type(throttleConfig) == "table" or throttleConfig == nil, "Bad throttleConfig")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local throttledFunction = ThrottledFunction.new(duration, function(...)
				sub:Fire(...)
			end, throttleConfig)

			maid:GiveTask(throttledFunction)
			maid:GiveTask(source:Subscribe(function(...)
				throttledFunction:Call(...)
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Only emits events after the deferred first signal.

	@return (source: Observable) -> Observable
]=]
function Rx.onlyAfterDefer()
	return function(observable)
		return Observable.new(function(sub)
			local isReady = false
			task.defer(function()
				isReady = true
			end)

			return observable:Subscribe(function(...)
				if isReady then
					sub:Fire(...)
				end
			end, sub:GetFailComplete())
		end)
	end
end

--[=[
	Throttles emission of observables on the defer stack to the last emission.

	:::tip
	There's a limited re-entrance amount for this. However, this can prevent computation being done repeatedly if
	stuff is being added all at once. Use with care.
	:::

	@return (source: Observable) -> Observable
]=]
function Rx.throttleDefer<T...>(): Observable.Transformer<T..., T...>
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local lastResult: any = nil
			local currentQueue: thread? = nil

			local sourceSub = source:Subscribe(function(...)
				if lastResult then
					lastResult = table.pack(...)
					return
				end

				lastResult = table.pack(...)

				-- Queue up our result
				currentQueue = task.defer(function()
					local current = lastResult
					lastResult = nil
					currentQueue = nil

					if sub:IsPending() then
						sub:Fire(table.unpack(current, 1, current.n))
					end
				end)
			end, sub:GetFailComplete())

			return function()
				if currentQueue then
					task.cancel(currentQueue)
					currentQueue = nil
				end

				sourceSub:Destroy()
			end
		end) :: any
	end
end

--[=[
	Throttles emission of observables on the defer stack to the last emission.

	https://rxjs.dev/api/operators/throttle

	@param durationSelector (T: value) -> Observable
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.throttle(durationSelector)
	assert(type(durationSelector) == "function", "Bad durationSelector")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local topMaid = Maid.new()

			local lastResult: any

			topMaid:GiveTask(source:Subscribe(function(...)
				if not lastResult then
					lastResult = table.pack(...)

					-- Queue up our result
					local maid = Maid.new()

					maid:GiveTask(durationSelector(lastResult):Subscribe(function()
						local current = lastResult
						lastResult = nil

						if sub:IsPending() then
							sub:Fire(table.unpack(current, 1, current.n))
						end

						if topMaid._currentQueue == maid then
							topMaid._currentQueue = nil
						end
					end))

					topMaid._currentQueue = maid
				else
					lastResult = table.pack(...)
				end
			end, sub:GetFailComplete()))

			return topMaid
		end)
	end
end

--[=[
	Skips over values emitted by the source observable until a passed-in notifier observable emits a value.

	https://rxjs.dev/api/operators/skipUntil

	@param notifier Observable
	@return (source: Observable) -> Observable
]=]
function Rx.skipUntil(notifier)
	assert(Observable.isObservable(notifier), "Bad observable")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()
			local taking = false

			maid._skipping = notifier:Subscribe(function()
				maid._skipping = nil
				taking = true
			end)

			maid:GiveTask(source:Subscribe(function(...)
				if taking then
					sub:Fire(...)
				end
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Skips over values emitted by the source observable as long as the given predicate is true.

	https://rxjs.dev/api/index/function/skipWhile

	@param predicate (index: number, ...: any) -> boolean
	@return (source: Observable) -> Observable
]=]
function Rx.skipWhile(predicate)
	assert(type(predicate) == "function", "Bad predicate")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local skipping = true
			local index = 0

			return source:Subscribe(function(...)
				if not skipping then
					sub:Fire(...)
					return
				end

				index += 1

				skipping = predicate(index, ...)
			end, sub:GetFailComplete())
		end)
	end
end

--[=[
	Emits values from the source observable as long as the given predicate is true. Completes if the predicate is false.

	https://rxjs.dev/api/index/function/takeWhile

	@param predicate (index: number, ...: any) -> boolean
	@return (source: Observable) -> Observable
]=]
function Rx.takeWhile(predicate)
	assert(type(predicate) == "function", "Bad predicate")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local index = 0

			return source:Subscribe(function(...)
				index += 1

				if predicate(index, ...) then
					sub:Fire(...)
				else
					sub:Complete()
				end
			end, sub:GetFailComplete())
		end)
	end
end

--[=[
	Applies an accumulator function over the source Observable where the accumulator function itself returns an Observable,
	emitting values only from the most recently returned Observable.

	https://rxjs.dev/api/index/function/switchScan

	@param accumulator function
	@param seed any | nil
	@return (source: Observable) -> Observable
]=]
function Rx.switchScan(accumulator, seed)
	assert(type(accumulator) == "function", "Bad accumulator")

	return Rx.pipe({
		Rx.scan(accumulator, seed) :: any,
		Rx.switchAll(),
	})
end

--[=[
	Applies an accumulator function over the source Observable where the accumulator function itself returns an Observable,
	then each intermediate Observable returned is merged into the output Observable.

	https://rxjs.dev/api/operators/mergeScan

	@param accumulator function
	@param seed any | nil
	@return (source: Observable) -> Observable
]=]
function Rx.mergeScan(accumulator, seed)
	assert(type(accumulator) == "function", "Bad accumulator")

	return Rx.pipe({
		Rx.scan(accumulator, seed) :: any,
		Rx.mergeAll(),
	})
end

return Rx
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="231">
                <Properties>
                  <string name="Name">Rx.spec</string>
                  <string name="Source"><![CDATA[--[[
	@class Rx.spec.lua
]]

local require =
	require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).bootstrapStory(script)

local Jest = require("Jest")
local Rx = require("Rx")

local describe = Jest.Globals.describe
local expect = Jest.Globals.expect
local it = Jest.Globals.it

describe("Rx.combineLatest({})", function()
	local observe = Rx.combineLatest({})
	local externalResult

	it("should execute immediately", function()
		local sub = observe:Subscribe(function(result)
			externalResult = result
		end)

		expect(externalResult).toEqual(expect.any("table"))
		sub:Destroy()
	end)
end)

describe("Rx.combineLatest({ value = 5 })", function()
	local observe = Rx.combineLatest({ value = 5 })
	local externalResult

	it("should execute immediately", function()
		local sub = observe:Subscribe(function(result)
			externalResult = result
		end)

		expect(externalResult).toEqual(expect.any("table"))
		expect(externalResult.value).toEqual(5)
		sub:Destroy()
	end)
end)

describe("Rx.combineLatest({ value = Rx.of(5) })", function()
	local observe = Rx.combineLatest({ value = Rx.of(5) })
	local externalResult

	it("should execute immediately", function()
		local sub = observe:Subscribe(function(result)
			externalResult = result
		end)

		expect(externalResult).toEqual(expect.any("table"))
		expect(externalResult.value).toEqual(5)
		sub:Destroy()
	end)
end)
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="232">
                <Properties>
                  <string name="Name">Subscription</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Subscriptions are used in the callback for an [Observable](/api/Observable). Standard usage
	is as follows.

	```lua
	-- Constucts an observable which will emit a, b, c via a subscription
	Observable.new(function(sub)
		sub:Fire("a")
		sub:Fire("b")
		sub:Fire("c")
		sub:Complete() -- ends stream
	end)
	```
	@class Subscription
]=]

local require = require(script.Parent.loader).load(script)

local MaidTaskUtils = require("MaidTaskUtils")

local ENABLE_STACK_TRACING = false

local Subscription = {}
Subscription.ClassName = "Subscription"
Subscription.__index = Subscription

export type SubscriptionState = "pending" | "failed" | "complete" | "cancelled"

export type FireCallback<T...> = (T...) -> ()
export type CompleteCallback = () -> ()
export type FailCallback = (...any) -> ()

export type Subscription<T...> = typeof(setmetatable(
	{} :: {
		_state: SubscriptionState,
		_cleanupTask: MaidTaskUtils.MaidTask?,
		_fireCallback: FireCallback<T...>?,
		_failCallback: FailCallback?,
		_completeCallback: CompleteCallback?,
		_fireCountAfterDeath: number?,
		_source: string?,
		_observableSource: string?,
	},
	{} :: typeof({ __index = Subscription })
))

export type SubscriptionStateTypes = {
	PENDING: "pending",
	FAILED: "failed",
	COMPLETE: "complete",
	CANCELLED: "cancelled",
}

local SubscriptionStateTypes: SubscriptionStateTypes = table.freeze({
	PENDING = "pending",
	FAILED = "failed",
	COMPLETE = "complete",
	CANCELLED = "cancelled",
} :: SubscriptionStateTypes)

--[=[
	Constructs a new Subscription

	@param fireCallback function?
	@param failCallback function?
	@param completeCallback function?
	@param observableSource string?
	@return Subscription
]=]
function Subscription.new<T...>(
	fireCallback: FireCallback<T...>?,
	failCallback: FailCallback?,
	completeCallback: CompleteCallback?,
	observableSource
): Subscription<T...>
	assert(type(fireCallback) == "function" or fireCallback == nil, "Bad fireCallback")
	assert(type(failCallback) == "function" or failCallback == nil, "Bad failCallback")
	assert(type(completeCallback) == "function" or completeCallback == nil, "Bad completeCallback")

	return setmetatable({
		_state = SubscriptionStateTypes.PENDING,
		_source = if ENABLE_STACK_TRACING then debug.traceback("Subscription.new()", 3) else nil,
		_observableSource = observableSource,
		_fireCallback = fireCallback,
		_failCallback = failCallback,
		_completeCallback = completeCallback,
	}, Subscription)
end

--[=[
	Fires the subscription

	@param ... any
]=]
function Subscription.Fire<T...>(self: Subscription<T...>, ...: T...)
	if self._state == SubscriptionStateTypes.PENDING then
		if self._fireCallback then
			self._fireCallback(...)
		end
	elseif self._state == SubscriptionStateTypes.CANCELLED then
		if self._fireCountAfterDeath then
			self._fireCountAfterDeath += 1
		else
			self._fireCountAfterDeath = 1
		end

		if self._fireCountAfterDeath > 1 then
			warn(
				debug.traceback(
					string.format(
						"Subscription:Fire(%s) called %d times after death. Be sure to disconnect all events.",
						(tostring :: any)(...),
						self._fireCountAfterDeath or -1
					),
					2
				)
			)

			if ENABLE_STACK_TRACING then
				print(self._observableSource)
				print(self._source)
			end
		end
	end
end

--[=[
	Fails the subscription, preventing anything else from emitting.
	@param ... any
]=]
function Subscription.Fail<T...>(self: Subscription<T...>, ...: any)
	if self._state ~= SubscriptionStateTypes.PENDING then
		return
	end

	self._state = SubscriptionStateTypes.FAILED

	if self._failCallback then
		self._failCallback(...)
	end

	self:_doCleanup()
end

--[=[
	Returns a tuple of fire, fail and complete functions which
	can be chained into the the next subscription.

	```lua
	return function(source)
		return Observable.new(function(sub)
			sub:Fire("hi")

			return source:Subscribe(sub:GetFireFailComplete())
		end)
	end
	```

	@return function
	@return function
	@return function
]=]
function Subscription.GetFireFailComplete<T...>(
	self: Subscription<T...>
): (FireCallback<T...>, FailCallback, CompleteCallback)
	return function(...: T...)
		self:Fire(...)
	end, function(...)
		self:Fail(...)
	end, function(...)
		self:Complete(...)
	end
end

--[=[
	Returns a tuple of fail and complete functions which
	can be chained into the the next subscription.

	```lua
	return function(source)
		return Observable.new(function(sub)
			return source:Subscribe(function(result)
				sub:Fire(tostring(result))
			end, sub:GetFailComplete()) -- Reuse is easy here!
		end)
	end
	```

	@return function
	@return function
]=]
function Subscription.GetFailComplete<T...>(self: Subscription<T...>): (FailCallback, CompleteCallback)
	return function(...)
		self:Fail(...)
	end, function(...)
		self:Complete(...)
	end
end

--[=[
	Completes the subscription, preventing anything else from being
	emitted.

	@param ... any
]=]
function Subscription.Complete<T...>(self: Subscription<T...>, ...)
	if self._state ~= SubscriptionStateTypes.PENDING then
		return
	end

	self._state = SubscriptionStateTypes.COMPLETE
	if self._completeCallback then
		self._completeCallback(...)
	end

	self:_doCleanup()
end

--[=[
	Returns whether the subscription is pending.
	@return boolean
]=]
function Subscription.IsPending<T...>(self: Subscription<T...>): boolean
	return self._state == SubscriptionStateTypes.PENDING
end

function Subscription._assignCleanup<T...>(self: Subscription<T...>, cleanupTask: MaidTaskUtils.MaidTask?)
	assert(self._cleanupTask == nil, "Already have _cleanupTask")

	if MaidTaskUtils.isValidTask(cleanupTask) then
		if self._state ~= SubscriptionStateTypes.PENDING then
			MaidTaskUtils.doTask(cleanupTask)
			return
		end

		self._cleanupTask = cleanupTask
	elseif cleanupTask ~= nil then
		error("Bad cleanup cleanupTask")
	end
end

function Subscription._doCleanup<T...>(self: Subscription<T...>)
	local cleanupTask = self._cleanupTask
	if cleanupTask then
		self._cleanupTask = nil

		-- The validity can change
		if MaidTaskUtils.isValidTask(cleanupTask) then
			MaidTaskUtils.doTask(cleanupTask)
		end
	end

	self._fireCallback = nil
	self._failCallback = nil
	self._completeCallback = nil
end

--[=[
	Cleans up the subscription

	:::tip
	This will be invoked by the Observable automatically, and should not
	be called within the usage of a subscription.
	:::
]=]
function Subscription.Destroy<T...>(self: Subscription<T...>)
	if self._state == SubscriptionStateTypes.PENDING then
		self._state = SubscriptionStateTypes.CANCELLED
	end

	self:_doCleanup()
end

--[=[
	Alias for [Subscription.Destroy].

	@method Disconnect
	@within Subscription
]=]
Subscription.Disconnect = Subscription.Destroy

return Subscription
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="233">
            <Properties>
              <string name="Name">rxbinderutils</string>
            </Properties>
            <Item class="Folder" referent="234">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="235">
                <Properties>
                  <string name="Name">RxBinderGroupUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Rx utility methods involving [BinderGroup] API surface
	@class RxBinderGroupUtils
]=]

local require = require(script.Parent.loader).load(script)

local BinderGroup = require("BinderGroup")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")
local RxBinderUtils = require("RxBinderUtils")

local RxBinderGroupUtils = {}

--[=[
	Observes all binders in a binder group
	@param binderGroup BinderGroup<T>
	@return Observable<Binder<T>>
]=]
function RxBinderGroupUtils.observeBinders(binderGroup: BinderGroup.BinderGroup)
	assert(type(binderGroup) == "table", "Bad binderGroup")

	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(binderGroup.BinderAdded:Connect(function(binder)
			sub:Fire(binder)
		end))

		for _, binder in binderGroup:GetBinders() do
			sub:Fire(binder)
		end

		return maid
	end)
end

--[=[
	Observes all classes in a given binder group.
	@param binderGroup BinderGroup<T>
	@return Observable<Brio<T>>
]=]
function RxBinderGroupUtils.observeAllClassesBrio(binderGroup)
	assert(type(binderGroup) == "table", "Bad binderGroup")

	return RxBinderGroupUtils.observeBinders(binderGroup):Pipe({
		Rx.flatMap(RxBinderUtils.observeAllBrio) :: any,
	}) :: any
end

return RxBinderGroupUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="236">
                <Properties>
                  <string name="Name">RxBinderUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility methods to observe bound objects on instances. This is what makes the Rx library with
	binders really good.

	:::info
	Using this API, you can query most game-state in very efficient ways, and react to the world
	changing in real-time. This makes programming streaming and other APIs really nice.
	:::

	@class RxBinderUtils
]=]

local require = require(script.Parent.loader).load(script)

local Binder = require("Binder")
local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local RxInstanceUtils = require("RxInstanceUtils")
local RxLinkUtils = require("RxLinkUtils")

local RxBinderUtils = {}

--[=[
	Observes a structure where a parent has object values with linked objects (for example), maybe
	an AI has a list of linked objectvalue tasks to execute.

	@param linkName string
	@param parent Instance
	@param binder Binder<T>
	@return Observable<Brio<T>>
]=]
function RxBinderUtils.observeLinkedBoundClassBrio<T>(
	linkName: string,
	parent: Instance,
	binder: Binder.Binder<T>
): Observable.Observable<Brio.Brio<T>>
	assert(type(linkName) == "string", "Bad linkName")
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(Binder.isBinder(binder), "Bad binder")

	return RxLinkUtils.observeValidLinksBrio(linkName, parent):Pipe({
		RxBrioUtils.flatMapBrio(function(_, linkValue)
			return binder:ObserveBrio(linkValue)
		end),
	})
end

--[=[
	Observes bound children classes.

	@param binder Binder<T>
	@param instance Instance
	@return Observable<Brio<T>>
]=]
function RxBinderUtils.observeChildrenBrio<T>(
	binder: Binder.Binder<T>,
	instance: Instance
): Observable.Observable<Brio.Brio<T>>
	assert(Binder.isBinder(binder), "Bad binder")
	assert(typeof(instance) == "Instance", "Bad instance")

	return RxInstanceUtils.observeChildrenBrio(instance):Pipe({
		RxBrioUtils.flatMapBrio(function(child)
			return binder:ObserveBrio(child)
		end) :: any,
	}) :: any
end

--[=[
	Observes bound children classes.

	@function observeBoundChildClassBrio
	@param binder Binder<T>
	@param instance Instance
	@return Observable<Brio<T>>
	@within RxBinderUtils
]=]
RxBinderUtils.observeBoundChildClassBrio = RxBinderUtils.observeChildrenBrio

--[=[
	Observes ainstance's parent class that is bound.

	@param binder Binder<T>
	@param instance Instance
	@return Observable<Brio<T>>
]=]
function RxBinderUtils.observeBoundParentClassBrio<T>(
	binder: Binder.Binder<T>,
	instance: Instance
): Observable.Observable<Brio.Brio<T>>
	assert(Binder.isBinder(binder), "Bad binder")
	assert(typeof(instance) == "Instance", "Bad instance")

	return RxInstanceUtils.observePropertyBrio(instance, "Parent"):Pipe({
		RxBrioUtils.switchMapBrio(function(child: Instance)
			if child then
				return RxBinderUtils.observeBoundClassBrio(binder, child)
			else
				return Rx.EMPTY
			end
		end) :: any,
		RxBrioUtils.onlyLastBrioSurvives() :: any,
	}) :: any
end

--[=[
	Observes all bound classes that hit that list of binders

	@param binders { Binder<T> }
	@param instance Instance
	@return Observable<Brio<T>>
]=]
function RxBinderUtils.observeBoundChildClassesBrio(binders, instance: Instance)
	assert(type(binders) == "table", "Bad binders")
	assert(typeof(instance) == "Instance", "Bad instance")

	return RxInstanceUtils.observeChildrenBrio(instance):Pipe({
		RxBrioUtils.flatMapBrio(function(child)
			return RxBinderUtils.observeBoundClassesBrio(binders, child)
		end) :: any,
	})
end

--[=[
	Observes a bound class on a given instance.

	@param binder Binder<T>
	@param instance Instance
	@return Observable<T?>
]=]
function RxBinderUtils.observeBoundClass<T>(binder: Binder.Binder<T>, instance: Instance): Observable.Observable<T?>
	assert(Binder.isBinder(binder), "Bad binder")
	assert(typeof(instance) == "Instance", "Bad instance")

	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(binder:ObserveInstance(instance, function(...)
			sub:Fire(...)
		end))
		sub:Fire(binder:Get(instance))

		return maid
	end)
end

--[=[
	Observes a bound class on a given instance.

	@param binder Binder<T>
	@param instance Instance
	@return Observable<Brio<T>>
]=]
function RxBinderUtils.observeBoundClassBrio<T>(
	binder: Binder.Binder<T>,
	instance: Instance
): Observable.Observable<Brio.Brio<T>>
	assert(Binder.isBinder(binder), "Bad binder")
	assert(typeof(instance) == "Instance", "Bad instance")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleClassChanged(class)
			if class then
				local brio = Brio.new(class)
				maid._lastBrio = brio

				sub:Fire(brio)
			else
				maid._lastBrio = nil
			end
		end

		maid:GiveTask(binder:ObserveInstance(instance, handleClassChanged))
		handleClassChanged(binder:Get(instance))

		return maid
	end) :: any
end

--[=[
	Observes all bound classes for a given binder.

	@param binders { Binder<T> }
	@param instance Instance
	@return Observable<Brio<T>>
]=]
function RxBinderUtils.observeBoundClassesBrio<T>(binders, instance: Instance): Observable.Observable<Brio.Brio<T>>
	assert(type(binders) == "table", "Bad binders")
	assert(typeof(instance) == "Instance", "Bad instance")

	local observables = {}

	for _, binder in binders do
		table.insert(observables, RxBinderUtils.observeBoundClassBrio(binder, instance))
	end

	return Rx.of(unpack(observables)):Pipe({
		Rx.mergeAll() :: any,
	}) :: any
end

--[=[
	Observes all instances bound to a given binder.

	@param binder Binder
	@return Observable<Brio<T>>
]=]
function RxBinderUtils.observeAllBrio<T>(binder: Binder.Binder<T>): Observable.Observable<Brio.Brio<T>>
	assert(Binder.isBinder(binder), "Bad binder")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleNewClass(class)
			local brio = Brio.new(class)
			maid[class] = brio

			sub:Fire(brio)
		end

		maid:GiveTask(binder:GetClassAddedSignal():Connect(handleNewClass))
		maid:GiveTask(binder:GetClassRemovingSignal():Connect(function(class)
			maid[class] = nil
		end))

		for class, _ in pairs(binder:GetAllSet()) do
			handleNewClass(class)
		end

		return maid
	end) :: any
end

--[=[
	Observes all instances bound to the given binder as an unordered array.

	@param binder Binder
	@return Observable<Brio<{ T }>>
]=]
function RxBinderUtils.observeAllArrayBrio<T>(binder: Binder.Binder<T>): Observable.Observable<Brio.Brio<{ T }>>
	assert(Binder.isBinder(binder), "Bad binder")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local array = binder:GetAll()

		local function emit()
			maid._brio = Brio.new(array)
			sub:Fire(maid._brio)
		end

		maid:GiveTask(binder:GetClassAddedSignal():Connect(function(class)
			table.insert(array, class)
			emit()
		end))
		maid:GiveTask(binder:GetClassRemovingSignal():Connect(function(class)
			local idx: number? = table.find(array, class)
			if not idx then
				return
			end
			-- Avoid 'table.remove'; that would suck with a very large list.
			-- We're assuming order doesn't matter. Instead, move the back element of the array over.
			-- From earlier benchmarking, calling #arr each time is faster than caching.
			if idx == #array then
				-- Just truncate. Handles case where array is 1 item.
				array[idx] = nil
			else
				-- Move back element forward.
				array[idx] = array[#array]
				array[#array] = nil
			end
			emit()
		end))

		emit()

		return maid
	end) :: any
end

return RxBinderUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="237">
            <Properties>
              <string name="Name">rxsignal</string>
            </Properties>
            <Item class="Folder" referent="238">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="239">
                <Properties>
                  <string name="Name">RxSignal</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class RxSignal
]=]

local require = require(script.Parent.loader).load(script)

local Observable = require("Observable")
local Rx = require("Rx")
local Subscription = require("Subscription")

local RxSignal = {}
RxSignal.ClassName = "RxSignal"
RxSignal.__index = RxSignal

export type RxSignal<T...> = typeof(setmetatable(
	{} :: {
		_observable: Observable.Observable<T...> | () -> Observable.Observable<T...>,
	},
	{} :: typeof({ __index = RxSignal })
))

--[=[
	Converts an observable to the Signal interface

	@param observable Observable<T> | () -> Observable<T>
	@return RxSignal<T>
]=]
function RxSignal.new<T...>(observable: Observable.Observable<T...> | () -> Observable.Observable<T...>): RxSignal<T...>
	assert(observable, "No observable")

	local self = setmetatable({}, RxSignal)

	self._observable = observable

	return self
end

--[=[
	Connects to the signal and returns a subscription
]=]
function RxSignal.Connect<T...>(self: RxSignal<T...>, callback: (T...) -> ()): Subscription.Subscription<T...>
	return self:_getObservable():Subscribe(callback)
end

--[=[
	Waits for the signal to fire and returns the values
]=]
function RxSignal.Wait<T...>(self: RxSignal<T...>): T...
	local waitingCoroutine = coroutine.running()

	local subscription: Subscription.Subscription<T...>
	subscription = self:Connect(function(...)
		subscription:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)

	return coroutine.yield()
end

--[=[
	Connects once to the signal and returns a subscription
]=]
function RxSignal.Once<T...>(self: RxSignal<T...>, callback: (T...) -> ()): Subscription.Subscription<T...>
	return self:_getObservable()
		:Pipe({
			Rx.take(1) :: any,
		})
		:Subscribe(callback)
end

function RxSignal._getObservable<T...>(self: RxSignal<T...>): Observable.Observable<T...>
	if Observable.isObservable(self._observable) then
		return self._observable :: Observable.Observable<T...>
	end

	if type(self._observable) == "function" then
		local result = self._observable()

		assert(Observable.isObservable(result), "Result should be observable")

		return result
	else
		error("Could not convert self._observable to observable")
	end
end

return RxSignal
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="240">
            <Properties>
              <string name="Name">servicebag</string>
            </Properties>
            <Item class="Folder" referent="241">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="242">
                <Properties>
                  <string name="Name">ServiceBag</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Service bags handle recursive initialization of services, and the
	retrieval of services from a given source. This allows the composition
	of services without the initialization of those services becoming a pain,
	which makes refactoring downstream services very easy.

	This also allows multiple copies of a service to exist at once, although
	many services right now are not designed for this.

	```lua
	local serviceBag = ServiceBag.new()

	serviceBag:GetService({
		Init = function(self)
			print("Service initialized")
		end;
	})
	serviceBag:Init()
	serviceBag:Start()
	```

	:::tip
	ServiceBag does not allow services to yield on :Init() or :Start(), nor
	does it allow you to add services after :Init() or :Start()
	:::

	@class ServiceBag
]=]

local require = require(script.Parent.loader).load(script)

local BaseObject = require("BaseObject")
local ServiceInitLogger = require("ServiceInitLogger")
local Signal = require("Signal")

--[=[
	@interface Service
	.Init: (serviceBag: ServiceBag) -> ()?
	.Start: () -> ()?
	.Destroy: () -> ()?
	@within ServiceBag
]=]

--[=[
	@type ServiceType Service | ModuleScript
	@within ServiceBag
]=]

local ServiceBag = setmetatable({}, BaseObject)
ServiceBag.ClassName = "ServiceBag"
ServiceBag.__index = ServiceBag

export type ServiceBag = typeof(setmetatable(
	{} :: {
		_services: { [any]: any },
		_parentProvider: ServiceBag?,
		_serviceTypesToInitializeSet: { [any]: true }?,
		_initializedServiceTypeSet: { [any]: true },
		_serviceTypesToStartSet: { [any]: true }?,

		_initRunAllowed: boolean,
		_destructing: boolean,
		_serviceInitLogger: ServiceInitLogger.ServiceInitLogger,
		_serviceStartLogger: ServiceInitLogger.ServiceInitLogger,

		_destroyingSignal: Signal.Signal<()>,
	},
	{} :: typeof({ __index = ServiceBag })
)) & BaseObject.BaseObject

--[=[
	Constructs a new ServiceBag

	@param parentProvider ServiceBag? -- Optional parent provider to find services in
	@return ServiceBag
]=]
function ServiceBag.new(parentProvider: ServiceBag?): ServiceBag
	local self: ServiceBag = setmetatable(BaseObject.new() :: any, ServiceBag)

	self._services = {}
	self._parentProvider = parentProvider

	self._serviceTypesToInitializeSet = {}
	self._initializedServiceTypeSet = {}
	self._serviceTypesToStartSet = {}

	self._initRunAllowed = false
	self._destructing = false

	self._serviceInitLogger = ServiceInitLogger.new("initialized")
	self._serviceStartLogger = ServiceInitLogger.new("started")

	self._destroyingSignal = Signal.new()

	return self
end

--[=[
	Returns whether the value is a serviceBag

	@param value ServiceBag?
	@return boolean
]=]
function ServiceBag.isServiceBag(value: any): boolean
	return type(value) == "table" and value.ClassName == "ServiceBag"
end

--[=[
	Prints out initialization stack trace - helpful for debugging
	and diagnostics.
]=]
function ServiceBag.PrintInitialization(self: ServiceBag)
	self._serviceInitLogger:Print()
	self._serviceStartLogger:Print()
end

--[=[
	Retrieves the service, ensuring initialization if we are in
	the initialization phase.

	@param serviceType ServiceType
	@return any
]=]
function ServiceBag.GetService<T>(self: ServiceBag, serviceType: T): T
	if typeof(serviceType) == "Instance" then
		serviceType = (require :: any)(serviceType)
	end

	if type(serviceType) ~= "table" then
		error(
			string.format(
				"Bad serviceType definition of type %s of type %s",
				tostring(serviceType),
				typeof(serviceType)
			)
		)
	end

	local service = self._services[serviceType]
	if service then
		self:_ensureInitialization(serviceType)
		return self._services[serviceType]
	else
		if self._parentProvider then
			return self._parentProvider:GetService(serviceType)
		end

		-- Try to add the service if we're still initializing services
		self:_addServiceType(serviceType)
		self:_ensureInitialization(serviceType)
		return self._services[serviceType]
	end
end

--[=[
	Returns whether the service bag has the service.
	@param serviceType ServiceType
	@return boolean
]=]
function ServiceBag.HasService<T>(self: ServiceBag, serviceType: T): boolean
	if typeof(serviceType) == "Instance" then
		serviceType = (require :: any)(serviceType)
	end

	if self._services[serviceType] then
		return true
	else
		return false
	end
end

--[=[
	Initializes the service bag and ensures recursive initialization
	can occur
]=]
function ServiceBag.Init(self: ServiceBag)
	assert(not self._initRunAllowed, "Already initializing")
	assert(self._serviceTypesToInitializeSet, "Already initialized")
	self._initRunAllowed = true

	while next(self._serviceTypesToInitializeSet) do
		local serviceType = next(self._serviceTypesToInitializeSet)
		self._serviceTypesToInitializeSet[serviceType] = nil

		self:_ensureInitialization(serviceType)
	end

	self._serviceTypesToInitializeSet = nil
end

--[=[
	Starts the service bag and all services
]=]
function ServiceBag.Start(self: ServiceBag)
	assert(self._serviceTypesToStartSet, "Already started")
	assert(not self._serviceTypesToInitializeSet, "Not initialized yet. Call serviceBag:Init() first.")

	self._initRunAllowed = false

	while next(self._serviceTypesToStartSet) do
		local serviceType = table.remove(self._serviceTypesToStartSet)
		local service = assert(self._services[serviceType], "No service")
		local serviceName = self:_getServiceName(serviceType)

		if service.Start then
			local current
			task.spawn(function()
				local stopClock = self._serviceStartLogger:StartInitClock(serviceName)

				debug.setmemorycategory(serviceName)
				current = coroutine.running()
				service:Start()

				stopClock()
			end)

			local isDead = coroutine.status(current) == "dead"
			if not isDead then
				error(debug.traceback(current, string.format("Starting service %q yielded", serviceName)))
			end
		end
	end

	self._serviceTypesToStartSet = nil
end

function ServiceBag._getServiceName(_self: ServiceBag, serviceType): string
	local serviceName
	pcall(function()
		serviceName = serviceType.ServiceName
	end)
	if type(serviceName) == "string" then
		return serviceName
	end

	return tostring(serviceType)
end

--[=[
	Returns whether the service bag has fully started or not.
	@return boolean
]=]
function ServiceBag.IsStarted(self: ServiceBag): boolean
	return self._serviceTypesToStartSet == nil
end

--[=[
	Creates a scoped service bag, where services within the scope will not
	be accessible outside of the scope.

	@return ServiceBag
]=]
function ServiceBag.CreateScope(self: ServiceBag): ServiceBag
	local provider: ServiceBag = ServiceBag.new(self)

	self:_addServiceType(provider)

	-- Remove from parent provider
	self._maid[provider] = provider._destroyingSignal:Connect(function()
		self._maid[provider] = nil
		self._services[provider] = nil
	end)

	return provider
end

-- Adds a service to this provider only
function ServiceBag._addServiceType<T>(self: ServiceBag, serviceType: T)
	if self._destructing then
		local serviceName = self:_getServiceName(serviceType)
		error(string.format("Cannot query service %q after ServiceBag is cleaned up", serviceName))
		return
	end

	if self:IsStarted() then
		local hint =
			'HINT: Be sure to call serviceBag:GetService(require("MyService")) either before calling serviceBag:Init() or during serviceBag:Init() (within another service:Init)'
		error(string.format("Already started, cannot add %q. \n%s", self:_getServiceName(serviceType), hint))
		return
	end

	-- Already added
	if self._services[serviceType] then
		return
	end

	-- Construct a new version of this service so we're isolated
	local service = setmetatable({}, { __index = serviceType })
	self._services[serviceType] = service

	self:_ensureInitialization(serviceType)
end

function ServiceBag._ensureInitialization<T>(self: ServiceBag, serviceType: T)
	if self._initializedServiceTypeSet[serviceType] then
		return
	end

	if self._destructing then
		local serviceName = self:_getServiceName(serviceType)
		error(string.format("Cannot initialize service %q after ServiceBag is cleaned up", serviceName))
		return
	end

	if self._initRunAllowed then
		if self._serviceTypesToInitializeSet then
			self._serviceTypesToInitializeSet[serviceType] = nil
		end

		self._initializedServiceTypeSet[serviceType] = true
		self:_initService(serviceType)
	elseif self._serviceTypesToInitializeSet then
		self._serviceTypesToInitializeSet[serviceType] = true
	else
		local serviceName = self:_getServiceName(serviceType)
		error(string.format("Cannot initialize service %q after start", serviceName))
	end
end

function ServiceBag._initService(self: ServiceBag, serviceType)
	assert(self._serviceTypesToStartSet, "ServiceBag cannot start")

	local service = assert(self._services[serviceType], "No service")
	local serviceName = self:_getServiceName(serviceType)

	if service.Init then
		local current
		task.spawn(function()
			debug.setmemorycategory(serviceName)

			local stopClock = self._serviceInitLogger:StartInitClock(serviceName)

			current = coroutine.running()
			service:Init(self)

			stopClock()
		end)

		local isDead = coroutine.status(current) == "dead"
		if not isDead then
			error(debug.traceback(current, string.format("Initializing service %q yielded", serviceName)))
		end
	end

	table.insert(self._serviceTypesToStartSet, serviceType)
end

--[=[
	Cleans up the service bag and all services that have been
	initialized in the service bag.
]=]
function ServiceBag.Destroy(self: ServiceBag)
	if self._destructing then
		return
	end

	local super = getmetatable(ServiceBag)

	self._destructing = true

	self._destroyingSignal:Fire()
	self._destroyingSignal:Destroy()

	self:_destructServices()

	super.Destroy(self :: any)
end

function ServiceBag._destructServices(self: ServiceBag)
	local services = self._services
	local serviceType, service = next(services)
	while service ~= nil do
		services[serviceType] = nil

		if not (self._serviceTypesToInitializeSet and self._serviceTypesToInitializeSet[serviceType]) then
			local serviceName = self:_getServiceName(serviceType)

			local current
			task.spawn(function()
				debug.setmemorycategory(serviceName)
				current = coroutine.running()

				if service.Destroy then
					service:Destroy()
				end
			end)

			local isDead = coroutine.status(current) == "dead"
			if not isDead then
				warn(debug.traceback(current, string.format("Destroying service %q yielded", serviceName)))
			end
		end

		serviceType, service = next(services)
	end
end

return ServiceBag
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="243">
                <Properties>
                  <string name="Name">ServiceInitLogger</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class ServiceInitLogger
]=]

local EPSILON = 1e-6

local ServiceInitLogger = {}
ServiceInitLogger.ClassName = "ServiceInitLogger"
ServiceInitLogger.__index = ServiceInitLogger

type LogEntry = {
	name: string,
	children: { LogEntry },
	log: string?,
}

export type ServiceInitLogger = typeof(setmetatable(
	{} :: {
		_action: string,
		_rootNode: LogEntry,
		_stack: { LogEntry },
		_totalTimeUsed: number,
		_initIndent: number,
		_totalServices: number,
	},
	{} :: typeof({ __index = ServiceInitLogger })
))

function ServiceInitLogger.new(action: string): ServiceInitLogger
	local self = setmetatable({}, ServiceInitLogger)

	assert(type(action) == "string", "Bad action")

	self._action = action
	self._rootNode = {
		name = "ROOT",
		children = {},
	} :: LogEntry
	self._stack = { self._rootNode }
	self._totalTimeUsed = 0
	self._initIndent = 0
	self._totalServices = 0

	return self
end

function ServiceInitLogger.StartInitClock(self: ServiceInitLogger, serviceName: string)
	assert(type(serviceName) == "string", "serviceName")

	local startTime: number = os.clock()

	local initialIndent: number = self._initIndent
	local initialTotalTimeUsed: number = self._totalTimeUsed
	local initialTotalServices: number = self._totalServices

	self._initIndent = initialIndent + 1
	self._totalServices = self._totalServices + 1

	local parent: LogEntry = self._stack[#self._stack]
	local entry: LogEntry = {
		name = serviceName,
		children = {},
		log = string.format("%s%sService is not loaded", string.rep("  ", initialIndent), serviceName),
	}
	table.insert(parent.children, entry)
	table.insert(self._stack, entry)

	return function()
		for i = #self._stack, 1, -1 do
			if self._stack[i] == entry then
				table.remove(self._stack, i)
				break
			end
		end

		local timeUsed = (os.clock() - startTime)
		local otherServiceTime = self._totalTimeUsed - initialTotalTimeUsed
		local internalTimeUsed = timeUsed - otherServiceTime
		local totalServices = self._totalServices - initialTotalServices - 1

		self._totalTimeUsed = self._totalTimeUsed + internalTimeUsed
		self._initIndent = self._initIndent - 1

		if math.abs(internalTimeUsed - timeUsed) <= EPSILON then
			entry.log = string.format(
				"%sService %s %s in %0.2f ms",
				string.rep("  ", initialIndent),
				serviceName,
				self._action,
				1000 * internalTimeUsed
			)
		else
			entry.log = string.format(
				"%sService %s %s in %0.2f ms (%0.2f ms total for %d descendants)",
				string.rep("  ", initialIndent),
				serviceName,
				self._action,
				1000 * internalTimeUsed,
				1000 * timeUsed,
				totalServices
			)
		end
	end
end

function ServiceInitLogger.Print(self: ServiceInitLogger)
	local function recurse(node: LogEntry)
		print(node.log)
		for _, childNode in node.children do
			recurse(childNode)
		end
	end

	for _, child in self._rootNode.children do
		recurse(child)
	end
end

return ServiceInitLogger
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="244">
            <Properties>
              <string name="Name">signal</string>
            </Properties>
            <Item class="Folder" referent="245">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="246">
                <Properties>
                  <string name="Name">EventHandlerUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility methods to fire an event in a free thread, reusing threads

	@class EventHandlerUtils
]=]

local EventHandlerUtils = {}

-- The currently idle thread to run the next handler on
local freeThreads = setmetatable({} :: { [string]: thread }, { __mode = "kv" })

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
function EventHandlerUtils._fireEvent<T...>(memoryCategory: string, fn: (T...) -> (), ...: T...): ()
	local acquiredRunnerThread = freeThreads[memoryCategory]
	freeThreads[memoryCategory] = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeThreads[memoryCategory] = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
function EventHandlerUtils._initializeThread(memoryCategory: string): ()
	if memoryCategory == "" then
		debug.setmemorycategory("signal_unknown")
	else
		debug.setmemorycategory(memoryCategory)
	end

	-- Note: We cannot use the initial set of arguments passed to
	-- initializeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		EventHandlerUtils._fireEvent(coroutine.yield())
	end
end

--[=[
	Safely fires an event in the given memory category we're in
]=]
function EventHandlerUtils.fire<T...>(memoryCategory: string, callback: (T...) -> (), ...: T...): ()
	assert(type(memoryCategory) == "string", "Bad memoryCategory")
	assert(type(callback) == "function", "Bad callback")

	if not freeThreads[memoryCategory] then
		freeThreads[memoryCategory] = coroutine.create(EventHandlerUtils._initializeThread)
		coroutine.resume(freeThreads[memoryCategory], memoryCategory)
	end

	task.spawn(freeThreads[memoryCategory], memoryCategory, callback, ...)
end

return EventHandlerUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="247">
                <Properties>
                  <string name="Name">OldSignal</string>
                  <string name="Source"><![CDATA[--!nocheck
--[=[
	Lua-side duplication of the [API of events on Roblox objects](https://create.roblox.com/docs/reference/engine/datatypes/RBXScriptSignal).

	Signals are needed for to ensure that for local events objects are passed by
	reference rather than by value where possible, as the BindableEvent objects
	always pass signal arguments by value, meaning tables will be deep copied.
	Roblox's deep copy method parses to a non-lua table compatable format.

	This class is designed to work both in deferred mode and in regular mode.
	It follows whatever mode is set.

	```lua
	local signal = Signal.new()

	local arg = {}

	signal:Connect(function(value)
		assert(arg == value, "Tables are preserved when firing a Signal")
	end)

	signal:Fire(arg)
	```

	:::info
	Why this over a direct [BindableEvent]? Well, in this case, the signal
	prevents Roblox from trying to serialize and desialize each table reference
	fired through the BindableEvent.
	:::

	@class Signal
]=]

local USE_GOOD_SIGNAL_ONLY = true

if USE_GOOD_SIGNAL_ONLY then
	local require = require(script.Parent.loader).load(script)

	return require("GoodSignal")
end

local HttpService = game:GetService("HttpService")

local ENABLE_TRACEBACK = false

local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"

--[=[
	Returns whether a class is a signal
	@param value any
	@return boolean
]=]
function Signal.isSignal(value)
	return type(value) == "table" and getmetatable(value) == Signal
end

--[=[
	Constructs a new signal.
	@return Signal<T>
]=]
function Signal.new()
	local self = setmetatable({}, Signal)

	self._bindableEvent = Instance.new("BindableEvent")
	self._argMap = {}
	self._source = ENABLE_TRACEBACK and debug.traceback() or ""

	-- Events in Roblox execute in reverse order as they are stored in a linked list and
	-- new connections are added at the head. This event will be at the tail of the list to
	-- clean up memory.
	self._bindableEvent.Event:Connect(function(key)
		self._argMap[key] = nil

		-- We've been destroyed here and there's nothing left in flight.
		-- Let's remove the argmap too.
		-- This code may be slower than leaving this table allocated.
		if (not self._bindableEvent) and (not next(self._argMap)) then
			self._argMap = nil
		end
	end)

	return self
end

--[=[
	Fire the event with the given arguments. All handlers will be invoked. Handlers follow
	@param ... T -- Variable arguments to pass to handler
]=]
function Signal:Fire(...)
	if not self._bindableEvent then
		warn(string.format("Signal is already destroyed. %s", self._source))
		return
	end

	local args = table.pack(...)

	-- TODO: Replace with a less memory/computationally expensive key generation scheme
	local key = HttpService:GenerateGUID(false)
	self._argMap[key] = args

	-- Queues each handler onto the queue.
	self._bindableEvent:Fire(key)
end

--[=[
	Connect a new handler to the event. Returns a connection object that can be disconnected.
	@param handler (... T) -> () -- Function handler called when `:Fire(...)` is called
	@return RBXScriptConnection
]=]
function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(string.format("connect(%s)", typeof(handler)), 2)
	end

	return self._bindableEvent.Event:Connect(function(key)
		-- note we could queue multiple events here, but we'll do this just as Roblox events expect
		-- to behave.

		local args = self._argMap[key]
		if args then
			handler(table.unpack(args, 1, args.n))
		else
			error("Missing arg data, probably due to reentrance.")
		end
	end)
end

--[=[
	Connect a new, one-time handler to the event. Returns a connection object that can be disconnected.
	@param handler (... T) -> () -- One-time function handler called when `:Fire(...)` is called
	@return RBXScriptConnection
]=]
function Signal:Once(handler)
	if not (type(handler) == "function") then
		error(string.format("once(%s)", typeof(handler)), 2)
	end

	return self._bindableEvent.Event:Once(function(key)
		local args = self._argMap[key]
		if args then
			handler(table.unpack(args, 1, args.n))
		else
			error("Missing arg data, probably due to reentrance.")
		end
	end)
end

--[=[
	Wait for fire to be called, and return the arguments it was given.
	@yields
	@return T
]=]
function Signal:Wait()
	local key = self._bindableEvent.Event:Wait()
	local args = self._argMap[key]
	if args then
		return table.unpack(args, 1, args.n)
	else
		error("Missing arg data, probably due to reentrance.")
		return nil
	end
end

--[=[
	Disconnects all connected events to the signal. Voids the signal as unusable.
	Sets the metatable to nil.
]=]
function Signal:Destroy()
	if self._bindableEvent then
		-- This should disconnect all events, but in-flight events should still be
		-- executed.

		self._bindableEvent:Destroy()
		self._bindableEvent = nil
	end

	-- Do not remove the argmap. It will be cleaned up by the cleanup connection.

	setmetatable(self, nil)
end

return Signal
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="248">
                <Properties>
                  <string name="Name">Signal</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Batched Yield-Safe Signal Implementation

	Lua-side duplication of the [API of events on Roblox objects](https://create.roblox.com/docs/reference/engine/datatypes/RBXScriptSignal).

	Signals are needed for to ensure that for local events objects are passed by
	reference rather than by value where possible, as the BindableEvent objects
	always pass signal arguments by value, meaning tables will be deep copied.
	Roblox's deep copy method parses to a non-lua table compatable format.

	This class is designed to work both in deferred mode and in regular mode.
	It follows whatever mode is set.

	```lua
	local signal = Signal.new()

	local arg = {}

	signal:Connect(function(value)
		assert(arg == value, "Tables are preserved when firing a Signal")
	end)

	signal:Fire(arg)
	```

	:::info
	Why this over a direct [BindableEvent]? Well, in this case, the signal
	prevents Roblox from trying to serialize and desialize each table reference
	fired through the BindableEvent.
	:::

	This is a Signal class which has effectively identical behavior to a
	normal RBXScriptSignal, with the only difference being a couple extra
	stack frames at the bottom of the stack trace when an error is thrown
	This implementation caches runner coroutines, so the ability to yield in
	the signal handlers comes at minimal extra cost over a naive signal
	implementation that either always or never spawns a thread.

	Author notes:
	stravant - July 31st, 2021 - Created the file.
	Quenty - Auguest 21st, 2023 - Modified to fit Nevermore contract, with Moonwave docs

	@class GoodSignal
]=]

local require = require(script.Parent.loader).load(script)

local EventHandlerUtils = require("EventHandlerUtils")

-- Connection class
local Connection = {}
Connection.ClassName = "Connection"
Connection.__index = Connection

export type SignalHandler<T...> = (T...) -> ()

export type Connection<T...> = typeof(setmetatable(
	{} :: {
		_memoryCategory: string,
		_signal: Signal<T...>?,
		_fn: SignalHandler<T...>?,
	},
	{} :: typeof({ __index = Connection })
))

function Connection.new<T...>(signal: Signal<T...>, fn: SignalHandler<T...>): Connection<T...>
	return setmetatable({
		-- selene: allow(incorrect_standard_library_use)
		_memoryCategory = debug.getmemorycategory(),
		_signal = signal,
		_fn = fn,
	}, Connection) :: any
end

function Connection.IsConnected<T...>(self: Connection<T...>): boolean
	return rawget(self :: any, "_signal") ~= nil
end

function Connection.Disconnect<T...>(self: Connection<T...>)
	local signal = rawget(self :: any, "_signal")
	if not signal then
		return
	end

	-- Unhook the node. Originally the good signal would not clear this signal and
	-- rely upon GC. However, this means that connections would keep themselves and other
	-- disconnected nodes in the chain alive, keeping the function closure alive, and in return
	-- keeping the signal alive. This means a `Maid` could keep full object trees alive if a
	-- connection was made to them.

	local ourNext = rawget(self :: any, "_next")

	if signal._handlerListHead == self then
		signal._handlerListHead = ourNext or false
	else
		local prev = signal._handlerListHead
		while prev and rawget(prev, "_next") ~= self do
			prev = rawget(prev, "_next")
		end
		if prev then
			rawset(prev, "_next", ourNext)
		end
	end

	-- Clear all member variables that aren't _next so keeping a connection
	-- indexed allows for GC of other components
	table.clear(self :: any)
end

Connection.Destroy = Connection.Disconnect

-- Make signal strict
setmetatable(Connection, {
	__index = function(_, key)
		error(string.format("Attempt to get Connection::%s (not a valid member)", tostring(key)), 2)
	end,
	__newindex = function(_, key, _)
		error(string.format("Attempt to set Connection::%s (not a valid member)", tostring(key)), 2)
	end,
})

-- Signal class
local Signal = {}
Signal.ClassName = "Signal"
Signal.__index = Signal

export type Signal<T...> = typeof(setmetatable(
	{} :: {
		_handlerListHead: Connection<T...> | false,
	},
	{} :: typeof({ __index = Signal })
))

--[=[
	Constructs a new signal.
	@return Signal<T...>
]=]
function Signal.new<T...>(): Signal<T...>
	return setmetatable({
		_handlerListHead = false,
	}, Signal) :: any
end

--[=[
	Returns whether a class is a signal

	@param value any
	@return boolean
]=]
function Signal.isSignal(value: any): boolean
	return type(value) == "table" and getmetatable(value) == Signal
end

--[=[
	Connect a new handler to the event. Returns a connection object that can be disconnected.

	@param fn (... T) -> () -- Function handler called when `:Fire(...)` is called
	@return RBXScriptConnection
]=]
function Signal.Connect<T...>(self: Signal<T...>, fn: SignalHandler<T...>): Connection<T...>
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		rawset(connection :: any, "_next", self._handlerListHead)
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

--[=[
	Disconnects all connected events to the signal.

	:::info
	Disconnect all handlers. Since we use a linked list it suffices to clear the
	reference to the head handler.
	:::
]=]
function Signal.DisconnectAll<T...>(self: Signal<T...>): ()
	self._handlerListHead = false
end

--[=[
	Fire the event with the given arguments. All handlers will be invoked. Handlers follow

	::: info
	Signal:Fire(...) is implemented by running the handler functions on the
	coRunnerThread, and any time the resulting thread yielded without returning
	to us, that means that it yielded to the Roblox scheduler and has been taken
	over by Roblox scheduling, meaning we have to make a new coroutine runner.
	:::

	@param ... T -- Variable arguments to pass to handler
]=]
function Signal.Fire<T...>(self: Signal<T...>, ...: T...): ()
	local connection: any = self._handlerListHead
	while connection do
		-- capture our next node, which could after this be cleared or disconnected.
		-- any connections occuring during fire will be added to the _handerListHead and not be fired
		-- in this round. Any disconnections in the chain will still work here.
		local nextNode = rawget(connection, "_next")

		if rawget(connection, "_signal") ~= nil then -- isConnected
			EventHandlerUtils.fire(connection._memoryCategory, connection._fn, ...)
		end

		connection = nextNode
	end
end

--[=[
	Wait for fire to be called, and return the arguments it was given.

	::: info
	Signal:Wait() is implemented in terms of a temporary connection using
	a Signal:Connect() which disconnects itself.
	:::

	@yields
	@return T
]=]
function Signal.Wait<T...>(self: Signal<T...>): T...
	local waitingCoroutine = coroutine.running()

	local connection: Connection<T...>
	connection = (self :: any):Connect(function(...)
		connection:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)

	return coroutine.yield()
end

--[=[
	Connect a new, one-time handler to the event. Returns a connection object that can be disconnected.

	::: info
	-- Implement Signal:Once() in terms of a connection which disconnects
	-- itself before running the handler.
	:::

	@param fn (... T) -> () -- One-time function handler called when `:Fire(...)` is called
	@return RBXScriptConnection
]=]
function Signal.Once<T...>(self: Signal<T...>, fn: SignalHandler<T...>): Connection<T...>
	local connection: Connection<T...>
	connection = (self :: any):Connect(function(...)
		connection:Disconnect()
		fn(...)
	end)
	return connection
end

--[=[
	Alias for [DisconnectAll]

	@function Destroy
	@within Signal
]=]
Signal.Destroy = Signal.DisconnectAll

-- Make signal strict
setmetatable(Signal, {
	__index = function(_, key)
		error(string.format("Attempt to get Signal::%s (not a valid member)", tostring(key)), 2)
	end,
	__newindex = function(_, key, _)
		error(string.format("Attempt to set Signal::%s (not a valid member)", tostring(key)), 2)
	end,
})

return Signal
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="249">
                <Properties>
                  <string name="Name">SignalUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utilities involving signals
	@class SignalUtils
]=]

local SignalUtils = {}

--[=[
	Executes on the next event connection.
	@param event RBXScriptSignal
	@param callback function
	@return RBXScriptConnection
]=]
function SignalUtils.onNext(event: RBXScriptSignal, callback: () -> ())
	assert(typeof(event) == "RBXScriptSignal", "Bad event")
	assert(type(callback) == "function", "Bad callback")

	return event:Once(callback)
end

return SignalUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="250">
            <Properties>
              <string name="Name">spring</string>
            </Properties>
            <Item class="Folder" referent="251">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="252">
                <Properties>
                  <string name="Name">LinearValue</string>
                  <string name="Source"><![CDATA[--!nocheck
--[=[
	Represents a value that can operate in linear space

	@class LinearValue
]=]

local require = require(script.Parent.loader).load(script)

local DuckTypeUtils = require("DuckTypeUtils")

local LinearValue = {}
LinearValue.ClassName = "LinearValue"
LinearValue.__index = LinearValue

export type LinearValue<T> = typeof(setmetatable(
	{} :: {
		_constructor: (...number) -> T,
		_values: { number },
	},
	{} :: typeof({ __index = LinearValue })
))

--[=[
	Constructs a new LinearValue object.

	@param constructor (number ...) -> T
	@param values ({ number })
	@return LinearValue<T>
]=]
function LinearValue.new<T>(constructor: (...number) -> T, values: { number }): LinearValue<T>
	return setmetatable({
		_constructor = constructor,
		_values = values,
	}, LinearValue)
end

--[=[
	Returns whether or not a value is a LinearValue object.

	@param value any -- A value to check
	@return boolean -- True if a linear value, false otherwise
]=]
function LinearValue.isLinear(value: any): boolean
	return DuckTypeUtils.isImplementation(LinearValue, value)
end

local function convertUDim2(scaleX: number, offsetX: number, scaleY: number, offsetY: number): UDim2
	-- Roblox UDim2.new(0, 9.999, 0, 9.999) rounds to UDim2.new(0, 9, 0, 9) which means small floating point
	-- errors can cause shaking UI.

	return UDim2.new(scaleX, math.round(offsetX), scaleY, math.round(offsetY))
end

local function convertUDim(scale: number, offset: number): UDim
	-- Roblox UDim.new(0, 9.999) rounds to UDim.new(0, 9) which means small floating point
	-- errors can cause shaking UI.

	return UDim.new(scale, math.round(offset))
end

local function convertBoolean(value: number): boolean
	return value ~= 0
end

local function convertColor3(r: number, g: number, b: number): Color3
	return Color3.new(r, g, b)
end

--[=[
	Converts an arbitrary value to a LinearValue if Roblox has not defined this value
	for multiplication and addition.

	@param value T
	@return LinearValue<T> | T
]=]
function LinearValue.toLinearIfNeeded<T>(value: any): LinearValue<any>
	if typeof(value) == "Color3" then
		return LinearValue.new(convertColor3, { value.R, value.G, value.B })
	elseif typeof(value) == "UDim2" then
		return LinearValue.new(
			convertUDim2,
			{ value.X.Scale, math.round(value.X.Offset), value.Y.Scale, math.round(value.Y.Offset) }
		)
	elseif typeof(value) == "UDim" then
		return LinearValue.new(convertUDim, { value.Scale, math.round(value.Offset) })
	elseif type(value) == "boolean" then
		return LinearValue.new(convertBoolean, { value and 1 or 0 })
	else
		return value
	end
end

--[=[
	Extracts the base value out of a packed linear value if needed.

	@param value LinearValue<T> | any
	@return T | any
]=]
function LinearValue.fromLinearIfNeeded<T>(value: LinearValue<T> | any): any
	if LinearValue.isLinear(value) then
		return value:ToBaseValue()
	else
		return value
	end
end

--[=[
	Converts the value back to the base value

	@return T
]=]
function LinearValue.ToBaseValue<T>(self: LinearValue<T>): T
	return self._constructor(unpack(self._values))
end

local function operation(func: (number, number) -> number)
	return function(a: LinearValue<any>, b: LinearValue<any>)
		if LinearValue.isLinear(a) and LinearValue.isLinear(b) then
			assert(a._constructor == b._constructor, "a is not the same type of linearValue as b")

			local values = {}
			for i = 1, #a._values do
				values[i] = func(a._values[i], b._values[i])
			end
			return LinearValue.new(a._constructor, values)
		elseif LinearValue.isLinear(a) then
			if type(b) == "number" then
				local values = {}
				for i = 1, #a._values do
					values[i] = func(a._values[i], b)
				end
				return LinearValue.new(a._constructor, values)
			else
				error("Bad type (b)")
			end
		elseif LinearValue.isLinear(b) then
			if type(a) == "number" then
				local values = {}
				for i = 1, #b._values do
					values[i] = func(a, b._values[i])
				end
				return LinearValue.new(b._constructor, values)
			else
				error("Bad type (a)")
			end
		else
			error("Neither value is a linearValue")
		end
	end
end

--[=[
	Returns the magnitude of the linear value.

	@return number -- The magnitude of the linear value.
]=]
function LinearValue.GetMagnitude<T>(self: LinearValue<T>): number
	local dot: number = 0
	for i = 1, #self._values do
		local value: number = self._values[i]
		dot = dot + value * value
	end
	return math.sqrt(dot)
end

--[=[
	Returns the magnitude of the linear value.

	@prop magnitude number
	@readonly
	@within LinearValue
]=]
function LinearValue.__index<T>(self: LinearValue<T>, key: string): any
	if LinearValue[key] then
		return LinearValue[key]
	elseif key == "magnitude" or key == "Magnitude" then
		return self:GetMagnitude()
	else
		return nil
	end
end

LinearValue.__add = operation(function(a, b)
	return a + b
end)

LinearValue.__sub = operation(function(a, b)
	return a - b
end)

LinearValue.__mul = operation(function(a, b)
	return a * b
end)

LinearValue.__div = operation(function(a, b)
	return a / b
end)

function LinearValue:__eq<T>(a: LinearValue<T>, b: LinearValue<T>): boolean
	if LinearValue.isLinear(a) and LinearValue.isLinear(b) then
		if #a._values ~= #b._values then
			return false
		end

		for i = 1, #a._values do
			if a._values[i] ~= b._values[i] then
				return false
			end
		end

		return true
	else
		return false
	end
end

return LinearValue
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="253">
                <Properties>
                  <string name="Name">Spring</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	A physical model of a spring, useful in many applications.

	A spring is an object that will compute based upon Hooke's law. Properties only evaluate
	upon index making this model good for lazy applications.

	```lua
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")

	local spring = Spring.new(Vector3.zero)

	RunService.RenderStepped:Connect(function()
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			spring.Target = Vector3.new(0, 0, 1)
		else
			spring.Target = Vector3.zero
		end

		print(spring.Position) -- A smoothed out version of the input keycode W
	end)
	```

	A good visualization can be found here, provided by Defaultio:
	https://www.desmos.com/calculator/hn2i9shxbz

	@class Spring
]=]
local Spring = {}
Spring.__index = Spring

export type SpringClock = () -> number

export type Spring<T> = typeof(setmetatable(
	{} :: {
		Position: T,
		Value: T,
		Velocity: T,
		Target: T,
		Damper: number,
		Speed: number,
		Clock: SpringClock,

		_position0: T,
		_velocity0: T,
		_time0: number,
		_target: T,
		_damper: number,
		_speed: number,
		_clock: SpringClock,
		_positionVelocity: (self: Spring<T>, now: number) -> (T, T),
	},
	{} :: typeof({ __index = Spring })
))

--[=[
	Constructs a new Spring at the position and target specified, of type T.

	```lua
	-- Linear spring
	local linearSpring = Spring.new(0)

	-- Vector2 spring
	local vector2Spring = Spring.new(Vector2.zero)

	-- Vector3 spring
	local vector3Spring = Spring.new(Vector3.zero)
	```

	@param initial T -- The initial parameter is a number or Vector3 (anything with * number and addition/subtraction).
	@param clock? () -> number -- The clock function is optional, and is used to update the spring
	@return Spring<T>
]=]
function Spring.new<T>(initial: T?, clock: SpringClock?): Spring<T>
	local p0 = initial or 0
	local springClock = clock or os.clock

	return setmetatable(
		{
			_clock = springClock,
			_time0 = springClock(),
			_position0 = p0,
			_velocity0 = 0 * (p0 :: any),
			_target = p0,
			_damper = 1,
			_speed = 1,
		} :: any,
		Spring
	) :: Spring<T>
end

--[=[
	Impulses the spring, increasing velocity by the amount given. This is useful to make something shake,
	like a Mac password box failing.

	@param velocity T -- The velocity to impulse with
	@return ()
]=]
function Spring.Impulse<T>(self: Spring<T>, velocity: T)
	self.Velocity = (self.Velocity :: any) + velocity
end

--[=[
	Instantly skips the spring forwards by that amount time
	@param delta number -- Time to skip forwards
	@return ()
]=]
function Spring.TimeSkip<T>(self: Spring<T>, delta: number)
	local now = self._clock()
	local position, velocity = self:_positionVelocity(now + delta)
	self._position0 = position
	self._velocity0 = velocity
	self._time0 = now
end

--[=[
	Sets the actual target. If doNotAnimate is set, then animation will be skipped.

	@param value T -- The target to set
	@param doNotAnimate boolean? -- Whether or not to animate
]=]
function Spring.SetTarget<T>(self: Spring<T>, value: T, doNotAnimate: boolean?)
	if doNotAnimate then
		local now = self._clock()
		self._position0 = value
		self._velocity0 = 0 * (value :: any)
		self._target = value
		self._time0 = now
	else
		self.Target = value
	end
end

--[=[
	The current position at the given clock time. Assigning the position will change the spring to have that position.

	```lua
	local spring = Spring.new(0)
	print(spring.Position) --> 0
	```

	@prop Position T
	@within Spring
]=]
--[=[
	Alias for [Spring.Position](/api/Spring#Position)

	@prop p T
	@within Spring
]=]
--[=[
	The current velocity. Assigning the velocity will change the spring to have that velocity.

	```lua
	local spring = Spring.new(0)
	print(spring.Velocity) --> 0
	```

	@prop Velocity T
	@within Spring
]=]
--[=[
	Alias for [Spring.Velocity](/api/Spring#Velocity)

	@prop v T
	@within Spring
]=]
--[=[
	The current target. Assigning the target will change the spring to have that target.

	```lua
	local spring = Spring.new(0)
	print(spring.Target) --> 0
	```

	@prop Target T
	@within Spring
]=]
--[=[
	Alias for [Spring.Target](/api/Spring#Target)
	@prop t T
	@within Spring
]=]
--[=[
	The current damper, defaults to 1. At 1 the spring is critically damped. At less than 1, it
	will be underdamped, and thus, bounce, and at over 1, it will be critically damped.

	@prop Damper number
	@within Spring
]=]
--[=[
	Alias for [Spring.Damper](/api/Spring#Damper)

	@prop d number
	@within Spring
]=]
--[=[
	The speed, defaults to 1, but should be between [0, infinity)

	@prop Speed number
	@within Spring
]=]
--[=[
	Alias for [Spring.Speed](/api/Spring#Speed)

	@prop s number
	@within Spring
]=]
--[=[
	The current clock object to syncronize the spring against.

	@prop Clock () -> number
	@within Spring
]=]
(Spring :: any).__index = function<T>(self: Spring<T>, index: any): any
	if Spring[index] then
		return Spring[index]
	elseif index == "Value" or index == "Position" or index == "p" then
		local position, _ = self:_positionVelocity(self._clock())
		return position
	elseif index == "Velocity" or index == "v" then
		local _, velocity = self:_positionVelocity(self._clock())
		return velocity
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damper" or index == "d" then
		return self._damper
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	else
		error(string.format("%q is not a valid member of Spring", tostring(index)), 2)
	end
end

function Spring.__newindex<T>(self: Spring<T>, index, value)
	local now = self._clock()

	if index == "Value" or index == "Position" or index == "p" then
		local _, velocity = self:_positionVelocity(now)
		self._position0 = value
		self._velocity0 = velocity
		self._time0 = now
	elseif index == "Velocity" or index == "v" then
		local position, _ = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = value
		self._time0 = now
	elseif index == "Target" or index == "t" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._target = value
		self._time0 = now
	elseif index == "Damper" or index == "d" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._damper = value :: any
		self._time0 = now
	elseif index == "Speed" or index == "s" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._speed = if (value :: any) < 0 then 0 else value :: any
		self._time0 = now
	elseif index == "Clock" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._clock = value :: any
		self._time0 = (value :: any)()
	else
		error(string.format("%q is not a valid member of Spring", tostring(index)), 2)
	end
end

function Spring._positionVelocity<T>(self: Spring<T>, now: number): (T, T)
	local p0 = self._position0
	local v0 = self._velocity0
	local p1 = self._target
	local d: number = self._damper
	local s: number = self._speed

	local t: number = s * (now - self._time0)
	local d2 = d * d

	local h, si, co
	if d2 < 1 then
		h = math.sqrt(1 - d2)
		local ep = math.exp(-d * t) / h
		co, si = ep * math.cos(h * t), ep * math.sin(h * t)
	elseif d2 == 1 then
		h = 1
		local ep = math.exp(-d * t) / h
		co, si = ep, ep * t
	else
		h = math.sqrt(d2 - 1)
		local u = math.exp((-d + h) * t) / (2 * h)
		local v = math.exp((-d - h) * t) / (2 * h)
		co, si = u + v, u - v
	end

	local a0: any = h * co + d * si
	local a1: any = 1 - (h * co + d * si)
	local a2: any = si / s

	local b0: any = -s * si
	local b1: any = s * si
	local b2: any = h * co - d * si

	-- stylua: ignore
	return a0 * p0 + a1 * p1 + a2 * v0,
		b0 * p0 + b1 * p1 + b2 * v0
end

return Spring
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="254">
                <Properties>
                  <string name="Name">SpringUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions that are related to the Spring object
	@class SpringUtils
]=]

local require = require(script.Parent.loader).load(script)

local LinearValue = require("LinearValue")
local Spring = require("Spring")

local SpringUtils = {}

local EPSILON = 1e-6

--[=[
	Utility function that returns whether or not a spring is animating based upon
	velocity and closeness to target, and as the second value, the value that should be
	used.

	@param spring Spring<T>
	@param epsilon number? -- Optional epsilon
	@return boolean, T
]=]
function SpringUtils.animating<T>(spring: Spring.Spring<T>, epsilon: number?): (boolean, T)
	local thisEpsilon = epsilon or EPSILON

	local position = spring.Position
	local target = spring.Target

	local animating
	if type(target) == "number" then
		animating = math.abs((spring :: any).Position - (spring :: any).Target) > thisEpsilon
			or math.abs((spring :: any).Velocity) > thisEpsilon
	else
		local rbxtype = typeof(target)
		if rbxtype == "Vector3" or rbxtype == "Vector2" or LinearValue.isLinear(target) then
			animating = ((spring :: any).Position - (spring :: any).Target).magnitude > thisEpsilon
				or (spring :: any).Velocity.magnitude > thisEpsilon
		else
			error("Unknown type")
		end
	end

	if animating then
		return true, position
	else
		-- We need to return the target so we use the actual target value (i.e. pretend like the (spring :: any) is asleep)
		return false, target
	end
end

--[=[
	Add to spring position to adjust for velocity of target. May have to set clock to time().

	@param velocity T
	@param dampen number
	@param speed number
	@return T
]=]
function SpringUtils.getVelocityAdjustment<T>(velocity: T, dampen: number, speed: number): T
	assert(velocity, "Bad velocity")
	assert(dampen, "Bad dampen")
	assert(speed, "Bad speed")

	return (velocity :: any) * (2 * dampen / speed)
end

--[=[
	Converts an arbitrary value to a LinearValue if Roblox has not defined this value
	for multiplication and addition.

	@param value T
	@return LinearValue<T> | T
]=]
function SpringUtils.toLinearIfNeeded<T>(value: T): LinearValue.LinearValue<T> | T
	return LinearValue.toLinearIfNeeded(value)
end

--[=[
	Extracts the base value out of a packed linear value if needed.

	@param value LinearValue<T> | any
	@return T | any
]=]
function SpringUtils.fromLinearIfNeeded<T>(value: LinearValue.LinearValue<T> | T): T
	return LinearValue.fromLinearIfNeeded(value)
end

return SpringUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="255">
            <Properties>
              <string name="Name">steputils</string>
            </Properties>
            <Item class="Folder" referent="256">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="257">
                <Properties>
                  <string name="Name">StepUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions primarily used to bind animations into update loops of the Roblox engine.
	@class StepUtils
]=]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local StepUtils = {}

--[=[
	Binds the given update function to [RunService.RenderStepped].

	```lua
	local spring = Spring.new(0)
	local maid = Maid.new()

	local startAnimation, maid._stopAnimation = StepUtils.bindToRenderStep(function()
		local animating, position = SpringUtils.animating(spring)

		print(position)

		return animating
	end)

	spring.t = 1
	startAnimation()
	```

	:::tip
	Be sure to call the disconnect function when cleaning up, otherwise you may memory leak.
	:::

	@param update () -> boolean -- should return true while it needs to update
	@return (...) -> () -- Connect function
	@return () -> () -- Disconnect function
]=]
function StepUtils.bindToRenderStep(update: () -> boolean): () -> ()
	return StepUtils.bindToSignal(RunService.RenderStepped, update)
end

--[=[
	Yields until the frame deferral is done
]=]
function StepUtils.deferWait(): ()
	local current = coroutine.running()
	task.defer(task.spawn, current)
	coroutine.yield()
end

--[=[
	Binds the given update function to [RunService.Stepped]. See [StepUtils.bindToRenderStep] for details.


	:::tip
	Be sure to call the disconnect function when cleaning up, otherwise you may memory leak.
	:::

	@param update () -> boolean -- should return true while it needs to update
	@return (...) -> () -- Connect function
	@return () -> () -- Disconnect function
]=]
function StepUtils.bindToStepped(update: () -> boolean): () -> ()
	return StepUtils.bindToSignal(RunService.Stepped, update)
end

--[=[
	Binds an update event to a signal until the update function stops returning a truthy
	value.

	@param signal Signal | RBXScriptSignal
	@param update () -> boolean -- should return true while it needs to update
	@return (...) -> () -- Connect function
	@return () -> () -- Disconnect function
]=]
function StepUtils.bindToSignal(signal: RBXScriptSignal, update: () -> boolean): (() -> (), () -> ())
	if typeof(signal) ~= "RBXScriptSignal" then
		error("signal must be of type RBXScriptSignal")
	end
	if type(update) ~= "function" then
		error(string.format("update must be of type function, got %q", type(update)))
	end

	local conn: RBXScriptConnection? = nil
	local function disconnect()
		if conn then
			conn:Disconnect()
			conn = nil
		end
	end

	local function connect(...)
		-- Ignore if we have an existing connection
		if conn and conn.Connected then
			return
		end

		-- Check to see if we even need to bind an update
		if not update(...) then
			return
		end

		-- Avoid reentrance, if update() triggers another connection, we'll already be connected.
		if conn and conn.Connected then
			return
		end

		-- Usually contains just the self arg!
		local args = { ... }

		-- Bind to render stepped
		conn = signal:Connect(function()
			if not update(unpack(args)) then
				disconnect()
			end
		end)
	end

	return connect, disconnect
end

--[=[
	Calls the function once at the given priority level, unless the cancel callback is
	invoked.

	@param priority number
	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtRenderPriority(priority: number, func: () -> ()): () -> ()
	assert(type(priority) == "number", "Bad priority")
	assert(type(func) == "function", "Bad func")

	local key = string.format("StepUtils.onceAtPriority_%s", HttpService:GenerateGUID(false))

	local function cleanup()
		RunService:UnbindFromRenderStep(key)
	end

	RunService:BindToRenderStep(key, priority, function()
		cleanup()
		func()
	end)

	return cleanup
end

--[=[
	Invokes the function once at stepped, unless the cancel callback is called.

	```lua
	-- Sometimes you need to defer the execution of code to make physics happy
	maid:GiveTask(StepUtils.onceAtStepped(function()
		part.CFrame = CFrame.new(0, 0, )
	end))
	```

	:::tip
	use `RunService.Stepped:Once()` instead
	:::

	@deprecated 3.5.2
	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtStepped(func: () -> ()): () -> ()
	local conn = RunService.Stepped:Once(func)
	return function()
		conn:Disconnect()
	end
end

--[=[
	Invokes the function once at renderstepped, unless the cancel callback is called.

	:::tip
	use `RunService.RenderStepped:Once()` instead
	:::

	@deprecated 3.5.2
	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtRenderStepped(func: () -> ()): () -> ()
	local conn = RunService.RenderStepped:Once(func)
	return function()
		conn:Disconnect()
	end
end

--[=[
	Invokes the function once at the given event, unless the cancel callback is called.

	@deprecated 3.5.2
	@param event Signal | RBXScriptSignal
	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtEvent(event: RBXScriptSignal, func: () -> ()): () -> ()
	assert(type(func) == "function", "Bad func")

	local conn: RBXScriptConnection?
	local function cleanup()
		if conn then
			conn:Disconnect()
			conn = nil
		end
	end

	conn = event:Connect(function(...)
		cleanup()
		func(...)
	end)

	return cleanup
end

return StepUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="258">
                <Properties>
                  <string name="Name">onRenderStepFrame</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Executes code at a specific point in render step priority queue
	@class onRenderStepFrame
]=]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

--[=[
	Executes code at a specific point in render step priority queue.
	@function onRenderStepFrame
	@param priority number
	@return MaidTask
	@within onRenderStepFrame
]=]

return function(priority: number, callback: () -> ()): () -> ()
	assert(type(priority) == "number", "Bad priority")
	assert(type(callback) == "function", "Bad callback")

	local key = HttpService:GenerateGUID(false) .. "_onRenderStepFrame"
	local unbound = false

	RunService:BindToRenderStep(key, priority, function()
		if not unbound then -- Probably not needed
			RunService:UnbindFromRenderStep(key)
			callback()
		end
	end)

	return function()
		if not unbound then
			RunService:UnbindFromRenderStep(key)
			unbound = true
		end
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="259">
                <Properties>
                  <string name="Name">onSteppedFrame</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Executes code at a specific point in Roblox's engine
	@class onSteppedFrame
]=]

local RunService = game:GetService("RunService")

--[=[
	Executes code at a specific point in Roblox's engine.
	@function onSteppedFrame
	@param func function
	@return RBXScriptConnection
	@within onSteppedFrame
]=]
return function(func: () -> ())
	assert(type(func) == "function", "Bad func")

	return RunService.Stepped:Once(func)
end
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="260">
            <Properties>
              <string name="Name">string</string>
            </Properties>
            <Item class="Folder" referent="261">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="262">
                <Properties>
                  <string name="Name">String</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	This module provides utility functions for strings
	@class String
]=]

local String = {}

--[=[
	Trims the string of the given pattern

	@param str string
	@param pattern string? -- Defaults to whitespace
	@return string
]=]
function String.trim(str: string, pattern: string?): string
	if pattern == nil then
		return string.match(str, "^%s*(.-)%s*$") :: string
	else
		-- When we find the first non space character defined by ^%s
		-- we yank out anything in between that and the end of the string
		-- Everything else is replaced with %1 which is essentially nothing
		return string.match(str, "^" .. pattern .. "*(.-)" .. pattern .. "*$")
	end
end

--[=[
	Converts the string to `UpperCamelCase` from `camelCase` or `snakeCase` or `YELL_CASE`
	@param str string
	@return string
]=]
function String.toCamelCase(str: string): string
	str = string.lower(str)
	str = string.gsub(str, "[ _](%a)", string.upper)
	str = string.gsub(str, "^%a", string.upper)
	str = string.gsub(str, "%p", "")

	return str
end

--[=[
	Uppercases the first letter of the string
	@param str string
	@return string
]=]
function String.uppercaseFirstLetter(str: string): string
	return (string.gsub(str, "^%a", string.upper))
end

--[=[
	Converts to the string to `lowerCamelCase` from `camelCase` or `snakeCase` or `YELL_CASE`
	@param str string
	@return string
]=]
function String.toLowerCamelCase(str: string): string
	str = string.lower(str)
	str = string.gsub(str, "[ _](%a)", string.upper)
	str = string.gsub(str, "^%a", string.lower)
	str = string.gsub(str, "%p", "")

	return str
end

--[=[
	Converts the string to _privateCamelCase
	@param str string
	@return string
]=]
function String.toPrivateCase(str: string): string
	return "_" .. string.lower(string.sub(str, 1, 1)) .. str:sub(2, #str)
end

--[=[
	Like trim, but only applied to the beginning of the setring
	@param str string
	@param pattern string? -- Defaults to whitespace
	@return string
]=]
function String.trimFront(str: string, pattern: string?): string
	local strPattern = pattern or "%s"
	return (string.gsub(str, "^" .. strPattern .. "*(.-)" .. strPattern .. "*", "%1"))
end

--[=[
	Counts the number of times a char appears in a string.

	:::note
	Note that this is not UTF8 safe
	:::

	@param str string
	@param char string
	@return number
]=]
function String.checkNumOfCharacterInString(str: string, char: string): number
	local count = 0
	for _ in string.gmatch(str, char) do
		count = count + 1
	end
	return count
end

--[=[
	Checks if a string is empty or nil
	@param str string
	@return boolean
]=]
function String.isEmptyOrWhitespaceOrNil(str: string): boolean
	return type(str) ~= "string" or str == "" or String.isWhitespace(str)
end

--[=[
	Returns whether or not text is only whitespace
	@param str string
	@return boolean
]=]
function String.isWhitespace(str: string): boolean
	return string.match(str, "[%s]+") == str
end

--[=[
	Converts text to have a ... after it if it's too long.
	@param str string
	@param characterLimit number
	@return string
]=]
function String.elipseLimit(str: string, characterLimit: number): string
	if #str > characterLimit then
		str = string.sub(str, 1, characterLimit - 3) .. "..."
	end
	return str
end

--[=[
	Removes a prefix from a string if it exists

	@param str string
	@param prefix string
	@return string
]=]
function String.removePrefix(str: string, prefix: string): string
	if string.sub(str, 1, #prefix) == prefix then
		return string.sub(str, #prefix + 1)
	else
		return str
	end
end

--[=[
	Removes a postfix from a string if it exists

	@param str string
	@param postfix string
	@return string
]=]
function String.removePostfix(str: string, postfix: string): string
	if string.sub(str, -#postfix) == postfix then
		return string.sub(str, 1, -#postfix - 1)
	else
		return str
	end
end

--[=[
	Returns if a string ends with a postfix

	@param str string
	@param postfix string
	@return boolean
]=]
function String.endsWith(str: string, postfix: string): boolean
	return string.sub(str, -#postfix) == postfix
end

--[=[
	Returns if a string starts with a postfix

	@param str string
	@param prefix string
	@return boolean
]=]
function String.startsWith(str: string, prefix: string): boolean
	return string.sub(str, 1, #prefix) == prefix
end

--[=[
	Adds commas to a number. Not culture aware.

	See [NumberLocalizationUtils.abbreviate] for a culture aware version.

	@param number string | number
	@param seperator string?
	@return string
]=]
function String.addCommas(number: string | number, seperator: string): string
	local strNumber
	if type(number) == "number" then
		strNumber = tostring(number)
	else
		strNumber = number
	end
	seperator = seperator or ","

	local index = -1

	while index ~= 0 do
		strNumber, index = string.gsub(strNumber, "^(-?%d+)(%d%d%d)", "%1" .. seperator .. "%2")
	end

	return strNumber
end

return String
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="263">
            <Properties>
              <string name="Name">symbol</string>
            </Properties>
            <Item class="Folder" referent="264">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="265">
                <Properties>
                  <string name="Name">Symbol</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
	@class Symbol
]=]

local Symbol = {}

export type Symbol = typeof(newproxy(true))

--[=[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.

	@param name string
	@return Symbol
]=]
function Symbol.named(name: string): Symbol
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = string.format("Symbol(%s)", name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[=[
	Returns true if a symbol

	@param value boolean
	@return boolean
]=]
function Symbol.isSymbol(value: any): boolean
	return typeof(value) == "userdata"
end

return Symbol
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="266">
            <Properties>
              <string name="Name">table</string>
            </Properties>
            <Item class="Folder" referent="267">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="268">
                <Properties>
                  <string name="Name">Set</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions involving sets, which are tables with the key as an index, and the value as a
	truthy value.
	@class Set
]=]

export type Set<Key> = { [Key]: true }
export type Array<Value> = { [number]: Value }
export type Map<Key, Value> = { [Key]: Value }

local Set = {}

--[=[
	Unions the set with the other set, making a copy.
	@param set table
	@param otherSet table
	@return table
]=]
function Set.union<T, U>(set: Set<T>, otherSet: Set<U>): Set<T | U>
	local newSet: Set<T | U> = {}
	for key, _ in set do
		newSet[key] = true
	end
	for key, _ in otherSet do
		newSet[key] = true
	end
	return newSet
end

--[=[
	Unions the set with the other set, updating the `set`
	@param set table
	@param otherSet table
	@return table
]=]
function Set.unionUpdate<T>(set: Set<T>, otherSet: Set<T>)
	for key, _ in otherSet do
		set[key] = true
	end
end

--[=[
	Finds the set intersection betwen the two sets
	@param set table
	@param otherSet table
	@return table
]=]
function Set.intersection<T>(set: Set<T>, otherSet: Set<T>): Set<T>
	local newSet: Set<T> = {}
	for key, _ in set do
		if otherSet[key] ~= nil then
			newSet[key] = true
		end
	end
	return newSet
end

--[=[
	Makes a copy of the set, making the values as true.
	@param set table
	@return table
]=]
function Set.copy<T>(set: Set<T>): Set<T>
	local newSet: Set<T> = {}
	for key, _ in set do
		newSet[key] = true
	end
	return newSet
end

--[=[
	Counts the number of entries in the set (linear)
]=]
function Set.count<T>(set: Set<T>): number
	local count = 0
	for _, _ in set do
		count += 1
	end
	return count
end

--[=[
	Makes a new set from the given keys of a table
	@param tab table
	@return table
]=]
function Set.fromKeys<T>(tab: Map<T, any>): Set<T>
	local newSet: Set<T> = {}
	for key, _ in tab do
		newSet[key] = true
	end
	return newSet
end

--[=[
	Converts a set from table values.
	@param tab table
	@return table
]=]
function Set.fromTableValue<T>(tab: Map<any, T>): Set<T>
	local set: Set<T> = {}

	for _, value in tab do
		set[value] = true
	end

	return set
end

--[=[
	Converts a set from a list
	@function fromList
	@param tab table
	@return table
	@within Set
]=]
Set.fromList = Set.fromTableValue

--[=[
	Converts a set to a list
	@param set table
	@return table
]=]
function Set.toList<T>(set: { [T]: any }): Array<T>
	local list = {}

	for value, _ in set do
		table.insert(list, value)
	end

	return list
end

--[=[
	Converts a set to a list
	@param set table
	@param otherSet table
	@return table
]=]
function Set.differenceUpdate<T>(set: Set<T>, otherSet: Set<T>)
	for value, _ in otherSet do
		set[value] = nil
	end
end

--[=[
	Computes the set difference between the two sets
	@param set table
	@param otherSet table
	@return table
]=]
function Set.difference<T>(set: Set<T>, otherSet: Set<T>): Set<T>
	local newSet: Set<T> = {}
	for key, _ in set do
		newSet[key] = true
	end
	for key, _ in otherSet do
		newSet[key] = nil
	end
	return newSet
end

return Set
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="269">
                <Properties>
                  <string name="Name">Table</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Provide a variety of utility table operations
	@class Table
]=]

local Table = {}

export type Array<T> = { [number]: T }
export type Map<Key, Value> = { [Key]: Value }

--[=[
	Concats `target` with `source` in-place, modifying the target

	@param target table -- Table to append to
	@param source table -- Table read from
	@return table -- parameter table
]=]
function Table.append<T>(target: Array<T>, source: Array<T>): Array<T>
	for _, value in source do
		target[#target + 1] = value
	end

	return target
end

--[=[
	Shallow merges two tables without modifying either.

	@param orig table -- Original table
	@param new table -- Result
	@return table
]=]
function Table.merge<T, U, T2, U2>(orig: Map<T, U>, new: Map<T2, U2>): Map<T | T2, U | U2>
	local result = table.clone(orig)
	for key, val in new do
		result[key :: any] = val :: any
	end
	return result
end

--[=[
	Reverses the list and returns the reversed copy

	@param orig table -- Original table
	@return table
]=]
function Table.reverse<T>(orig: Array<T>): Array<T>
	local new = {}
	for i = #orig, 1, -1 do
		table.insert(new, orig[i])
	end
	return new
end

--[=[
	Returns a list of all of the values that a table has.

	@param source table -- Table source to extract values from
	@return table -- A list with all the values the table has
]=]
function Table.values<T>(source: Map<any, T>): Array<T>
	local new = {}
	for _, val in source do
		table.insert(new, val)
	end
	return new
end

--[=[
	Returns a list of all of the keys that a table has. (In order of pairs)

	@param source table -- Table source to extract keys from
	@return table -- A list with all the keys the table has
]=]
function Table.keys<T>(source: Map<T, any>): Array<T>
	local new = {}
	for key, _ in source do
		table.insert(new, key)
	end
	return new
end

--[=[
	Shallow merges two lists without modifying either.

	@param orig table -- Original table
	@param new table -- Result
	@return table
]=]
function Table.mergeLists<T, U>(orig: Array<T>, new: Array<U>): Array<T | U>
	local _table: Array<T | U> = {}
	for _, val in orig do
		table.insert(_table, val)
	end
	for _, val in new do
		table.insert(_table, val)
	end
	return _table
end

--[=[
	Swaps keys with values, overwriting additional values if duplicated.

	@param orig table -- Original table
	@return table
]=]
function Table.swapKeyValue<Key, Value>(orig: Map<Key, Value>): Map<Value, Key>
	local tab = {}
	for key, val in orig do
		tab[val] = key
	end
	return tab
end

--[=[
	Converts a table to a list.

	@param _table table -- Table to convert to a list
	@return table
]=]
function Table.toList<T>(_table: Map<any, T>): Array<T>
	local list = {}
	for _, item in _table do
		table.insert(list, item)
	end
	return list
end

--[=[
	Counts the number of items in `_table`.
	Useful since `__len` on table in Lua 5.2 returns just the array length.

	@param _table table -- Table to count
	@return number -- count
]=]
function Table.count(_table: Map<any, any>): number
	local count = 0
	for _, _ in _table do
		count = count + 1
	end
	return count
end

--[=[
	Shallow copies a table from target into a new table

	@function Table.copy
	@param target table -- Table to copy
	@return table -- Result
	@within Table
]=]
Table.copy = table.clone

--[=[
	Deep copies a table including metatables

	@param target table -- Table to deep copy
	@param _deepCopyContext table? -- Context to deepCopy the value in
	@return table -- Result
]=]
function Table.deepCopy<T>(target: T, _deepCopyContext: any?): T
	local context = _deepCopyContext or {}
	if context[target] then
		return context[target]
	end

	if type(target) == "table" then
		local new = {}
		context[target] = new
		for index, value in target do
			new[Table.deepCopy(index, context)] = Table.deepCopy(value, context)
		end
		return setmetatable(new, Table.deepCopy(getmetatable(target), context) :: any) :: any
	else
		return target
	end
end

--[=[
	Overwrites a table's value
	@param target table -- Target table
	@param source table -- Table to read from
	@return table -- target
]=]
function Table.deepOverwrite<K0, K1, V0, V1>(target: Map<K0, V0>, source: Map<K1, V1>): Map<K0 | K1, V0 | V1>
	for index: any, value: any in source do
		if type(target[index]) == "table" and type(value) == "table" then
			target[index] = Table.deepOverwrite(target[index] :: any, value) :: any
		else
			target[index] = value
		end
	end
	return target
end

--[=[
	Gets an index by value, returning `nil` if no index is found.
	@param haystack table -- To search in
	@param needle Value to search for
	@return The index of the value, if found
	@return nil -- if not found
]=]
function Table.getIndex<T>(haystack: Array<T>, needle: T): number?
	assert(needle ~= nil, "Needle cannot be nil")

	for index, item in haystack do
		if needle == item then
			return index
		end
	end

	return nil
end

--[=[
	Recursively prints the table. Does not handle recursive tables.

	@param _table table -- Table to stringify
	@param indent number? -- Indent level
	@param output string? -- Output string, used recursively
	@return string -- The table in string form
]=]
function Table.stringify<Key, Value>(_table: Map<Key, Value>, indent: number?, output: string?): string
	local result = output or tostring(_table)
	local stringIndent = indent or 0
	for key, value in _table do
		local formattedText = "\n" .. string.rep("  ", stringIndent) .. tostring(key) .. ": "
		if type(value) == "table" then
			result = result .. formattedText
			result = Table.stringify(value, stringIndent + 1, result)
		else
			result = result .. formattedText .. tostring(value)
		end
	end
	return result
end

--[=[
	Returns whether `value` is within `table`

	@param _table table -- To search in for value
	@param value any -- Value to search for
	@return boolean -- `true` if within, `false` otherwise
]=]
function Table.contains<T>(_table: { T }, value: T): boolean
	for _, item in _table do
		if item == value then
			return true
		end
	end

	return false
end

--[=[
	Overwrites an existing table with the source values.

	@param target table -- Table to overwite
	@param source table -- Source table to read from
	@return table -- target
]=]
function Table.overwrite(target, source)
	for index, item in source do
		target[index] = item
	end

	return target
end

--[=[
	Deep equivalent comparison of a table assuming keys are indexable in the same way.

	@param target table -- Table to check
	@param source table -- Other table to check
	@return boolean
]=]
function Table.deepEquivalent(target, source): boolean
	if target == source then
		return true
	end

	if type(target) ~= type(source) then
		return false
	end

	if type(target) == "table" then
		for key, value in target do
			if not Table.deepEquivalent(value, source[key]) then
				return false
			end
		end

		for key, value in source do
			if not Table.deepEquivalent(value, target[key]) then
				return false
			end
		end

		return true
	else
		-- target == source should do it.
		return false
	end
end

--[=[
	Takes `count` entries from the table. If the table does not have
	that many entries, will return up to the number the table has to
	provide.

	@param source table -- Source table to retrieve values from
	@param count number -- Number of entries to take
	@return table -- List with the entries retrieved
]=]
function Table.take<T>(source: Array<T>, count: number): Array<T>
	local n = math.min(#source, count)
	local newTable = table.create(n)

	for i = 1, n do
		newTable[i] = source[i]
	end

	return newTable
end

local function errorOnIndex(_, index)
	error(string.format("Bad index %q", tostring(index)), 2)
end

local READ_ONLY_METATABLE = {
	__index = errorOnIndex,
	__newindex = errorOnIndex,
}

--[=[
	Sets a metatable on a table such that it errors when
	indexing a nil value

	@param target table -- Table to error on indexing
	@return table -- The same table, with the metatable set to readonly
]=]
function Table.readonly<T>(target: T): T
	return table.freeze(setmetatable(target :: any, READ_ONLY_METATABLE)) :: any
end

--[=[
	Sets a metatable on a table such that it errors when
	indexing a nil value

	@param target table -- Table to error on indexing
	@return table -- The same table, with the target set to error on nil
]=]
function Table.errorOnNilIndex<T>(target: T): T
	return setmetatable(target :: any, READ_ONLY_METATABLE)
end

--[=[
	Recursively sets the table as ReadOnly

	@param target table -- Table to error on indexing
	@return table -- The same table
]=]
function Table.deepReadonly<T>(target: T): T
	for _, item in target :: any do
		if type(item) == "table" then
			Table.deepReadonly(item)
		end
	end

	return Table.readonly(target)
end

return Table
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="270">
            <Properties>
              <string name="Name">templateprovider</string>
            </Properties>
            <Item class="Folder" referent="271">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="Folder" referent="272">
                <Properties>
                  <string name="Name">Modules</string>
                </Properties>
                <Item class="ModuleScript" referent="273">
                  <Properties>
                    <string name="Name">ModuleProvider</string>
                    <string name="Source"><![CDATA[--[=[
	Creates a service that provides modules from a parent module, either by name, or by list!
	@class ModuleProvider
]=]

local ModuleProvider = {}
ModuleProvider.ClassName = "ModuleProvider"
ModuleProvider.ServiceName = "ModuleProvider"
ModuleProvider.__index = ModuleProvider

function ModuleProvider.new(parent, checkModule, initModule, sortList)
	local self = setmetatable({}, ModuleProvider)

	assert(typeof(parent) == "Instance", "Bad parent")
	assert(checkModule == nil or type(checkModule) == "function", "Bad checkModule")
	assert(initModule == nil or type(initModule) == "function", "Bad initModule")
	assert(sortList == nil or type(sortList) == "function", "Bad sortList")

	self._parent = parent or error("No parent")

	self._initModule = initModule
	self._checkModule = checkModule
	self._sortList = sortList

	return self
end

function ModuleProvider:Init()
	assert(not self._modulesList, "Already initialized")

	self._modulesList = {}
	self._moduleScriptToModule = {}
	self._registry = {}

	self:_processFolder(self._parent)

	if self._sortList then
		self._sortList(self._modulesList)
	end

	if self._initModule then
		for moduleScript, _module in self._moduleScriptToModule do
			self._initModule(_module, moduleScript)
		end
	end

	self._moduleScriptToModule = nil
end

function ModuleProvider:GetModules()
	assert(self._modulesList, "Not initialized yet")

	return self._modulesList
end

function ModuleProvider:GetFromName(name)
	assert(self._registry, "Not initialized yet")
	assert(type(name) == "string", "Bad name")

	return self._registry[name]
end

function ModuleProvider:_processFolder(folder)
	for _, moduleScript in folder:GetChildren() do
		if moduleScript:IsA("ModuleScript") then
			self:_addToRegistery(moduleScript)
		else
			self:_processFolder(moduleScript)
		end
	end
end

function ModuleProvider:_addToRegistery(moduleScript)
	if self._registry[moduleScript.Name] then
		error(string.format("[ModuleProvider._addToRegistery] - Duplicate %q in registery", moduleScript.Name))
	end

	if not moduleScript.Parent:FindFirstChild("loader") then
		local fakeLoader = script.Parent.ModuleProviderFakeLoader:Clone()
		fakeLoader.Name = "loader"
		fakeLoader.Archivable = false
		fakeLoader.Parent = moduleScript.Parent
	end

	local _module
	xpcall(function()
		_module = require(moduleScript)
	end, function(err)
		error(
			string.format(
				"[ModuleProvider._addToRegistery] - Failed to load %q due to %q",
				moduleScript:GetFullName(),
				tostring(err)
			)
		)
	end)

	if self._checkModule then
		local ok, err = self._checkModule(_module, moduleScript)
		if not ok then
			error(string.format("[ModuleProvider] - Bad module %q - %q", moduleScript:GetFullName(), tostring(err)))
		end
	end

	table.insert(self._modulesList, _module)
	self._moduleScriptToModule[moduleScript] = _module
	self._registry[moduleScript.Name] = _module
end

return ModuleProvider
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="274">
                  <Properties>
                    <string name="Name">ModuleProviderFakeLoader</string>
                    <string name="Source"><![CDATA[--[=[
	Creates a service that provides modules from a parent module, either by name, or by list!
	@class ModuleProviderFakeLoader
]=]

local function load(script)
	local moduleProvider = script:FindFirstAncestorWhichIsA("ModuleScript")
	assert(moduleProvider, "No moduleProvider")

	local loader = require(moduleProvider.Parent.loader)
	return loader.load(moduleProvider)
end

return {
	load = load,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="275">
                <Properties>
                  <string name="Name">Replication</string>
                </Properties>
                <Item class="Folder" referent="276">
                  <Properties>
                    <string name="Name">Util</string>
                  </Properties>
                  <Item class="ModuleScript" referent="277">
                    <Properties>
                      <string name="Name">TemplateReplicationModes</string>
                      <string name="Source"><![CDATA[--!strict
--[=[
	@class TemplateReplicationModes
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

export type TemplateReplicationMode = "client" | "server" | "shared"

type TemplateReplicationModeMap = {
	CLIENT: "client",
	SERVER: "server",
	SHARED: "shared",
}

return Table.readonly({
	CLIENT = "client",
	SERVER = "server",
	SHARED = "shared",
} :: TemplateReplicationModeMap)
]]></string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="278">
                    <Properties>
                      <string name="Name">TemplateReplicationModesUtils</string>
                      <string name="Source"><![CDATA[--!strict
--[=[
	@class TemplateReplicationModesUtils
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local TemplateReplicationModes = require("TemplateReplicationModes")

local TemplateReplicationModesUtils = {}

--[=[
	Uses run service to infer the replication mode
]=]
function TemplateReplicationModesUtils.inferReplicationMode(): TemplateReplicationModes.TemplateReplicationMode
	if not RunService:IsRunning() then
		return TemplateReplicationModes.SHARED
	end

	if RunService:IsServer() then
		return TemplateReplicationModes.SERVER
	elseif RunService:IsClient() then
		return TemplateReplicationModes.CLIENT
	else
		return TemplateReplicationModes.SHARED
	end
end

return TemplateReplicationModesUtils
]]></string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="279">
                <Properties>
                  <string name="Name">TaggedTemplateProvider</string>
                  <string name="Source"><![CDATA[--[=[
	Like a template provider, but it also reparents and retrieves tagged objects

	@class TaggedTemplateProvider
]=]

local require = require(script.Parent.loader).load(script)

local RxCollectionServiceUtils = require("RxCollectionServiceUtils")
local TemplateProvider = require("TemplateProvider")

local TaggedTemplateProvider = {}

function TaggedTemplateProvider.new(providerName: string, tagName: string): TemplateProvider.TemplateProvider
	assert(type(providerName) == "string", "bad providerName")
	assert(type(tagName) == "string", "Bad tagName")

	return TemplateProvider.new(providerName, RxCollectionServiceUtils.observeTaggedBrio(tagName))
end

return TaggedTemplateProvider
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="280">
                <Properties>
                  <string name="Name">TemplateProvider</string>
                  <string name="Source"><![CDATA[--[=[
	Base of a template retrieval system. Templates can be retrieved from Roblox and then retrieved by name. If a folder is used
	all of their children are also included as templates, which allows for flexible organization by artists.

	Additionally, you can provide template overrides as the last added template will always be used.

	```lua
	-- shared/CarTemplates.lua

	return TemplateProvider.new(script.Name, script) -- Load locally
	```

	:::tip
	If the TemplateProvider is initialized on the server, the the templates will be hidden from the client until the
	client requests them.

	This prevents large amounts of templates from being rendered to the client, taking up memory on the client. This especially
	affects meshes, but can also affect sounds and other similar templates.
	:::

	```lua
	-- Server
	local serviceBag = ServiceBag.new()
	local templates = serviceBag:GetService(require("CarTemplates"))
	serviceBag:Init()
	serviceBag:Start()
	```

	```lua
	-- Client
	local serviceBag = ServiceBag.new()
	local templates = serviceBag:GetService(require("CarTemplates"))
	serviceBag:Init()
	serviceBag:Start()

	templates:PromiseCloneTemplate("CopCar"):Then(function(crate)
		print("Got crate!")
	end)
	```

	@class TemplateProvider
]=]

local require = require(script.Parent.loader).load(script)

local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Brio = require("Brio")
local DuckTypeUtils = require("DuckTypeUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local ObservableCountingMap = require("ObservableCountingMap")
local ObservableMapList = require("ObservableMapList")
local Promise = require("Promise")
local PromiseMaidUtils = require("PromiseMaidUtils")
local Remoting = require("Remoting")
local Rx = require("Rx")
local RxInstanceUtils = require("RxInstanceUtils")
local ServiceBag = require("ServiceBag")
local String = require("String")
local TemplateReplicationModes = require("TemplateReplicationModes")
local TemplateReplicationModesUtils = require("TemplateReplicationModesUtils")

local TOMBSTONE_ID_ATTRIBUTE = "UnreplicatedTemplateId"
local TOMBSTONE_NAME_POSTFIX_UNLOADED = "_Unloaded"
local TOMBSTONE_NAME_POSTFIX_LOADED = "_Loaded"

local TemplateProvider = {}
TemplateProvider.ClassName = "TemplateProvider"
TemplateProvider.ServiceName = "TemplateProvider"
TemplateProvider.__index = TemplateProvider

--[=[
	@type TemplateDeclaration Instance | Observable<Brio<Instance>> | table
	@within TemplateProvider
]=]
export type TemplateDeclaration = Instance | Observable.Observable<Brio.Brio<Instance>> | { TemplateDeclaration }

export type TemplateProvider = typeof(setmetatable(
	{} :: {
		_serviceBag: ServiceBag.ServiceBag,
		_initialTemplates: TemplateDeclaration,
		_maid: Maid.Maid,
		_templateMapList: any, -- ObservableMapList.ObservableMapList<Instance>,
		_unreplicatedTemplateMapList: any, -- ObservableMapList.ObservableMapList<Instance>,
		_containerRootCountingMap: ObservableCountingMap.ObservableCountingMap<Instance>,
		_remoting: Remoting.Remoting,
		_tombstoneLookup: { [string]: Instance },
		_pendingTemplatePromises: { [string]: Promise.Promise<Instance> },
		_pendingTombstoneRequests: { [string]: Promise.Promise<Instance> },
		_replicationMode: TemplateReplicationModes.TemplateReplicationMode,
	},
	{} :: typeof({ __index = TemplateProvider })
))

--[=[
	Constructs a new [TemplateProvider].

	@param providerName string
	@param initialTemplates TemplateDeclaration
]=]
function TemplateProvider.new(providerName: string, initialTemplates: TemplateDeclaration): TemplateProvider
	assert(type(providerName) == "string", "Bad providerName")
	local self = setmetatable({}, TemplateProvider)

	self.ServiceName = assert(providerName, "No providerName")
	self._initialTemplates = initialTemplates

	if not (self:_isValidTemplateDeclaration(self._initialTemplates) or self._initialTemplates == nil) then
		error(
			string.format(
				"[TemplateProvider.%s] - Bad initialTemplates of type %s",
				self.ServiceName,
				typeof(initialTemplates)
			)
		)
	end

	return self
end

--[=[
	Returns if the value is a template provider

	@param value any
	@return boolean
]=]

function TemplateProvider.isTemplateProvider(value: any): boolean
	return DuckTypeUtils.isImplementation(TemplateProvider, value)
end

--[=[
	Initializes the container provider. Should be done via [ServiceBag].

	@param serviceBag ServiceBag
]=]
function TemplateProvider.Init(self: TemplateProvider, serviceBag: ServiceBag.ServiceBag)
	assert(not self._serviceBag, "Already initialized")
	self._serviceBag = assert(serviceBag, "No serviceBag")
	self._maid = Maid.new()

	self._replicationMode = TemplateReplicationModesUtils.inferReplicationMode()

	-- There can be multiple templates for a given name
	self._templateMapList = self._maid:Add(ObservableMapList.new())
	self._unreplicatedTemplateMapList = self._maid:Add(ObservableMapList.new())

	self._containerRootCountingMap = self._maid:Add(ObservableCountingMap.new())
	self._pendingTemplatePromises = {} -- [templateName] = Promise

	self:_setupTemplateCache()
end

function TemplateProvider._setupTemplateCache(self: TemplateProvider)
	if self._replicationMode == TemplateReplicationModes.SERVER then
		self._tombstoneLookup = {}
		self._remoting = self._maid:Add(Remoting.Server.new(ReplicatedStorage, self.ServiceName .. "TemplateProvider"))

		-- TODO: Maybe de-duplicate and use a centralized service
		self._maid:GiveTask(self._remoting.ReplicateTemplate:Bind(function(player, tombstoneId)
			assert(type(tombstoneId) == "string", "Bad tombstoneId")
			assert(self._tombstoneLookup[tombstoneId], "Not a valid tombstone")

			-- Stuff doesn't replicate in the PlayerGui
			local playerGui = player:FindFirstChildWhichIsA("PlayerGui")
			if not playerGui then
				return Promise.rejected("No playerGui")
			end

			-- Just group stuff to simplify things
			local replicationParent = playerGui:FindFirstChild("TemplateProviderReplication")
			if not replicationParent then
				replicationParent = Instance.new("Folder")
				replicationParent.Name = "TemplateProviderReplication"
				replicationParent.Archivable = false
				replicationParent.Parent = playerGui
			end

			local copy = self._tombstoneLookup[tombstoneId]:Clone()
			copy.Parent = playerGui

			task.delay(0.1, function()
				copy:Remove()
			end)

			return copy
		end))
	elseif self._replicationMode == TemplateReplicationModes.CLIENT then
		self._pendingTombstoneRequests = {}

		self._remoting = self._maid:Add(Remoting.Client.new(ReplicatedStorage, self.ServiceName .. "TemplateProvider"))
	end

	if self._initialTemplates then
		self._maid:GiveTask(self:AddTemplates(self._initialTemplates))
	end

	-- Recursively adds roots, but also de-duplicates them as necessary
	self._maid:GiveTask(self._containerRootCountingMap:ObserveKeysBrio():Subscribe(function(containerBrio)
		if containerBrio:IsDead() then
			return
		end

		local containerMaid, container = containerBrio:ToMaidAndValue()
		self:_handleContainer(containerMaid, container)
	end))
end

function TemplateProvider._handleContainer(self: TemplateProvider, containerMaid: Maid.Maid, container: Instance)
	if
		self._replicationMode == TemplateReplicationModes.SERVER
		and not container:IsA("Camera")
		and not container:FindFirstAncestorWhichIsA("Camera")
	then
		-- Prevent replication to client immediately

		local camera = containerMaid:Add(Instance.new("Camera"))
		camera.Name = "PreventReplication"
		camera.Parent = container

		local function handleChild(child)
			if child == camera then
				return
			end
			if child:GetAttribute(TOMBSTONE_ID_ATTRIBUTE) then
				return
			end

			child.Parent = camera
		end

		containerMaid:GiveTask(container.ChildAdded:Connect(handleChild))

		for _, child in container:GetChildren() do
			handleChild(child)
		end

		self:_replicateTombstones(containerMaid, camera, container)

		return
	end

	containerMaid:GiveTask(RxInstanceUtils.observeChildrenBrio(container):Subscribe(function(brio)
		if brio:IsDead() then
			return
		end

		local maid, child = brio:ToMaidAndValue()
		self:_addInstanceTemplate(maid, child)
	end))
end

function TemplateProvider._replicateTombstones(
	self: TemplateProvider,
	topMaid: Maid.Maid,
	unreplicatedParent,
	replicatedParent
)
	assert(self._replicationMode == TemplateReplicationModes.SERVER, "Only should be invoked on server")

	-- Tombstone each child so the client knows what is replicated
	topMaid:GiveTask(RxInstanceUtils.observeChildrenBrio(unreplicatedParent):Subscribe(function(brio)
		if brio:IsDead() then
			return
		end

		local maid, child = brio:ToMaidAndValue()
		self:_addInstanceTemplate(maid, child)

		local tombstoneId = HttpService:GenerateGUID(false)

		-- Tell the client something exists here
		local tombstone = maid:Add(Instance.new("Folder"))
		tombstone.Name = child.Name .. TOMBSTONE_NAME_POSTFIX_UNLOADED
		tombstone:SetAttribute(TOMBSTONE_ID_ATTRIBUTE, tombstoneId)

		-- Recursively replicate other tombstones
		if self:_shouldAddChildrenAsTemplates(child) then
			self:_replicateTombstones(maid, child, tombstone)
		end

		self._tombstoneLookup[tombstoneId] = child

		maid:GiveTask(function()
			self._tombstoneLookup[tombstoneId] = nil
		end)

		tombstone.Parent = replicatedParent
	end))
end

--[=[
	Observes the given template by name

	@param templateName string
	@return Observable<Instance>
]=]
function TemplateProvider.ObserveTemplate(self: TemplateProvider, templateName: string): Observable.Observable<Instance>
	assert(type(templateName) == "string", "Bad templateName")

	return self._templateMapList:ObserveList(templateName):Pipe({
		Rx.switchMap(function(list)
			if not list then
				return Rx.of(nil)
			end

			return list:ObserveAtIndex(-1)
		end),
	})
end

function TemplateProvider.ObserveTemplateNamesBrio(self: TemplateProvider): Observable.Observable<Brio.Brio<string>>
	return self._templateMapList:ObserveKeysBrio()
end

function TemplateProvider.ObserveUnreplicatedTemplateNamesBrio(
	self: TemplateProvider
): Observable.Observable<Brio.Brio<string>>
	return self._unreplicatedTemplateMapList:ObserveKeysBrio()
end

--[=[
	Returns the raw template

	@param templateName string
	@return Instance?
]=]
function TemplateProvider.GetTemplate(self: TemplateProvider, templateName: string): Instance?
	assert(type(templateName) == "string", "Bad templateName")

	return self._templateMapList:GetItemForKeyAtIndex(templateName, -1)
end

--[=[
	Promises to clone the template as soon as it exists

	@param templateName string
	@return Promise<Instance>
]=]
function TemplateProvider.PromiseCloneTemplate(self: TemplateProvider, templateName: string): Promise.Promise<Instance>
	assert(type(templateName) == "string", "Bad templateName")

	return self:PromiseTemplate(templateName):Then(function(template)
		return self:_cloneTemplate(template)
	end)
end

--[=[
	Promise to resolve the raw template as soon as it exists

	@param templateName string
	@return Promise<Instance>
]=]
function TemplateProvider.PromiseTemplate(self: TemplateProvider, templateName: string): Promise.Promise<Instance>
	assert(type(templateName) == "string", "Bad templateName")

	local foundTemplate = self._templateMapList:GetItemForKeyAtIndex(templateName, -1)
	if foundTemplate then
		return Promise.resolved(foundTemplate)
	end

	if self._pendingTemplatePromises[templateName] then
		return self._pendingTemplatePromises[templateName]
	end

	local promiseTemplate = Promise.new()

	-- Observe thet template
	PromiseMaidUtils.whilePromise(promiseTemplate, function(topMaid)
		topMaid:GiveTask(self:ObserveTemplate(templateName):Subscribe(function(template)
			if template then
				promiseTemplate:Resolve(template)
			end
		end))

		if self._replicationMode == TemplateReplicationModes.SERVER then
			-- There's a chance an external process will stream in our template

			topMaid:GiveTask(task.delay(5, function()
				warn(
					string.format(
						"[TemplateProvider.%s.PromiseTemplate] - Missing template %q",
						self.ServiceName,
						templateName
					)
				)
			end))
		elseif self._replicationMode == TemplateReplicationModes.CLIENT then
			-- Replicate from the unfound area
			topMaid:GiveTask(
				self._unreplicatedTemplateMapList:ObserveAtListIndexBrio(templateName, -1):Subscribe(function(brio)
					if brio:IsDead() then
						return
					end

					local maid, templateTombstone = brio:ToMaidAndValue()

					local originalName = templateTombstone.Name

					maid:GivePromise(self:_promiseReplicateTemplateFromTombstone(templateTombstone))
						:Then(function(template)
							-- Cache the template here which then loads it into the known templates naturally
							templateTombstone.Name = String.removePostfix(originalName, TOMBSTONE_NAME_POSTFIX_UNLOADED)
								.. TOMBSTONE_NAME_POSTFIX_LOADED
							template.Parent = templateTombstone

							promiseTemplate:Resolve(template)
						end)
				end)
			)

			topMaid:GiveTask(task.delay(5, function()
				if self._unreplicatedTemplateMapList:GetListForKey(templateName) then
					warn(
						string.format(
							"[TemplateProvider.%s.PromiseTemplate] - Failed to replicate template %q from server to client",
							self.ServiceName,
							templateName
						)
					)
				else
					warn(
						string.format(
							"[TemplateProvider.%s.PromiseTemplate] - Template %q is not a known template",
							self.ServiceName,
							templateName
						)
					)
				end
			end))
		elseif self._replicationMode == TemplateReplicationModes.SHARED then
			-- There's a chance an external process will stream in our template

			topMaid:GiveTask(task.delay(5, function()
				warn(
					string.format(
						"[TemplateProvider.%s.PromiseTemplate] - Missing template %q",
						self.ServiceName,
						templateName
					)
				)
			end))
		else
			error("Bad replicationMode")
		end
	end)

	self._maid[promiseTemplate] = promiseTemplate
	self._pendingTemplatePromises[templateName] = promiseTemplate

	promiseTemplate:Finally(function()
		self._maid[promiseTemplate] = nil
		self._pendingTemplatePromises[templateName] = nil
	end)

	return promiseTemplate
end

function TemplateProvider._promiseReplicateTemplateFromTombstone(
	self: TemplateProvider,
	templateTombstone: Instance
): Promise.Promise<Instance>
	assert(self._replicationMode == TemplateReplicationModes.CLIENT, "Bad replicationMode")
	assert(typeof(templateTombstone) == "Instance", "Bad templateTombstone")

	local tombstoneId = templateTombstone:GetAttribute(TOMBSTONE_ID_ATTRIBUTE)
	if type(tombstoneId) ~= "string" then
		return Promise.rejected("tombstoneId must be a string")
	end

	if self._pendingTombstoneRequests[tombstoneId] then
		return self._pendingTombstoneRequests[tombstoneId]
	end

	local promiseTemplate = Promise.new()

	PromiseMaidUtils.whilePromise(promiseTemplate, function(topMaid)
		topMaid
			:GivePromise(self._remoting.ReplicateTemplate:PromiseInvokeServer(tombstoneId))
			:Then(function(tempTemplate)
				if not tempTemplate then
					Promise.rejected("Failed to get any template")
					return
				end

				-- This tempTemplate will get destroyed by the server soon to free up server memory
				-- TODO: cache on client
				local copy = tempTemplate:Clone()
				promiseTemplate:Resolve(copy)
			end, function(...)
				promiseTemplate:Reject(...)
			end)
	end)

	self._maid[promiseTemplate] = promiseTemplate
	self._pendingTombstoneRequests[tombstoneId] = promiseTemplate

	promiseTemplate:Finally(function()
		self._maid[promiseTemplate] = nil
		self._pendingTombstoneRequests[tombstoneId] = nil
	end)

	return promiseTemplate
end

--[=[
	Clones the template.

	:::info
	If the template name has a prefix of "Template" then it will remove it on the cloned instance.
	:::

	@param templateName string
	@return Instance?
]=]
function TemplateProvider.CloneTemplate(self: TemplateProvider, templateName: string): Instance?
	assert(type(templateName) == "string", "Bad templateName")

	local template = self._templateMapList:GetItemForKeyAtIndex(templateName, -1)
	if not template then
		local unreplicated = self._unreplicatedTemplateMapList:GetListForKey(templateName)

		if unreplicated then
			error(
				string.format(
					"[TemplateProvider.%s.CloneTemplate] - Template %q is not replicated. Use PromiseCloneTemplate instead",
					self.ServiceName,
					tostring(templateName)
				)
			)
		else
			error(
				string.format(
					"[TemplateProvider.%s.CloneTemplate] - Cannot provide template %q",
					self.ServiceName,
					tostring(templateName)
				)
			)
		end
	end

	return self:_cloneTemplate(template)
end

--[=[
	Adds a new container to the provider for provision of assets. The initial container
	is considered a template. Additionally, we will include any children that are in a folder
	as a potential root

	:::tip
	The last template with a given name added will be considered the canonical template.
	:::

	@param container Template
	@return MaidTask
]=]
function TemplateProvider.AddTemplates(self: TemplateProvider, container: TemplateDeclaration): () -> ()
	assert(self:_isValidTemplateDeclaration(container), "Bad container")

	if typeof(container) == "Instance" then
		-- Always add this instance as we explicitly asked for it to be added as a root. This could be a
		-- module script, or other component.
		return self._containerRootCountingMap:Add(container)
	elseif Observable.isObservable(container) then
		local topMaid = Maid.new()

		self:_addObservableTemplates(topMaid, container)

		self._maid[topMaid] = topMaid
		topMaid:GiveTask(function()
			self._maid[topMaid] = nil
		end)

		return topMaid
	elseif type(container) == "table" then
		local topMaid = Maid.new()

		for _, value in container :: any do
			if typeof(value) == "Instance" then
				-- Always add these as we explicitly ask for this to be a root too.
				topMaid:GiveTask(self._containerRootCountingMap:Add(value))
			elseif Observable.isObservable(value) then
				self:_addObservableTemplates(topMaid, value)
			else
				error(
					string.format(
						"[TemplateProvider.%s] - Bad value of type %q in container table",
						self.ServiceName,
						typeof(value)
					)
				)
			end
		end

		self._maid[topMaid] = topMaid
		topMaid:GiveTask(function()
			self._maid[topMaid] = nil
		end)

		return function()
			self._maid[topMaid] = nil
		end
	else
		error(string.format("[TemplateProvider.%s] - Bad container of type %s", self.ServiceName, typeof(container)))
	end
end

function TemplateProvider._addObservableTemplates(self: TemplateProvider, topMaid: Maid.Maid, observable)
	topMaid:GiveTask(observable:Subscribe(function(result)
		if Brio.isBrio(result) then
			if result:IsDead() then
				return
			end

			local maid, template = result:ToMaidAndValue()
			if typeof(template) == "Instance" then
				self:_addInstanceTemplate(maid, template)
			else
				error("Cannot add non-instance from observable template")
			end
		else
			error("Cannot add non Brio<Instance> from observable")
		end
	end))
end

function TemplateProvider._addInstanceTemplate(self: TemplateProvider, topMaid: Maid.Maid, template: Instance)
	if self:_shouldAddChildrenAsTemplates(template) then
		topMaid:GiveTask(self._containerRootCountingMap:Add(template))
	end

	if template:GetAttribute(TOMBSTONE_ID_ATTRIBUTE) then
		topMaid:GiveTask(self._unreplicatedTemplateMapList:Push(
			RxInstanceUtils.observeProperty(template, "Name"):Pipe({
				Rx.map(function(name)
					if String.endsWith(name, TOMBSTONE_NAME_POSTFIX_UNLOADED) then
						return String.removePostfix(name, TOMBSTONE_NAME_POSTFIX_UNLOADED)
					elseif String.endsWith(name, TOMBSTONE_NAME_POSTFIX_LOADED) then
						return String.removePostfix(name, TOMBSTONE_NAME_POSTFIX_LOADED)
					else
						return name
					end
				end),
				Rx.distinct(),
			}),
			template
		))
	else
		topMaid:GiveTask(self._templateMapList:Push(RxInstanceUtils.observeProperty(template, "Name"), template))
	end
end

--[=[
	Returns whether or not a template is registered at the time

	@param templateName string
	@return boolean
]=]
function TemplateProvider.IsTemplateAvailable(self: TemplateProvider, templateName: string)
	assert(type(templateName) == "string", "Bad templateName")

	return self._templateMapList:GetItemForKeyAtIndex(templateName, -1) ~= nil
end

--[=[
	Returns all current registered items.

	@return { Instance }
]=]
function TemplateProvider.GetTemplateList(self: TemplateProvider): { Instance }
	return self._templateMapList:GetListOfValuesAtListIndex(-1)
end

--[=[
	Gets all current the containers.

	@return { Instance }
]=]
function TemplateProvider.GetContainerList(self: TemplateProvider): { Instance }
	return self._containerRootCountingMap:GetKeyList()
end

function TemplateProvider._cloneTemplate(_self: TemplateProvider, template: Instance): Instance
	local newItem = template:Clone()
	newItem.Name = String.removePostfix(template.Name, "Template")
	return newItem
end

function TemplateProvider._shouldAddChildrenAsTemplates(_self: TemplateProvider, container: Instance): boolean
	return container:IsA("Folder")
end

function TemplateProvider._isValidTemplateDeclaration(_self: TemplateProvider, container: TemplateDeclaration): boolean
	return typeof(container) == "Instance" or Observable.isObservable(container) or type(container) == "table"
end

-- Backwards compatibility
TemplateProvider.IsAvailable = assert(TemplateProvider.IsTemplateAvailable, "Missing method")
TemplateProvider.Get = assert(TemplateProvider.GetTemplate, "Missing method")
TemplateProvider.Clone = assert(TemplateProvider.CloneTemplate, "Missing method")
TemplateProvider.PromiseClone = assert(TemplateProvider.PromiseCloneTemplate, "Missing method")
TemplateProvider.GetAllTemplates = assert(TemplateProvider.GetTemplateList, "Missing method")
TemplateProvider.GetAll = assert(TemplateProvider.GetTemplateList, "Missing method")

--[=[
	Cleans up the provider
]=]
function TemplateProvider.Destroy(self: TemplateProvider)
	self._maid:DoCleaning()
end

return TemplateProvider
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="281">
            <Properties>
              <string name="Name">throttle</string>
            </Properties>
            <Item class="Folder" referent="282">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="283">
                <Properties>
                  <string name="Name">ThrottledFunction</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Throttles execution of a functon. Does both leading, and following
	@class ThrottledFunction
]=]

export type ThrottleConfig = {
	leading: boolean?,
	trailing: boolean?,
	leadingFirstTimeOnly: boolean?,
}

local ThrottledFunction = {}
ThrottledFunction.ClassName = "ThrottledFunction"
ThrottledFunction.__index = ThrottledFunction

export type Func<T...> = (T...) -> ...any

export type ThrottledFunction<T...> = typeof(setmetatable(
	{} :: {
		_nextCallTimeStamp: number,
		_timeout: number,
		_func: Func<T...>,
		_trailingValue: any,
		_callLeading: boolean,
		_callTrailing: boolean,
		_callLeadingFirstTime: boolean?,
	},
	{} :: typeof({ __index = ThrottledFunction })
))

function ThrottledFunction.new<T...>(
	timeoutInSeconds: number,
	func: Func<T...>,
	config: ThrottleConfig
): ThrottledFunction<T...>
	local self: ThrottledFunction<T...> = setmetatable({} :: any, ThrottledFunction)

	self._nextCallTimeStamp = 0
	self._timeout = timeoutInSeconds or error("No timeoutInSeconds")
	self._func = func or error("No func")

	self._trailingValue = nil

	self._callLeading = true
	self._callTrailing = true

	self:_configureOrError(config)

	return self
end

function ThrottledFunction.Call<T...>(self: ThrottledFunction<T...>, ...: T...)
	if self._trailingValue then
		-- Update the next value to be dispatched
		self._trailingValue = table.pack(...)
	elseif self._nextCallTimeStamp <= tick() then
		if self._callLeading or self._callLeadingFirstTime then
			self._callLeadingFirstTime = false
			-- Dispatch immediately
			self._nextCallTimeStamp = tick() + self._timeout
			self._func(...)
		elseif self._callTrailing then
			-- Schedule for trailing at exactly timeout
			self._trailingValue = table.pack(...)
			task.delay(self._timeout, function()
				if self.Destroy then
					self:_dispatch()
				end
			end)
		else
			error("[ThrottledFunction.Cleanup] - Trailing and leading are both disabled")
		end
	elseif self._callLeading or self._callTrailing or self._callLeadingFirstTime then
		self._callLeadingFirstTime = false
		-- As long as either leading or trailing are set to true, we are good
		local remainingTime = self._nextCallTimeStamp - tick()
		self._trailingValue = table.pack(...)

		task.delay(remainingTime, function()
			if self.Destroy then
				self:_dispatch()
			end
		end)
	end
end

ThrottledFunction.__call = ThrottledFunction.Call

function ThrottledFunction._dispatch<T...>(self: ThrottledFunction<T...>)
	self._nextCallTimeStamp = tick() + self._timeout

	local trailingValue = self._trailingValue
	if trailingValue then
		-- Clear before call so we are in valid state!
		self._trailingValue = nil
		self._func(unpack(trailingValue, 1, trailingValue.n))
	end
end

function ThrottledFunction._configureOrError<T...>(self: ThrottledFunction<T...>, throttleConfig: ThrottleConfig)
	if throttleConfig == nil then
		return
	end

	assert(type(throttleConfig) == "table", "Bad throttleConfig")

	for key, value in throttleConfig do
		assert(type(value) == "boolean", "Bad throttleConfig entry")

		if key == "leading" then
			self._callLeading = value
		elseif key == "trailing" then
			self._callTrailing = value
		elseif key == "leadingFirstTimeOnly" then
			self._callLeadingFirstTime = value
		else
			error(string.format("Bad key %q in config", tostring(key)))
		end
	end

	assert(self._callLeading or self._callTrailing, "Cannot configure both leading and trailing disabled")
end

function ThrottledFunction.Destroy<T...>(self: ThrottledFunction<T...>)
	local private: any = self
	private._trailingValue = nil
	private._func = nil
	setmetatable(private, nil)
end

return ThrottledFunction
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="284">
                <Properties>
                  <string name="Name">throttle</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Debounce a existing function by timeout

	@class throttle
]=]

local require = require(script.Parent.loader).load(script)

local ThrottledFunction = require("ThrottledFunction")
local TypeUtils = require("TypeUtils")

export type ThrottleConfig = ThrottledFunction.ThrottleConfig

--[=[
	Provides a debounce function call on an operation.

	@function throttle
	@within throttle
	@param timeoutInSeconds number
	@param func function
	@param throttleConfig? { leading = true; trailing = true; }
	@return function
]=]
local function throttle<T...>(
	timeoutInSeconds: number,
	func: ThrottledFunction.Func<T...>,
	throttleConfig: ThrottledFunction.ThrottleConfig
): (T...) -> ()
	assert(type(timeoutInSeconds) == "number", "timeoutInSeconds is not a number")
	assert(type(func) == "function", "func is not a function")

	local throttled = ThrottledFunction.new(timeoutInSeconds, func, throttleConfig)

	return function(...: T...)
		throttled:Call(TypeUtils.anyValue(...))
	end
end

return throttle
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="285">
            <Properties>
              <string name="Name">typeutils</string>
            </Properties>
            <Item class="Folder" referent="286">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="287">
                <Properties>
                  <string name="Name">TypeUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class TypeUtils
]=]

local TypeUtils = {}

--[=[
	Type checking hack to convert a typed variable argument parameter to a type of any
	@param ... any
]=]
function TypeUtils.anyValue(...): ...any
	return ...
end

return TypeUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="288">
            <Properties>
              <string name="Name">valuebaseutils</string>
            </Properties>
            <Item class="Folder" referent="289">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="290">
                <Properties>
                  <string name="Name">RxValueBaseUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class RxValueBaseUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Observable = require("Observable")
local Rx = require("Rx")
local RxBrioUtils = require("RxBrioUtils")
local RxInstanceUtils = require("RxInstanceUtils")

local RxValueBaseUtils = {}

--[=[
	Observes a value base underneath a parent (last named child).

	@param parent Instance
	@param className string
	@param name string
	@param predicate callback -- Optional callback
	@return Observable<Brio<any>>
]=]
function RxValueBaseUtils.observeBrio(
	parent: Instance,
	className: string,
	name: string,
	predicate: Rx.Predicate<any>?
): Observable.Observable<Brio.Brio<any>>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")
	assert(type(name) == "string", "Bad naem")

	return RxInstanceUtils.observeLastNamedChildBrio(parent, className, name):Pipe({
		RxBrioUtils.switchMapBrio(RxValueBaseUtils.observeValue) :: any,
		RxBrioUtils.onlyLastBrioSurvives() :: any,
		if predicate then RxBrioUtils.where(predicate) :: any else nil :: never,
	}) :: any
end

--[=[
	Observes a value base underneath a parent

	@param parent Instance
	@param className string
	@param name string
	@param defaultValue any
	@return Observable<any>
]=]
function RxValueBaseUtils.observe(
	parent: Instance,
	className: string,
	name: string,
	defaultValue: any?
): Observable.Observable<any>
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")
	assert(type(name) == "string", "Bad name")

	return RxValueBaseUtils.observeBrio(parent, className, name):Pipe({
		RxBrioUtils.emitOnDeath(defaultValue) :: any,
	}) :: any
end

--[=[
	Observables a given value object's value
	@param valueObject Instance
	@return Observable<T>
]=]
function RxValueBaseUtils.observeValue(valueObject: ValueBase): Observable.Observable<any>
	assert(typeof(valueObject) == "Instance", "Bad valueObject")

	return RxInstanceUtils.observeProperty(valueObject, "Value")
end

return RxValueBaseUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="291">
                <Properties>
                  <string name="Name">ValueBaseUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Provides utilities for working with ValueBase objects, like [IntValue] or [ObjectValue] in Roblox.

	@class ValueBaseUtils
]=]

local ValueBaseUtils = {}

local TYPE_TO_CLASSNAME_LOOKUP = {
	["nil"] = "ObjectValue",
	boolean = "BoolValue",
	number = "NumberValue",
	string = "StringValue",

	BrickColor = "BrickColorValue",
	CFrame = "CFrameValue",
	Color3 = "Color3Value",
	Instance = "ObjectValue",
	Ray = "RayValue",
	Vector3 = "Vector3Value",
}

local VALUE_BASE_TYPE_LOOKUP = {
	BoolValue = "boolean",
	NumberValue = "number",
	IntValue = "number",
	StringValue = "string",
	BrickColorValue = "BrickColor",
	CFrameValue = "CFrame",
	Color3Value = "Color3",
	ObjectValue = "Instance",
	RayValue = "Ray",
	Vector3Value = "Vector3",
}

export type ValueBaseType =
	"BoolValue"
	| "NumberValue"
	| "IntValue"
	| "StringValue"
	| "BrickColorValue"
	| "CFrameValue"
	| "Color3Value"
	| "ObjectValue"
	| "RayValue"
	| "Vector3Value"

--[=[
	Returns true if the value is a ValueBase instance

	@param instance Instance
	@return boolean
]=]
function ValueBaseUtils.isValueBase(instance: Instance): boolean
	return typeof(instance) == "Instance" and instance:IsA("ValueBase")
end

--[=[
	Gets the lua type for the given class name

	@param valueBaseClassName string
	@return string?
]=]
function ValueBaseUtils.getValueBaseType(valueBaseClassName: ValueBaseType): string?
	return VALUE_BASE_TYPE_LOOKUP[valueBaseClassName]
end

--[=[
	Gets class type for the given lua type

	@param luaType string
	@return string?
]=]
function ValueBaseUtils.getClassNameFromType(luaType: string): string?
	return TYPE_TO_CLASSNAME_LOOKUP[luaType]
end

--[=[
	Initializes the value as needed

	@param parent Instance
	@param instanceType string
	@param name string
	@param defaultValue any?
	@return Instance
]=]
function ValueBaseUtils.getOrCreateValue(
	parent: Instance,
	instanceType: ValueBaseType,
	name: string,
	defaultValue
): Instance
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(
				string.format(
					"[ValueBaseUtils.getOrCreateValue] - Value of type %q of name %q is of type %q in %s instead",
					instanceType,
					name,
					foundChild.ClassName,
					foundChild:GetFullName()
				)
			)
		end

		return foundChild
	else
		local newChild: any = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = defaultValue
		newChild.Parent = parent

		return newChild
	end
end

--[=[
	Sets the value for the parent

	@param parent Instance
	@param instanceType string
	@param name string
	@param value any
	@return any
]=]
function ValueBaseUtils.setValue(parent: Instance, instanceType: ValueBaseType, name: string, value: any)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(
				string.format(
					"[ValueBaseUtils.setValue] - Value of type %q of name %q is of type %q in %s instead",
					instanceType,
					name,
					foundChild.ClassName,
					foundChild:GetFullName()
				)
			)
		end

		(foundChild :: any).Value = value
	else
		local newChild: any = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = value
		newChild.Parent = parent
	end
end

--[=[
	Gets the value in the children

	@param parent Instance
	@param instanceType string
	@param name string
	@param default any?
	@return any
]=]
function ValueBaseUtils.getValue(parent: Instance, instanceType: ValueBaseType, name: string, default: any?)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if foundChild:IsA(instanceType) then
			return (foundChild :: any).Value
		else
			warn(
				string.format(
					"[ValueBaseUtils.getValue] - Value of type %q of name %q is of type %q in %s instead",
					instanceType,
					name,
					foundChild.ClassName,
					foundChild:GetFullName()
				)
			)
			return nil
		end
	else
		return default
	end
end

--[=[
	Gets a getter, setter, and initializer for the instance type and name.

	@param instanceType string
	@param name string
	@return function
	@return function
	@return function
]=]
function ValueBaseUtils.createGetSet(instanceType: ValueBaseType, name: string)
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	return function(parent, defaultValue)
		assert(typeof(parent) == "Instance", "Bad argument 'parent'")

		return ValueBaseUtils.getValue(parent, instanceType, name, defaultValue)
	end, function(parent, value)
		assert(typeof(parent) == "Instance", "Bad argument 'parent'")

		return ValueBaseUtils.setValue(parent, instanceType, name, value)
	end, function(parent, defaultValue)
		return ValueBaseUtils.getOrCreateValue(parent, instanceType, name, defaultValue)
	end
end

return ValueBaseUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="292">
                <Properties>
                  <string name="Name">ValueBaseValue</string>
                  <string name="Source"><![CDATA[--[=[
	For when attributes don't work

	@class ValueBaseValue
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local Brio = require("Brio")
local Observable = require("Observable")
local Rx = require("Rx")
local RxSignal = require("RxSignal")
local RxValueBaseUtils = require("RxValueBaseUtils")
local ValueBaseUtils = require("ValueBaseUtils")

local ValueBaseValue = {}
ValueBaseValue.ClassName = "ValueBaseValue"
ValueBaseValue.__index = ValueBaseValue

export type ValueBaseValue = typeof(setmetatable(
	{} :: {
		_parent: Instance,
		_className: ValueBaseUtils.ValueBaseType,
		_name: string,
		_defaultValue: any?,
		Value: any?,
		Changed: RxSignal.RxSignal<any>,
	},
	{} :: typeof({ __index = ValueBaseValue })
))

--[=[
	Constructs a ValueBaseValue object. This is a wrapper around the value base
	underneath the parent. It will create the value base if it does not exist.

	@param parent Instance
	@param className string
	@param name string
	@param defaultValue any?
	@return ValueBaseValue
]=]
function ValueBaseValue.new(
	parent: Instance,
	className: ValueBaseUtils.ValueBaseType,
	name: string,
	defaultValue: any?
): ValueBaseValue
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(className) == "string", "Bad argument 'className'")
	assert(type(name) == "string", "Bad argument 'name'")

	local self = {}

	self._parent = parent
	self._name = name
	self._className = className
	self._defaultValue = defaultValue

	-- Initialize on the server
	if RunService:IsServer() then
		ValueBaseUtils.getOrCreateValue(parent, self._className, self._name, self._defaultValue)
	end

	return setmetatable(self, ValueBaseValue) :: any
end

--[=[
	Observes the value base value. This will return a brio of the value base
	underneath the parent.

	@param predicate ((any) -> boolean)? -- Optional callback
	@return Observable<Brio<any>>
]=]
function ValueBaseValue.ObserveBrio(
	self: ValueBaseValue,
	predicate: Rx.Predicate<any>?
): Observable.Observable<Brio.Brio<any>>
	return RxValueBaseUtils.observeBrio(self._parent, self._className, self._name, predicate)
end

--[=[
	Observes the value base value's

	@return Observable<any>
]=]
function ValueBaseValue.Observe(self: ValueBaseValue): Observable.Observable<any>
	return RxValueBaseUtils.observe(self._parent, self._className, self._name, self._defaultValue)
end

(ValueBaseValue :: any).__index = function(self: any, index)
	if index == "Value" then
		return ValueBaseUtils.getValue(self._parent, self._className, self._name, self._defaultValue)
	elseif index == "Changed" then
		return RxSignal.new(self:Observe():Pipe({
			Rx.skip(1),
		}))
	elseif ValueBaseValue[index] or index == "_defaultValue" then
		return ValueBaseValue[index]
	else
		error(string.format("%q is not a member of ValueBaseValue", tostring(index)))
	end
end

function ValueBaseValue.__newindex(self: ValueBaseValue, index, value)
	if index == "Value" then
		ValueBaseUtils.setValue(self._parent, self._className, self._name, value)
	else
		error(string.format("%q is not a member of ValueBaseValue", tostring(index)))
	end
end

return ValueBaseValue
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="293">
            <Properties>
              <string name="Name">valueobject</string>
            </Properties>
            <Item class="Folder" referent="294">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="295">
                <Properties>
                  <string name="Name">ValueObject</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	To work like value objects in Roblox and track a single item,
	with `.Changed` events
	@class ValueObject
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local DuckTypeUtils = require("DuckTypeUtils")
local Maid = require("Maid")
local MaidTaskUtils = require("MaidTaskUtils")
local Observable = require("Observable")
local Rx = require("Rx")
local RxValueBaseUtils = require("RxValueBaseUtils")
local Signal = require("Signal")
local Subscription = require("Subscription")
local ValueBaseUtils = require("ValueBaseUtils")

local EMPTY_FUNCTION = function() end

local ValueObject = {}
ValueObject.ClassName = "ValueObject"

export type TypeChecker = (value: any) -> (boolean, string?)

export type ValueObjectTypeArg = string | TypeChecker

export type Mountable<T> = T | Observable.Observable<T> | ValueBase | ValueObject<T>

export type ValueObject<T> = typeof(setmetatable(
	{} :: {
		--[=[
			The value of the ValueObject
			@prop Value T
			@within ValueObject
		]=]
		Value: T,

		--[=[
			Event fires when the value's object value change
			@prop Changed Signal<T> -- fires with oldValue, newValue, ...
			@within ValueObject
		]=]
		Changed: Signal.Signal<(T, T, ...any)>,
		LastEventContext: { any },

		_checkType: ValueObjectTypeArg?,
		_value: T,
		_default: T?,
		_lastEventContext: { any }?,
		_lastMountedSub: Subscription.Subscription<(T, ...any)>?,
	},
	{} :: typeof({ __index = ValueObject })
))

--[=[
	Constructs a new value object
	@param baseValue T
	@param checkType string? | (value: T) -> (boolean, string?)
	@return ValueObject
]=]
function ValueObject.new<T>(baseValue: T?, checkType: ValueObjectTypeArg?): ValueObject<T>
	local self: ValueObject<T> = setmetatable(
		{
			_value = baseValue,
			_default = baseValue,
			_checkType = checkType,
		} :: any,
		ValueObject
	)

	if type(checkType) == "string" then
		if typeof(baseValue) ~= checkType then
			error(string.format("Expected value of type %q, got %q instead", checkType, typeof(baseValue)))
		end
	elseif type(checkType) == "function" then
		assert(checkType(baseValue))
	end

	return self
end

--[=[
	Returns the current check type, if any

	@return string? | (value: T) -> (boolean, string)
]=]
function ValueObject.GetCheckType<T>(self: ValueObject<T>): ValueObjectTypeArg?
	return rawget(self :: any, "_checkType")
end

--[=[
	Constructs a new value object
	@param observable Observable<T>
	@return ValueObject<T>
]=]
function ValueObject.fromObservable<T>(observable: Observable.Observable<T>): ValueObject<T>
	local result = ValueObject.new()

	result:Mount(observable)

	return result
end

--[=[
	Returns whether the object is a ValueObject class
	@param value any
	@return boolean
]=]
function ValueObject.isValueObject(value: any): boolean
	return DuckTypeUtils.isImplementation(ValueObject, value)
end

function ValueObject._toMountableObservable<T>(_self: ValueObject<T>, value: Mountable<T>)
	if Observable.isObservable(value) then
		return value
	elseif typeof(value) == "Instance" then
		-- IntValue, ObjectValue, et cetera
		if ValueBaseUtils.isValueBase(value) then
			return RxValueBaseUtils.observeValue(value)
		end
	elseif type(value) == "table" then
		if ValueObject.isValueObject(value) then
			return (value :: any):Observe()
			-- elseif Promise.isPromise(value) then
			-- 	return Rx.fromPromise(value)
		end
	end

	return nil
end

--[=[
	Mounts the value to the observable. Overrides the last mount.

	@param value Observable | T
	@return MaidTask
]=]
function ValueObject.Mount<T>(self: ValueObject<T>, value: Mountable<T>): () -> ()
	local observable = self:_toMountableObservable(value)
	if observable then
		self:_cleanupLastMountedSub()

		local sub = observable:Subscribe(function(...)
			ValueObject._applyValue(self, ...)
		end)

		rawset(self :: any, "_lastMountedSub", sub)

		return function()
			if rawget(self :: any, "_lastMountedSub") == sub then
				self:_cleanupLastMountedSub()
			end
		end
	else
		self:_cleanupLastMountedSub()

		ValueObject._applyValue(self, value :: T)

		return EMPTY_FUNCTION
	end
end

function ValueObject._cleanupLastMountedSub<T>(self: ValueObject<T>)
	local lastSub = rawget(self :: any, "_lastMountedSub")
	if lastSub then
		rawset(self :: any, "_lastMountedSub", nil)
		MaidTaskUtils.doTask(lastSub)
	end
end

--[=[
	Observes the current value of the ValueObject
	@return Observable<T?>
]=]
function ValueObject.Observe<T>(self: ValueObject<T>): Observable.Observable<T>
	local found = rawget(self :: any, "_observable")
	if found then
		return found
	end

	local created = Observable.new(function(sub)
		if not self.Destroy then
			warn("[ValueObject.observeValue] - Connecting to dead ValueObject")
			-- No firing, we're dead
			sub:Complete()
			return
		end

		local connection = self.Changed:Connect(function(newValue, _, ...)
			sub:Fire(newValue, ...)
		end)

		local args = rawget(self :: any, "_lastEventContext")
		local value = rawget(self :: any, "_value")
		if args then
			sub:Fire(value, table.unpack(args, 1, args.n))
		else
			sub:Fire(value)
		end

		return connection
	end)

	-- We use a lot of these so let's cache the result which reduces the number of tables we have here
	rawset(self :: any, "_observable", created)
	return created :: any
end

--[=[
	Observes the value as a brio. The condition defaults to truthy or nil.

	@param condition function | nil -- optional
	@return Observable<Brio<T>>
]=]
function ValueObject.ObserveBrio<T>(self: ValueObject<T>, condition: Rx.Predicate<T>?): Observable.Observable<Brio.Brio<T>>
	assert(type(condition) == "function" or condition == nil, "Bad condition")

	return Observable.new(function(sub)
		if not self.Destroy then
			warn("[ValueObject.observeValue] - Connecting to dead ValueObject")
			-- No firing, we're dead
			sub:Complete()
			return
		end

		local maid = Maid.new()

		local function handleNewValue(newValue: T, ...)
			if not condition or condition(newValue) then
				local brio = Brio.new(newValue, ...)
				maid._current = brio
				sub:Fire(brio)
			else
				maid._current = nil
			end
		end

		maid:GiveTask(self.Changed:Connect(function(newValue, _previous, ...)
			handleNewValue(newValue, ...)
		end))

		local args = rawget(self :: any, "_lastEventContext")
		if args then
			handleNewValue(self.Value, table.unpack(args, 1, args.n))
		else
			handleNewValue(self.Value)
		end

		return maid
	end) :: any
end

--[=[
	Allows you to set a value, and provide additional event context for the actual change.
	For example, you might do.

	```lua
	self.IsVisible:SetValue(isVisible, true)

	print(self.IsVisible.Changed:Connect(function(isVisible, _, doNotAnimate)
		print(doNotAnimate)
	end))
	```

	@param value T
	@param ... any -- Additional args. Can be used to pass event changing state args with value
	@return () -> () -- Cleanup
]=]
function ValueObject.SetValue<T>(self: ValueObject<T>, value: T, ...)
	self:_cleanupLastMountedSub()

	ValueObject._applyValue(self, value, ...)

	return function()
		if rawget(self :: any, "_value") == value then
			ValueObject._applyValue(self, rawget(self :: any, "_default"))
		end
	end
end

function ValueObject._applyValue<T>(self: ValueObject<T>, value: T, ...)
	local previous = rawget(self :: any, "_value")
	local checkType = rawget(self :: any, "_checkType")

	if type(checkType) == "string" then
		if typeof(value) ~= checkType then
			error(string.format("Expected value of type %q, got %q instead", checkType, typeof(value)))
		end
	elseif typeof(checkType) == "function" then
		assert(checkType(value))
	end

	if previous ~= value then
		if select("#", ...) > 0 then
			rawset(self :: any, "_lastEventContext", table.pack(...))
		else
			rawset(self :: any, "_lastEventContext", nil)
		end

		rawset(self :: any, "_value", value)
		local changed = rawget(self :: any, "Changed")
		if changed then
			changed:Fire(value, previous, ...)
		end
	end
end

function ValueObject:__index(index)
	if ValueObject[index] then
		return ValueObject[index]
	elseif index == "Value" then
		return rawget(self :: any, "_value")
	elseif index == "Changed" then
		-- Defer construction of Changed event until something needs it, since a lot
		-- of times we don't need it

		local signal = Signal.new() -- :Fire(newValue, oldValue, ...)

		rawset(self :: any, "Changed", signal)

		return signal
	elseif index == "LastEventContext" then
		local args = rawget(self :: any, "_lastEventContext")
		if args then
			return table.unpack(args, 1, args.n)
		else
			return
		end
	elseif index == "_value" then
		return nil -- Edge case
	else
		error(string.format("%q is not a member of ValueObject", tostring(index)))
	end
end

function ValueObject:__newindex(index, value)
	if index == "Value" then
		-- Avoid deoptimization
		ValueObject._applyValue(self, value)
	elseif index == "LastEventContext" or ValueObject[index] then
		error(string.format("%q cannot be set in ValueObject", tostring(index)))
	else
		error(string.format("%q is not a member of ValueObject", tostring(index)))
	end
end

--[=[
	Forces the value to be nil on cleanup, cleans up the Maid

	Does not fire the event since 3.5.0
]=]
function ValueObject.Destroy<T>(self: ValueObject<T>)
	rawset(self :: any, "_value", nil)

	self:_cleanupLastMountedSub()

	-- Avoid using a maid here because we make a LOT of ValueObjects
	local changed = rawget(self :: any, "Changed")
	if changed then
		changed:Destroy()
	end

	setmetatable(self :: any, nil)
end

return ValueObject
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="296">
                <Properties>
                  <string name="Name">ValueObjectUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utils that work with Roblox Value objects (and also ValueObject)
	@class ValueObjectUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local ValueObject = require("ValueObject")

local ValueObjectUtils = {}

--[=[
	Syncs the value from `from` to `to`.
	@param from ValueObject<T>
	@param to ValueObject<T>
	@return MaidTask
]=]
function ValueObjectUtils.syncValue<T>(from: ValueObject.ValueObject<T>, to: ValueObject.ValueObject<T>): Maid.Maid
	local maid = Maid.new()
	to.Value = from.Value

	maid:GiveTask(from.Changed:Connect(function()
		to.Value = from.Value
	end))

	return maid
end

--[=[
	Observes the current value of the ValueObject

	@deprecated 13.18.0
	@param valueObject ValueObject<T>
	@return Observable<T>
]=]
function ValueObjectUtils.observeValue<T>(valueObject: ValueObject.ValueObject<T>): Observable.Observable<T>
	assert(ValueObject.isValueObject(valueObject), "Bad valueObject")

	return valueObject:Observe()
end

--[=[
	Observes the current value of the ValueObject
	@param valueObject ValueObject<T>
	@return Observable<Brio<T>>
]=]
function ValueObjectUtils.observeValueBrio<T>(valueObject: ValueObject.ValueObject<T>): Observable.Observable<Brio.Brio<T>>
	assert(valueObject, "Bad valueObject")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function refire()
			local brio = Brio.new(valueObject.Value)
			maid._lastBrio = brio
			sub:Fire(brio)
		end

		maid:GiveTask(valueObject.Changed:Connect(refire))

		refire()

		return maid
	end) :: any
end

return ValueObjectUtils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="297">
            <Properties>
              <string name="Name">vector3utils</string>
            </Properties>
            <Item class="Folder" referent="298">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="299">
                <Properties>
                  <string name="Name">RandomVector3Utils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utility functions involving RandomVector3Utils
	@class RandomVector3Utils
]=]

local RandomVector3Utils = {}

--[=[
	Equal distribution unit vectors around a sphere
	@return Vector3
]=]
function RandomVector3Utils.getRandomUnitVector(): Vector3
	local s = 2 * (math.random() - 0.5)
	local t = 6.2831853071796 * math.random()
	local rx = s
	local m = (1 - s * s) ^ 0.5
	local ry = m * math.cos(t)
	local rz = m * math.sin(t)
	return Vector3.new(rx, ry, rz)
end

local function gaussianRandom(): number
	return math.sqrt(-2 * math.log(1 - math.random())) * math.cos(2 * math.pi * math.random())
end

--[=[
	Computes a gaussian random vector3.

	@param mean Vector3 -- center
	@param spread Vector3 -- std deviation
	@return Vector3
]=]
function RandomVector3Utils.gaussianRandom(mean: Vector3, spread: Vector3): Vector3
	return mean + spread * Vector3.new(gaussianRandom(), gaussianRandom(), gaussianRandom()) / math.sqrt(3)
end

--[=[
	Gets a uniformally distributed random unit vector3 in the direction
	specified.

	@param direction Vector3
	@param angleRad number -- Angle in radians
	@return Vector3
]=]
function RandomVector3Utils.getDirectedRandomUnitVector(direction: Vector3, angleRad: number): Vector3
	assert(typeof(direction) == "Vector3", "Bad direction")
	assert(type(angleRad) == "number", "Bad angleRad")

	local s = 1 - (1 - math.cos(angleRad)) * math.random()
	local t = 6.2831853071796 * math.random()
	local rx = s
	local m = (1 - s * s) ^ 0.5
	local ry = m * math.cos(t)
	local rz = m * math.sin(t)

	local dx, dy, dz = direction.X, direction.Y, direction.Z
	local d = (dx * dx + dy * dy + dz * dz) ^ 0.5

	if dx / d < -0.9999 then
		return Vector3.new(-rx, ry, rz)
	elseif dx / d < 0.9999 then
		local coef1 = (rx - dx * (dy * ry + dz * rz) / (dy * dy + dz * dz)) / d
		local coef2 = (dz * ry - dy * rz) / (dy * dy + dz * dz)
		return Vector3.new((dx * rx + dy * ry + dz * rz) / d, dy * coef1 + dz * coef2, dz * coef1 - dy * coef2)
	else
		return Vector3.new(rx, ry, rz)
	end
end

return RandomVector3Utils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="300">
                <Properties>
                  <string name="Name">Vector3SerializationUtils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	@class Vector3SerializationUtils
]=]

local Vector3SerializationUtils = {}

export type SerializedVector3 = { number }

--[=[
	Returns true if this data is a serialized Vector3

	@param data any
	@return boolean
]=]
function Vector3SerializationUtils.isSerializedVector3(data: any): boolean
	return type(data) == "table" and #data == 3
end

--[=[
	Serialized a Vector3 into a Lua table, which should encode in JSON and be network safe.

	@param vector3 Vector3
	@return SerializedVector3
]=]
function Vector3SerializationUtils.serialize(vector3: Vector3): SerializedVector3
	return {
		vector3.X,
		vector3.Y,
		vector3.Z,
	}
end

--[=[
	Deserializes a Vector3 from a Lua table

	@param data SerializedVector3
	@return Vector3
]=]
function Vector3SerializationUtils.deserialize(data: SerializedVector3): Vector3
	assert(type(data) == "table", "Bad data")
	assert(#data == 3, "Bad data")

	return Vector3.new(data[1], data[2], data[3])
end

return Vector3SerializationUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="301">
                <Properties>
                  <string name="Name">Vector3Utils</string>
                  <string name="Source"><![CDATA[--!strict
--[=[
	Utilities involving Vector3 objects in Roblox.
	@class Vector3Utils
]=]

local require = require(script.Parent.loader).load(script)

local Math = require("Math")

local Vector3Utils = {}

--[=[
	Creates a Vector3 from a Vector2 in the XY plane

	@param vector2 Vector2
	@return Vector3
]=]
function Vector3Utils.fromVector2XY(vector2: Vector2): Vector3
	return Vector3.new(vector2.X, vector2.Y, 0)
end

--[=[
	Creates a Vector3 from a Vector2 in the XZ plane

	@param vector2 Vector2
	@return Vector3
]=]
function Vector3Utils.fromVector2XZ(vector2: Vector2): Vector3
	return Vector3.new(vector2.X, 0, vector2.Y)
end

--[=[
	Computes the angle between 2 vectors in radians

	@param a Vector3
	@param b Vector3
	@return number?
]=]
function Vector3Utils.getAngleRad(a: Vector3, b: Vector3): number?
	if a.Magnitude == 0 then
		return nil
	end

	return math.acos(a:Dot(b))
end

--[=[
	Reflects a vector over a unit normal

	@param vector Vector3
	@param unitNormal Vector3
	@return Vector3
]=]
function Vector3Utils.reflect(vector: Vector3, unitNormal: Vector3): Vector3
	return vector - 2 * (unitNormal * vector:Dot(unitNormal))
end

--[=[
	Computes the angle between 2 vectors in radians

	@param a Vector3
	@param b Vector3
	@return number
]=]
function Vector3Utils.angleBetweenVectors(a: Vector3, b: Vector3): number
	local u = b.Magnitude * a
	local v = a.Magnitude * b
	return 2 * math.atan2((v - u).Magnitude, (u + v).Magnitude)
end

--[=[
	Spherically lerps between start and finish

	@param start Vector3
	@param finish Vector3
	@param t number -- Amount to slerp. 0 is start, 1 is finish. beyond that is extended as expected.
	@return Vector3
]=]
function Vector3Utils.slerp(start: Vector3, finish: Vector3, t: number): Vector3
	local dot = math.clamp(start:Dot(finish), -1, 1)

	local theta = math.acos(dot) * t
	local relVec = (finish - start * dot).Unit
	return ((start * math.cos(theta)) + (relVec * math.sin(theta)))
end

--[=[
	Constrains a Vector3 into a cone.

	@param direction Vector3 -- The vector direction to constrain
	@param coneDirection Vector3 -- The direction of the cone.
	@param coneAngleRad -- Angle of the cone
	@return Vector3 -- Constrained angle
]=]
function Vector3Utils.constrainToCone(direction: Vector3, coneDirection: Vector3, coneAngleRad: number): Vector3
	local angle = Vector3Utils.angleBetweenVectors(direction, coneDirection)
	local coneHalfAngle = 0.5 * coneAngleRad

	if angle > coneHalfAngle then
		local proportion = coneHalfAngle / angle
		return Vector3Utils.slerp(coneDirection.Unit, direction.Unit, proportion) * direction.Magnitude
	end

	return direction
end

--[=[
	Rounds the vector to the nearest number

	```lua
	-- Snaps to a grid!
	local snapped = Vector3Utils.round(position, 4)
	```

	@param vector3 Vector3
	@param amount number
	@return Vector3
]=]
function Vector3Utils.round(vector3: Vector3, amount: number): Vector3
	return Vector3.new(Math.round(vector3.X, amount), Math.round(vector3.Y, amount), Math.round(vector3.Z, amount))
end

--[=[
	Checks if 2 Vector3 values are clsoe to each other

	@param a Vector3
	@param b Vector3
	@param epsilon number
	@return boolean
]=]
function Vector3Utils.areClose(a: Vector3, b: Vector3, epsilon: number): boolean
	assert(type(epsilon) == "number", "Bad epsilon")

	return math.abs(a.X - b.X) <= epsilon and math.abs(a.Y - b.Y) <= epsilon and math.abs(a.Z - b.Z) <= epsilon
end

return Vector3Utils
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="302">
          <Properties>
            <string name="Name">@quentystudios</string>
          </Properties>
          <Item class="ModuleScript" referent="303">
            <Properties>
              <string name="Name">Cmdr</string>
              <string name="Source">local RunService = game:GetService("RunService")
local Util = require(script.Shared:WaitForChild("Util"))

if RunService:IsServer() == false then
	error("Cmdr server module is somehow running on a client!")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = nil;
		RemoteFunction = nil;
		RemoteEvent = nil;
		Util = Util;
		DefaultCommandsFolder = script.BuiltInCommands;
	}, {
		__index = function (self, k)
			local r = self.Registry[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Registry, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(script.Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(script.Shared.Dispatcher)(Cmdr)

	require(script.Initialize)(Cmdr)
end

-- Handle command invocations from the clients.
Cmdr.RemoteFunction.OnServerInvoke = function (player, text, options)
	if #text &gt; 100_000 then
		return "Input too long"
	end

	return Cmdr.Dispatcher:EvaluateAndRun(text, player, options)
end

return Cmdr</string>
            </Properties>
            <Item class="Folder" referent="304">
              <Properties>
                <string name="Name">BuiltInCommands</string>
              </Properties>
              <Item class="Folder" referent="305">
                <Properties>
                  <string name="Name">Admin</string>
                </Properties>
                <Item class="ModuleScript" referent="306">
                  <Properties>
                    <string name="Name">announce</string>
                    <string name="Source">return {
	Name = "announce";
	Aliases = {"m"};
	Description = "Makes a server-wide announcement.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "string";
			Name = "text";
			Description = "The announcement text.";
		},
	};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="307">
                  <Properties>
                    <string name="Name">announceServer</string>
                    <string name="Source">local TextService = game:GetService("TextService")
local Players = game:GetService("Players")
local Chat = game:GetService("Chat")

return function (context, text)
	local filterResult = TextService:FilterStringAsync(text, context.Executor.UserId, Enum.TextFilterContext.PublicChat)

	for _, player in ipairs(Players:GetPlayers()) do
		if Chat:CanUsersChatAsync(context.Executor.UserId, player.UserId) then
			context:SendEvent(player, "Message", filterResult:GetChatForUserAsync(player.UserId), context.Executor)
		end
	end

	return "Created announcement."
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="308">
                  <Properties>
                    <string name="Name">gotoPlace</string>
                    <string name="Source">return {
	Name = "goto-place";
	Aliases = {};
	Description = "Teleport to a Roblox place";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"follow-player|Join a player in another server\" goto-place $1{players|Players} ${{get-player-place-instance $2{playerId|Target}}}",
		"alias \"rejoin|Rejoin this place. You might end up in a different server.\" goto-place $1{players|Players} ${get-player-place-instance ${me} PlaceId}"
	};
	Args = {
		{
			Type = "players";
			Name = "Players";
			Description = "The players you want to teleport";
		},
		{
			Type = "positiveInteger";
			Name = "Place ID";
			Description = "The Place ID you want to teleport to";
		},
		{
			Type = "string";
			Name = "JobId";
			Description = "The specific JobId you want to teleport to";
			Optional = true;
		}
	};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="309">
                  <Properties>
                    <string name="Name">gotoPlaceServer</string>
                    <string name="Source"><![CDATA[local TeleportService = game:GetService("TeleportService")

return function(context, players, placeId, jobId)
	players = players or { context.Executor }

	if placeId <= 0 then
		return "Invalid place ID"
	elseif jobId == "-" then
		return "Invalid job ID"
	end

	context:Reply("Commencing teleport...")

	if jobId then
		for _, player in ipairs(players) do
			TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
		end
	else
		TeleportService:TeleportAsync(placeId, players)
	end

	return "Teleported."
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="310">
                  <Properties>
                    <string name="Name">kick</string>
                    <string name="Source">return {
	Name = "kick";
	Aliases = {"boot"};
	Description = "Kicks a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "players";
			Description = "The players to kick.";
		},
	};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="311">
                  <Properties>
                    <string name="Name">kickServer</string>
                    <string name="Source">return function (_, players)
	for _, player in pairs(players) do
		player:Kick("Kicked by admin.")
	end

	return ("Kicked %d players."):format(#players)
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="312">
                  <Properties>
                    <string name="Name">kill</string>
                    <string name="Source">return {
	Name = "kill";
	Aliases = {"slay"};
	Description = "Kills a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "victims";
			Description = "The players to kill.";
		},
	};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="313">
                  <Properties>
                    <string name="Name">killServer</string>
                    <string name="Source">return function (_, players)
	for _, player in pairs(players) do
		if player.Character then
			player.Character:BreakJoints()
		end
	end

	return ("Killed %d players."):format(#players)
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="314">
                  <Properties>
                    <string name="Name">respawn</string>
                    <string name="Source"><![CDATA[return {
	Name = "respawn";
	Description = "Respawns a player or a group of players.";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"refresh|Respawns the player and returns them to their previous location.\" var= .refresh_pos ${position $1{player|Player}} && respawn $1 && tp $1 @${{var .refresh_pos}}"
	},
	Args = {
		{
			Type = "players";
			Name = "targets";
			Description = "The players to respawn."
		}
	}
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="315">
                  <Properties>
                    <string name="Name">respawnServer</string>
                    <string name="Source"><![CDATA[return function(_, players)
	for _, player in pairs(players) do
		if player.Character then
			player:LoadCharacter()
		end
	end
	return ("Respawned %d players."):format(#players)
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="316">
                  <Properties>
                    <string name="Name">teleport</string>
                    <string name="Source">return {
	Name = "teleport";
	Aliases = {"tp"};
	Description = "Teleports a player or set of players to one target.";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"bring|Brings a player or set of players to you.\" teleport $1{players|players|The players to bring} ${me}";
		"alias \"to|Teleports you to another player or location.\" teleport ${me} $1{player @ vector3|Destination|The player or location to teleport to}";
	};
	Args = {
		{
			Type = "players";
			Name = "From";
			Description = "The players to teleport";
		},
		{
			Type = "player @ vector3";
			Name = "Destination";
			Description = "The player to teleport to"
		}
	};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="317">
                  <Properties>
                    <string name="Name">teleportServer</string>
                    <string name="Source"><![CDATA[return function (_, fromPlayers, destination)
	local cframe

	if typeof(destination) == "Instance" then
		if destination.Character and destination.Character:FindFirstChild("HumanoidRootPart") then
			cframe = destination.Character.HumanoidRootPart.CFrame
		else
			return "Target player has no character."
		end
	elseif typeof(destination) == "Vector3" then
		cframe = CFrame.new(destination)
	end

	for _, player in ipairs(fromPlayers) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			player.Character.HumanoidRootPart.CFrame = cframe
		end
	end

	return ("Teleported %d players."):format(#fromPlayers)
end
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="318">
                <Properties>
                  <string name="Name">Debug</string>
                </Properties>
                <Item class="ModuleScript" referent="319">
                  <Properties>
                    <string name="Name">blink</string>
                    <string name="Source">return {
	Name = "blink";
	Aliases = {"b"};
	Description = "Teleports you to where your mouse is hovering.";
	Group = "DefaultDebug";
	Args = {};

	ClientRun = function(context)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character then
			return "You don't have a character."
		end

		character:MoveTo(mouse.Hit.p)

		return "Blinked!"
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="320">
                  <Properties>
                    <string name="Name">fetch</string>
                    <string name="Source">return {
	Name = "fetch";
	Aliases = {};
	Description = "Fetch a value from the Internet";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "url";
			Name = "URL";
			Description = "The URL to fetch.";
		}
	};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="321">
                  <Properties>
                    <string name="Name">fetchServer</string>
                    <string name="Source">local HttpService = game:GetService("HttpService")

return function (_, url)
	return HttpService:GetAsync(url)
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="322">
                  <Properties>
                    <string name="Name">getPlayerPlaceInstance</string>
                    <string name="Source">return {
	Name = "get-player-place-instance";
	Aliases = {};
	Description = "Returns the target player's Place ID and the JobId separated by a space. Returns 0 if the player is offline or something else goes wrong.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "playerId";
			Name = "Player";
			Description = "Get the place instance of this player";
		},
		function(context)
			return {
				Type = context.Cmdr.Util.MakeEnumType("PlaceInstance Format", {"PlaceIdJobId", "PlaceId", "JobId"}),
				Name = "Format";
				Description = "What data to return. PlaceIdJobId returns both separated by a space.";
				Default = "PlaceIdJobId";
			}
		end
	};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="323">
                  <Properties>
                    <string name="Name">getPlayerPlaceInstanceServer</string>
                    <string name="Source">local TeleportService = game:GetService("TeleportService")

return function (_, playerId, format)
	format = format or "PlaceIdJobId"

	local ok, _, errorText, placeId, jobId = pcall(function()
		return TeleportService:GetPlayerPlaceInstanceAsync(playerId)
	end)

	if not ok or (errorText and #errorText &gt; 0) then
		if format == "PlaceIdJobId" then
			return "0" .. " -"
		elseif format == "PlaceId" then
			return "0"
		elseif format == "JobId" then
			return "-"
		end
	end

	if format == "PlaceIdJobId" then
		return placeId .. " " .. jobId
	elseif format == "PlaceId" then
		return tostring(placeId)
	elseif format == "JobId" then
		return tostring(jobId)
	end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="324">
                  <Properties>
                    <string name="Name">position</string>
                    <string name="Source">local Players = game:GetService("Players")

return {
	Name = "position";
	Aliases = {"pos"};
	Description = "Returns Vector3 position of you or other players. Empty string is the player has no character.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "player";
			Name = "Player";
			Description = "The player to report the position of. Omit for your own position.";
			Default = Players.LocalPlayer;
		}
	};

	ClientRun = function(_, player)
		local character = player.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return ""
		end

		return tostring(character.HumanoidRootPart.Position):gsub("%s", "")
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="325">
                  <Properties>
                    <string name="Name">thru</string>
                    <string name="Source">return {
	Name = "thru";
	Aliases = {"t", "through"};
	Description = "Teleports you through whatever your mouse is hovering over, placing you equidistantly from the wall.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "number";
			Name = "Extra distance";
			Description = "Go through the wall an additional X studs.";
			Default = 0;
		}
	};

	ClientRun = function(context, extra)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return "You don't have a character."
		end

		local pos = character.HumanoidRootPart.Position
		local diff = (mouse.Hit.p - pos)

		character:MoveTo((diff * 2) + (diff.unit * extra) + pos)

		return "Blinked!"
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="326">
                  <Properties>
                    <string name="Name">uptime</string>
                    <string name="Source">return {
	Name = "uptime";
	Aliases = {};
	Description = "Returns the amount of time the server has been running.";
	Group = "DefaultDebug";
	Args = {};
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="327">
                  <Properties>
                    <string name="Name">uptimeServer</string>
                    <string name="Source">local startTime = os.time()

return function ()
	local uptime = os.time() - startTime
	return ("%dd %dh %dm %ds"):format(
		math.floor(uptime / (60 * 60 * 24)),
		math.floor(uptime / (60 * 60)) % 24,
		math.floor(uptime / 60) % 60,
		math.floor(uptime) % 60
	)
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="328">
                  <Properties>
                    <string name="Name">version</string>
                    <string name="Source"><![CDATA[local version = "v1.12.0"

return {
	Name = "version",
	Args = {},
	Description = "Shows the current version of Cmdr",
	Group = "DefaultDebug",

	Run = function()
		return ("Cmdr Version %s"):format(version)
	end,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="329">
                <Properties>
                  <string name="Name">Utility</string>
                </Properties>
                <Item class="ModuleScript" referent="330">
                  <Properties>
                    <string name="Name">alias</string>
                    <string name="Source">return {
	Name = "alias";
	Aliases = {};
	Description = "Creates a new, single command out of a command and given arguments.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Alias name";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "string";
			Name = "Command string";
			Description = "The command text you want to run. Separate multiple commands with \"&amp;&amp;\". Accept arguments with $1, $2, $3, etc."
		},
	};

	ClientRun = function(context, name, commandString)
		context.Cmdr.Registry:RegisterCommandObject(
			context.Cmdr.Util.MakeAliasCommand(name, commandString),
			true
		)

		return ("Created alias %q"):format(name)
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="331">
                  <Properties>
                    <string name="Name">bind</string>
                    <string name="Source">local UserInputService = game:GetService("UserInputService")

return {
	Name = "bind";
	Aliases = {};
	Description = "Binds a command string to a key or mouse input.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "command";
			Name = "Command";
			Description = "The command you want to run on this input"
		},
		{
			Type = "string";
			Name = "Arguments";
			Description = "The arguments for the command";
			Default = "";
		}
	};

	ClientRun = function(context, bind, command, arguments)
		local binds = context:GetStore("CMDR_Binds")

		command = command .. " " .. arguments

		if binds[bind] then
			binds[bind]:Disconnect()
		end

		local bindType = context:GetArgument(1).Type.Name

		if bindType == "userInput" then
			binds[bind] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
				if gameProcessed then
					return
				end

				if input.UserInputType == bind or input.KeyCode == bind then
					context:Reply(context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command)))
				end
			end)
		elseif bindType == "bindableResource" then
			return "Unimplemented..."
		elseif bindType == "player" then
			binds[bind] = bind.Chatted:Connect(function(message)
				local args = { message }
				local chatCommand = context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, context.Cmdr.Util.SubstituteArgs(command, args))
				context:Reply(("%s $ %s : %s"):format(
					bind.Name,
					chatCommand,
					context.Dispatcher:EvaluateAndRun(chatCommand)
				), Color3.fromRGB(244, 92, 66))
			end)
		end


		return "Bound command to input."
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="332">
                  <Properties>
                    <string name="Name">clear</string>
                    <string name="Source"><![CDATA[local Players = game:GetService("Players")

return {
	Name = "clear",
	Aliases = {},
	Description = "Clear all lines above the entry line of the Cmdr window.",
	Group = "DefaultUtil",
	Args = {},
	ClientRun = function()
		local player = Players.LocalPlayer
		local gui = player:WaitForChild("PlayerGui"):WaitForChild("Cmdr")
		local frame = gui:WaitForChild("Frame")

		if gui and frame then
			for _, child in pairs(frame:GetChildren()) do
				if child.Name == "Line" and child:IsA("TextBox") then
					child:Destroy()
				end
			end
		end
		return ""
	end
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="333">
                  <Properties>
                    <string name="Name">convertTimestamp</string>
                    <string name="Source"><![CDATA[return {
	Name = "convertTimestamp";
	Aliases = { "date" },
	Description = "Convert a timestamp to a human-readable format.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "number";
			Name = "timestamp";
			Description = "A numerical representation of a specific moment in time.";
			Optional = true
		}
	};
	ClientRun = function(_, timestamp)
		timestamp = timestamp or os.time()
		return `{os.date("%x", timestamp)} {os.date("%X", timestamp)}`
	end
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="334">
                  <Properties>
                    <string name="Name">echo</string>
                    <string name="Source">return {
	Name = "echo";
	Aliases = {"="};
	Description = "Echoes your text back to you.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Text";
			Description = "The text."
		},
	};

	Run = function(_, text)
		return text
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="335">
                  <Properties>
                    <string name="Name">edit</string>
                    <string name="Source">local Players = game:GetService("Players")

local TEXT_BOX_PROPERTIES = {
	AnchorPoint = Vector2.new(0.5, 0.5),
	BackgroundColor3 = Color3.fromRGB(17, 17, 17),
	BackgroundTransparency = 0.05,
	BorderColor3 = Color3.fromRGB(17, 17, 17),
	BorderSizePixel = 20,
	ClearTextOnFocus = false,
	MultiLine = true,
	Position = UDim2.new(0.5, 0, 0.5, 0),
	Size = UDim2.new(0.5, 0, 0.4, 0),
	Font = Enum.Font.Code,
	TextColor3 = Color3.fromRGB(241, 241, 241),
	TextWrapped = true,
	TextSize = 18,
	TextXAlignment = "Left",
	TextYAlignment = "Top",
	AutoLocalize = false,
	PlaceholderText = "Right click to exit",
}

local lock

return {
	Name = "edit";
	Aliases = {};
	Description = "Edit text in a TextBox";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Input text";
			Description = "The text you wish to edit";
			Default = "";
		},
		{
			Type = "string";
			Name = "Delimiter";
			Description = "The character that separates each line";
			Default = ",";
		}
	};

	ClientRun = function(context, text, delimeter)
		lock = lock or context.Cmdr.Util.Mutex()

		local unlock = lock()

		context:Reply("Right-click on the text area to exit.", Color3.fromRGB(158, 158, 158))

		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = "CmdrEditBox"
		screenGui.ResetOnSpawn = false

		local textBox = Instance.new("TextBox")

		for key, value in pairs(TEXT_BOX_PROPERTIES) do
			textBox[key] = value
		end

		textBox.Text = text:gsub(delimeter, "\n")
		textBox.Parent = screenGui

		screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

		local thread = coroutine.running()

		textBox.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				coroutine.resume(thread, textBox.Text:gsub("\n", delimeter))
				screenGui:Destroy()
				unlock()
			end
		end)

		return coroutine.yield()
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="336">
                  <Properties>
                    <string name="Name">history</string>
                    <string name="Source">return {
	Name = "history";
	Aliases = {};
	AutoExec = {
		"alias \"!|Displays previous command from history.\" run ${history $1{number|Line Number}}";
		"alias \"^|Runs the previous command, replacing all occurrences of A with B.\" run ${run replace ${history -1} $1{string|A} $2{string|B}}";
		"alias \"!!|Reruns the last command.\" ! -1";
	};
	Description = "Displays previous commands from history.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "Line Number";
			Description = "Command line number (can be negative to go from end)"
		},
	};

	ClientRun = function(context, line)
		local history = context.Dispatcher:GetHistory()

		if line &lt;= 0 then
			line = #history + line
		end

		return history[line] or ""
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="337">
                  <Properties>
                    <string name="Name">hover</string>
                    <string name="Source">local Players = game:GetService("Players")

return {
	Name = "hover";
	Description = "Returns the name of the player you are hovering over.";
	Group = "DefaultUtil";
	Args = {};

	ClientRun = function()
		local mouse = Players.LocalPlayer:GetMouse()
		local target = mouse.Target

		if not target then
			return ""
		end

		local p = Players:GetPlayerFromCharacter(target:FindFirstAncestorOfClass("Model"))

		return p and p.Name or ""
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="338">
                  <Properties>
                    <string name="Name">jsonArrayDecode</string>
                    <string name="Source"><![CDATA[return {
	Name = "json-array-decode";
	Aliases = {};
	Description = "Decodes a JSON Array into a comma-separated list";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "json";
			Name = "JSON";
			Description = "The JSON array."
		},
	};

	ClientRun = function(_, value)
		if type(value) ~= "table" then
			value = { value }
		end

		return table.concat(value, ",")
	end
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="339">
                  <Properties>
                    <string name="Name">jsonArrayEncode</string>
                    <string name="Source">local HttpService = game:GetService("HttpService")

return {
	Name = "json-array-encode";
	Aliases = {};
	Description = "Encodes a comma-separated list into a JSON array";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		},
	};

	Run = function(_, text)
		return HttpService:JSONEncode(text:split(","))
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="340">
                  <Properties>
                    <string name="Name">len</string>
                    <string name="Source">return {
	Name = "len";
	Aliases = {};
	Description = "Returns the length of a comma-separated list";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		}
	};

	Run = function(_, list)
		return #(list:split(","))
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="341">
                  <Properties>
                    <string name="Name">math</string>
                    <string name="Source"><![CDATA[return {
	Name = "math";
	Aliases = {};
	Description = "Perform a math operation on 2 values.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"+|Perform an addition.\" math + $1{number|Number} $2{number|Number}";
		"alias \"-|Perform a subtraction.\" math - $1{number|Number} $2{number|Number}";
		"alias \"*|Perform a multiplication.\" math * $1{number|Number} $2{number|Number}";
		"alias \"/|Perform a division.\" math / $1{number|Number} $2{number|Number}";
		"alias \"**|Perform an exponentiation.\" math ** $1{number|Number} $2{number|Number}";
		"alias \"%|Perform a modulus.\" math % $1{number|Number} $2{number|Number}";
	};
	Args = {
		{
			Type = "mathOperator";
			Name = "Operation";
			Description = "A math operation."
		};
		{
			Type = "number";
			Name = "Value";
			Description = "A number value."
		};
		{
			Type = "number";
			Name = "Value";
			Description = "A number value."
		}
	};

	ClientRun = function(_, operation, a, b)
		return operation.Perform(a, b)
	end
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="342">
                  <Properties>
                    <string name="Name">pick</string>
                    <string name="Source">return {
	Name = "pick";
	Aliases = {};
	Description = "Picks a value out of a comma-separated list.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "positiveInteger";
			Name = "Index to pick";
			Description = "The index of the item you want to pick";
		},
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		}
	};

	Run = function(_, index, list)
		return list:split(",")[index] or ""
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="343">
                  <Properties>
                    <string name="Name">rand</string>
                    <string name="Source">return {
	Name = "rand";
	Aliases = {};
	Description = "Returns a random number between min and max";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "First number";
			Description = "If second number is nil, random number is between 1 and this value. If second number is provided, number is between this number and the second number."
		},
		{
			Type = "integer";
			Name = "Second number";
			Description = "The upper bound.";
			Optional = true;
		}
	};

	Run = function(_, min, max)
		return tostring(max and math.random(min, max) or math.random(min))
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="344">
                  <Properties>
                    <string name="Name">replace</string>
                    <string name="Source">return {
	Name = "replace";
	Aliases = {"gsub", "//"};
	Description = "Replaces text A with text B";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"map|Maps a CSV into another CSV\" replace $1{string|CSV} ([^,]+) \"$2{string|mapped value|Use %1 to insert the element}\"",
		"alias \"join|Joins a CSV with a specified delimiter\" replace $1{string|CSV} , $2{string|Delimiter}"
	},
	Args = {
		{
			Type = "string";
			Name = "Haystack";
			Description = "The source string upon which to perform replacement."
		},
		{
			Type = "string";
			Name = "Needle";
			Description = "The string pattern search for."
		},
		{
			Type = "string";
			Name = "Replacement";
			Description = "The string to replace matches (%1 to insert matches).";
			Default = "";
		},
	};

	Run = function(_, haystack, needle, replacement)
		return haystack:gsub(needle, replacement)
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="345">
                  <Properties>
                    <string name="Name">resolve</string>
                    <string name="Source">return {
	Name = "resolve";
	Aliases = {};
	Description = "Resolves Argument Value Operators into lists. E.g., resolve players * gives you a list of all players.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"me|Displays your username\" resolve players ."
	};
	Args = {
		{
			Type = "type";
			Name = "Type";
			Description = "The type for which to resolve"
		},
		function (context)
			if context:GetArgument(1):Validate() == false then
				return
			end

			return {
				Type = context:GetArgument(1):GetValue();
				Name = "Argument Value Operator";
				Description = "The value operator to resolve. One of: * ** . ? ?N";
				Optional = true;
			}
		end
	};

	Run = function(context)
		return table.concat(context:GetArgument(2).RawSegments, ",")
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="346">
                  <Properties>
                    <string name="Name">run</string>
                    <string name="Source">return {
	Name = "run";
	Aliases = {"&gt;"};
	AutoExec = {
		"alias \"discard|Run a command and discard the output.\" replace ${run $1} .* \\\"\\\""
	};
	Description = "Runs a given command string (replacing embedded commands).";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run"
		},
	};

	Run = function(context, commandString)
		return context.Cmdr.Util.RunCommandString(context.Dispatcher, commandString)
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="347">
                  <Properties>
                    <string name="Name">runLines</string>
                    <string name="Source"><![CDATA[return {
	Name = "run-lines";
	Aliases = {};
	Description = "Splits input by newlines and runs each line as its own command. This is used by the init-run command.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Script";
			Description = "The script to parse.";
			Default = "";
		}
	};

	ClientRun = function(context, text)
		if #text == 0 then
			return ""
		end

		local shouldPrintOutput = context.Dispatcher:Run("var", "INIT_PRINT_OUTPUT") ~= ""

		local commands = text:gsub("\n+", "\n"):split("\n")

		for _, command in ipairs(commands) do
			if command:sub(1, 1) == "#" then
				continue
			end

			local output = context.Dispatcher:EvaluateAndRun(command)

			if shouldPrintOutput then
				context:Reply(output)
			end
		end

		return ""
	end
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="348">
                  <Properties>
                    <string name="Name">runif</string>
                    <string name="Source">local conditions = {
	startsWith = function (text, arg)
		if text:sub(1, #arg) == arg then
			return text:sub(#arg + 1)
		end
	end
}

return {
	Name = "runif";
	Aliases = {};
	Description = "Runs a given command string if a certain condition is met.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "conditionFunction";
			Name = "Condition";
			Description = "The condition function"
		},
		{
			Type = "string";
			Name = "Argument";
			Description = "The argument to the condition function"
		},
		{
			Type = "string";
			Name = "Test against";
			Description = "The text to test against."
		},
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run if requirements are met. If omitted, return value from condition function is used.";
			Optional = true;
		},
	};

	Run = function(context, condition, arg, testAgainst, command)
		local conditionFunc = conditions[condition]

		if not conditionFunc then
			return ("Condition %q is not valid."):format(condition)
		end

		local text = conditionFunc(testAgainst, arg)

		if text then
			return context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command or text))
		end

		return ""
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="349">
                  <Properties>
                    <string name="Name">unbind</string>
                    <string name="Source">return {
	Name = "unbind";
	Aliases = {};
	Description = "Unbinds an input previously bound with Bind";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input/Key";
			Description = "The key or input type you'd like to unbind."
		}
	};

	ClientRun = function(context, inputEnum)
		local binds = context:GetStore("CMDR_Binds")

		if binds[inputEnum] then
			binds[inputEnum]:Disconnect()
			binds[inputEnum] = nil
			return "Unbound command from input."
		else
			return "That input wasn't bound."
		end
	end
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="350">
                  <Properties>
                    <string name="Name">var</string>
                    <string name="Source"><![CDATA[return {
	Name = "var";
	Aliases = {};
	Description = "Gets a stored variable.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"init-edit|Edit your initialization script\" edit ${var init} \\\\\n && var= init ||",
		"alias \"init-run|Re-runs the initialization script manually.\" run-lines ${var init}",
		"init-run",
	},
	Args = {
		{
			Type = "storedKey";
			Name = "Key";
			Description = "The key to get, retrieved from your user data store. Keys prefixed with . are not saved. Keys prefixed with $ are game-wide. Keys prefixed with $. are game-wide and non-saved.";
		}
	};

	ClientRun = function(context, key)
		context:GetStore("vars_used")[key] = true
	end
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="351">
                  <Properties>
                    <string name="Name">varServer</string>
                    <string name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local queue = {}
local DataStoresActive, DataStore
task.spawn(function()
	DataStoresActive, DataStore = pcall(function()
		local DataStore = DataStoreService:GetDataStore("_package/eryn.io/Cmdr")
		DataStore:GetAsync("test_key")
		return DataStore
	end)

	while #queue > 0 do
		coroutine.resume(table.remove(queue, 1))
	end
end)

return function (context, key)
	if DataStoresActive == nil then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	local gameWide = false
	local saved = true

	if key:sub(1, 1) == "$" then
		key = key:sub(2)
		gameWide = true
	end

	if key:sub(1, 1) == "." then
		key = key:sub(2)
		saved = false
	end

	if saved and not DataStoresActive then
		return "# You must publish this place to the web to use saved keys."
	end

	local namespace = "var_" .. (gameWide and "global" or tostring(context.Executor.UserId))

	if saved then
		local keyPath = namespace .. "_" .. key
		local value = DataStore:GetAsync(keyPath) or ""
		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end
		return value
	else
		local store = context:GetStore(namespace)

		local value = store[key] or ""

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	end
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="352">
                  <Properties>
                    <string name="Name">varSet</string>
                    <string name="Source"><![CDATA[return {
	Name = "var=";
	Aliases = {};
	Description = "Sets a stored value.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "storedKey";
			Name = "Key";
			Description = "The key to set, saved in your user data store. Keys prefixed with . are not saved. Keys prefixed with $ are game-wide. Keys prefixed with $. are game-wide and non-saved.";
		},
		{
			Type = "string";
			Name = "Value";
			Description = "Value or values to set.";
			Default = "";
		}
	};

	ClientRun = function(context, key)
		context:GetStore("vars_used")[key] = true
	end
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="353">
                  <Properties>
                    <string name="Name">varSetServer</string>
                    <string name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local queue = {}
local DataStoresActive, DataStore
task.spawn(function()
	DataStoresActive, DataStore = pcall(function()
		local DataStore = DataStoreService:GetDataStore("_package/eryn.io/Cmdr")
		DataStore:GetAsync("test_key")
		return DataStore
	end)

	while #queue > 0 do
		coroutine.resume(table.remove(queue, 1))
	end
end)

return function (context, key, value)
	if DataStoresActive == nil then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	local gameWide = false
	local saved = true

	if key:sub(1, 1) == "$" then
		key = key:sub(2)
		gameWide = true
	end

	if key:sub(1, 1) == "." then
		key = key:sub(2)
		saved = false
	end

	if saved and not DataStoresActive then
		return "# You must publish this place to the web to use saved keys."
	end

	local namespace = "var_" .. (gameWide and "global" or tostring(context.Executor.UserId))

	if saved then
		local keyPath = namespace .. "_" .. key

		DataStore:SetAsync(keyPath, value)

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	else
		local store = context:GetStore(namespace)

		store[key] = value

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	end
end
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="354">
                <Properties>
                  <string name="Name">help</string>
                  <string name="Source"><![CDATA[local ARGUMENT_SHORTHANDS = [[
Argument Shorthands
-------------------
.   Me/Self
*   All/Everyone
**  Others
?   Random
?N  List of N random values
]]

local TIPS = [[
Tips
----
• Utilize the Tab key to automatically complete commands
• Easily select and copy command output
]]

return {
	Name = "help";
	Description = "Displays a list of all commands, or inspects one command.";
	Group = "Help";
	Args = {
		{
			Type = "command";
			Name = "Command";
			Description = "The command to view information on";
			Optional = true;
		},
	};

	ClientRun = function (context, commandName)
		if commandName then
			local command = context.Cmdr.Registry:GetCommand(commandName)
			context:Reply(`Command: {command.Name}`, Color3.fromRGB(230, 126, 34))
			if command.Aliases and #command.Aliases > 0 then
				context:Reply(`Aliases: {table.concat(command.Aliases, ", ")}`, Color3.fromRGB(230, 230, 230))
			end
			context:Reply(command.Description, Color3.fromRGB(230, 230, 230))
			for i, arg in ipairs(command.Args) do
				context:Reply(
					`#{i} {arg.Name}{if arg.Optional == true then "?" else ""}: {arg.Type} - {arg.Description}`
				)
			end
		else
			context:Reply(ARGUMENT_SHORTHANDS)
			context:Reply(TIPS)

			local commands = context.Cmdr.Registry:GetCommands()
			table.sort(commands, function(a, b)
				return if a.Group and b.Group then a.Group < b.Group else a.Group
			end)
			local lastGroup
			for _, command in ipairs(commands) do
				command.Group = command.Group or "No Group"
				if lastGroup ~= command.Group then
					context:Reply(`\n{command.Group}\n{string.rep("-", #command.Group)}`)
					lastGroup = command.Group
				end
				context:Reply(if command.Description then `{command.Name} - {command.Description}` else command.Name)
			end
		end
		return ""
	end;
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="355">
              <Properties>
                <string name="Name">BuiltInTypes</string>
              </Properties>
              <Item class="ModuleScript" referent="356">
                <Properties>
                  <string name="Name">BindableResource</string>
                  <string name="Source"><![CDATA[return function (registry)
	registry:RegisterType("bindableResource", registry.Cmdr.Util.MakeEnumType("BindableResource", {"Chat"}))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="357">
                <Properties>
                  <string name="Name">BrickColor</string>
                  <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local brickColorNames = {
    "White", "Grey", "Light yellow", "Brick yellow", "Light green (Mint)", "Light reddish violet", "Pastel Blue",
    "Light orange brown", "Nougat", "Bright red", "Med. reddish violet", "Bright blue", "Bright yellow", "Earth orange",
    "Black", "Dark grey", "Dark green", "Medium green", "Lig. Yellowich orange", "Bright green", "Dark orange",
    "Light bluish violet", "Transparent", "Tr. Red", "Tr. Lg blue", "Tr. Blue", "Tr. Yellow", "Light blue",
    "Tr. Flu. Reddish orange", "Tr. Green", "Tr. Flu. Green", "Phosph. White", "Light red", "Medium red", "Medium blue",
    "Light grey", "Bright violet", "Br. yellowish orange", "Bright orange", "Bright bluish green", "Earth yellow",
    "Bright bluish violet", "Tr. Brown", "Medium bluish violet", "Tr. Medi. reddish violet", "Med. yellowish green",
    "Med. bluish green", "Light bluish green", "Br. yellowish green", "Lig. yellowish green", "Med. yellowish orange",
    "Br. reddish orange", "Bright reddish violet", "Light orange", "Tr. Bright bluish violet", "Gold", "Dark nougat",
    "Silver", "Neon orange", "Neon green", "Sand blue", "Sand violet", "Medium orange", "Sand yellow", "Earth blue",
    "Earth green", "Tr. Flu. Blue", "Sand blue metallic", "Sand violet metallic", "Sand yellow metallic",
    "Dark grey metallic", "Black metallic", "Light grey metallic", "Sand green", "Sand red", "Dark red",
    "Tr. Flu. Yellow", "Tr. Flu. Red", "Gun metallic", "Red flip/flop", "Yellow flip/flop", "Silver flip/flop", "Curry",
    "Fire Yellow", "Flame yellowish orange", "Reddish brown", "Flame reddish orange", "Medium stone grey", "Royal blue",
    "Dark Royal blue", "Bright reddish lilac", "Dark stone grey", "Lemon metalic", "Light stone grey", "Dark Curry",
    "Faded green", "Turquoise", "Light Royal blue", "Medium Royal blue", "Rust", "Brown", "Reddish lilac", "Lilac",
    "Light lilac", "Bright purple", "Light purple", "Light pink", "Light brick yellow", "Warm yellowish orange",
    "Cool yellow", "Dove blue", "Medium lilac", "Slime green", "Smoky grey", "Dark blue", "Parsley green", "Steel blue",
    "Storm blue", "Lapis", "Dark indigo", "Sea green", "Shamrock", "Fossil", "Mulberry", "Forest green", "Cadet blue",
    "Electric blue", "Eggplant", "Moss", "Artichoke", "Sage green", "Ghost grey", "Lilac", "Plum", "Olivine",
    "Laurel green", "Quill grey", "Crimson", "Mint", "Baby blue", "Carnation pink", "Persimmon", "Maroon", "Gold",
    "Daisy orange", "Pearl", "Fog", "Salmon", "Terra Cotta", "Cocoa", "Wheat", "Buttermilk", "Mauve", "Sunrise",
    "Tawny", "Rust", "Cashmere", "Khaki", "Lily white", "Seashell", "Burgundy", "Cork", "Burlap", "Beige", "Oyster",
    "Pine Cone", "Fawn brown", "Hurricane grey", "Cloudy grey", "Linen", "Copper", "Dirt brown", "Bronze", "Flint",
    "Dark taupe", "Burnt Sienna", "Institutional white", "Mid gray", "Really black", "Really red", "Deep orange",
    "Alder", "Dusty Rose", "Olive", "New Yeller", "Really blue", "Navy blue", "Deep blue", "Cyan", "CGA brown",
    "Magenta", "Pink", "Deep orange", "Teal", "Toothpaste", "Lime green", "Camo", "Grime", "Lavender",
    "Pastel light blue", "Pastel orange", "Pastel violet", "Pastel blue-green", "Pastel green", "Pastel yellow",
    "Pastel brown", "Royal purple", "Hot pink"
}

local brickColorFinder = Util.MakeFuzzyFinder(brickColorNames)

local brickColorType =  {
	Prefixes = "% teamColor";

    Transform = function(text)
        local brickColors = {}
        for i, name in pairs(brickColorFinder(text)) do
            brickColors[i] = BrickColor.new(name)
        end
        return brickColors
    end;

    Validate = function(brickColors)
        return #brickColors &gt; 0, "No valid brick colors with that name could be found."
    end;

    Autocomplete = function(brickColors)
        return Util.GetNames(brickColors)
    end;

    Parse = function(brickColors)
        return brickColors[1]
    end;
}

local brickColor3Type = {
	Transform = brickColorType.Transform;
	Validate = brickColorType.Validate;
	Autocomplete = brickColorType.Autocomplete;

	Parse = function(brickColors)
		return brickColors[1].Color
	end;
}

return function(registry)
    registry:RegisterType("brickColor", brickColorType)
	registry:RegisterType("brickColors", Util.MakeListableType(brickColorType, {
		Prefixes = "% teamColors"
	}))

	registry:RegisterType("brickColor3", brickColor3Type)
    registry:RegisterType("brickColor3s", Util.MakeListableType(brickColor3Type))
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="358">
                <Properties>
                  <string name="Name">Color3</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local color3Type = Util.MakeSequenceType({
	Prefixes = "# hexColor3 ! brickColor3";
	ValidateEach = function(value, i)
		if value == nil then
			return false, ("Invalid or missing number at position %d in Color3 type."):format(i)
		elseif value < 0 or value > 255 then
			return false, ("Number out of acceptable range 0-255 at position %d in Color3 type."):format(i)
		elseif value % 1 ~= 0 then
			return false, ("Number is not an integer at position %d in Color3 type."):format(i)
		end

		return true
	end;
	TransformEach = tonumber;
	Constructor = Color3.fromRGB;
	Length = 3;
})

local function parseHexDigit(x)
	if #x == 1 then
		x = x .. x
	end

	return tonumber(x, 16)
end

local hexColor3Type = {
	Transform = function(text)
		local r, g, b = text:match("^#?(%x%x?)(%x%x?)(%x%x?)$")
		return Util.Each(parseHexDigit, r, g, b)
	end;

	Validate = function(r, g, b)
		return r ~= nil and g ~= nil and b ~= nil, "Invalid hex color"
	end;

	Parse = function(...)
		return Color3.fromRGB(...)
	end;
}

return function (cmdr)
	cmdr:RegisterType("color3", color3Type)
	cmdr:RegisterType("color3s", Util.MakeListableType(color3Type, {
		Prefixes = "# hexColor3s ! brickColor3s"
	}))

	cmdr:RegisterType("hexColor3", hexColor3Type)
	cmdr:RegisterType("hexColor3s", Util.MakeListableType(hexColor3Type))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="359">
                <Properties>
                  <string name="Name">Command</string>
                  <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

return function (cmdr)
	local commandType = {
		Transform = function (text)
			local findCommand = Util.MakeFuzzyFinder(cmdr:GetCommandNames())

			return findCommand(text)
		end;

		Validate = function (commands)
			return #commands &gt; 0, "No command with that name could be found."
		end;

		Autocomplete = function (commands)
			return commands
		end;

		Parse = function (commands)
			return commands[1]
		end;
	}

	cmdr:RegisterType("command", commandType)
	cmdr:RegisterType("commands", Util.MakeListableType(commandType))
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="360">
                <Properties>
                  <string name="Name">ConditionFunction</string>
                  <string name="Source"><![CDATA[return function (registry)
	registry:RegisterType("conditionFunction", registry.Cmdr.Util.MakeEnumType("ConditionFunction", {"startsWith"}))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="361">
                <Properties>
                  <string name="Name">Duration</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local unitTable = {
    Years = 31556926,
    Months = 2629744,
    Weeks = 604800,
    Days = 86400,
    Hours = 3600,
    Minutes = 60,
    Seconds = 1
}

local searchKeyTable = {}
for key, _ in pairs(unitTable) do
    table.insert(searchKeyTable, key)
end
local unitFinder = Util.MakeFuzzyFinder(searchKeyTable)

local function stringToSecondDuration(stringDuration)
    -- The duration cannot be null or an empty string.
    if stringDuration == nil or stringDuration == "" then
        return nil
    end
    -- Allow 0 by itself (without a unit) to indicate 0 seconds
    local durationNum = tonumber(stringDuration)
    if durationNum and durationNum == 0 then
        return 0, 0, true
    end
    -- The duration must end with a unit,
    -- if it doesn't then return true as the fourth value to indicate the need to offer autocomplete for units.
    local endOnlyString = stringDuration:gsub("-?%d+%a+", "")
    local endNumber = endOnlyString:match("-?%d+")
    if endNumber then
        return nil, tonumber(endNumber), true
    end
    local seconds = nil
    local rawNum, rawUnit
    for rawComponent in stringDuration:gmatch("-?%d+%a+") do
        rawNum, rawUnit = rawComponent:match("(-?%d+)(%a+)")
        local unitNames = unitFinder(rawUnit)
        -- There were no matching units, it's invalid. Return the parsed number to be used for autocomplete
        if #unitNames == 0 then
            return nil, tonumber(rawNum)
        end
        if seconds == nil then seconds = 0 end
        -- While it was already defaulting to use minutes when using just "m", this does it without worrying
        -- about any consistency between list ordering.
        seconds = seconds + (rawUnit:lower() == "m" and 60 or unitTable[unitNames[1]]) * tonumber(rawNum)
    end
    -- If no durations were provided, return nil.
    if seconds == nil then
        return nil
    else
        return seconds, tonumber(rawNum)
    end
end

local function mapUnits(units, rawText, lastNumber, subStart)
    subStart = subStart or 1
    local returnTable = {}
    for i, unit in pairs(units) do
        if lastNumber == 1 then
            returnTable[i] = rawText .. unit:sub(subStart, #unit - 1)
        else
            returnTable[i] = rawText .. unit:sub(subStart)
        end
    end
    return returnTable
end

local durationType = {
    Transform = function(text)
        return text, stringToSecondDuration(text)
    end;

    Validate = function(_, duration)
        return duration ~= nil
    end;

    Autocomplete = function(rawText, duration, lastNumber, isUnitMissing, matchedUnits)
        local returnTable = {}
        if isUnitMissing or matchedUnits then
            local unitsTable = isUnitMissing == true and unitFinder("") or matchedUnits
            if isUnitMissing == true then
                -- Concat the entire unit name to existing text.
                returnTable = mapUnits(unitsTable, rawText, lastNumber)
            else
                -- Concat the rest of the unit based on what already exists of the unit name.
                local existingUnitLength = rawText:match("^.*(%a+)$"):len()
                returnTable = mapUnits(unitsTable, rawText, existingUnitLength + 1)
            end
        elseif duration ~= nil then
            local endingUnit = rawText:match("^.*-?%d+(%a+)%s?$")
            -- Assume there is a singular match at this point
            local fuzzyUnits = unitFinder(endingUnit)
            -- List all possible fuzzy matches. This is for the Minutes/Months ambiguity case.
            returnTable = mapUnits(fuzzyUnits, rawText, lastNumber, #endingUnit + 1)
            -- Sort alphabetically in the Minutes/Months case, so Minutes are displayed on top.
            table.sort(returnTable)
        end
        return returnTable
    end;

    Parse = function(_, duration)
        return duration
    end;
}

return function(registry)
    registry:RegisterType("duration", durationType)
    registry:RegisterType("durations", Util.MakeListableType(durationType))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="362">
                <Properties>
                  <string name="Name">JSON</string>
                  <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

return function(registry)
	registry:RegisterType("json", {
		Validate = function(text)
			return pcall(HttpService.JSONDecode, HttpService, text)
		end;

		Parse = function(text)
			return HttpService:JSONDecode(text)
		end
	})
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="363">
                <Properties>
                  <string name="Name">MathOperator</string>
                  <string name="Source"><![CDATA[return function(registry)
	registry:RegisterType("mathOperator", registry.Cmdr.Util.MakeEnumType("Math Operator", {
		{
			Name = "+";
			Perform = function(a, b)
				return a + b
			end
		};
		{
			Name = "-";
			Perform = function(a, b)
				return a - b
			end
		};
		{
			Name = "*";
			Perform = function(a, b)
				return a * b
			end
		};
		{
			Name = "/";
			Perform = function(a, b)
				return a / b
			end
		};
		{
			Name = "**";
			Perform = function(a, b)
				return a ^ b
			end
		};
		{
			Name = "%";
			Perform = function(a, b)
				return a % b
			end
		}
	}))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="364">
                <Properties>
                  <string name="Name">Player</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local playerType = {
	Transform = function (text)
		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return findPlayer(text)
	end;

	Validate = function (players)
		return #players > 0, "No player with that name could be found."
	end;

	Autocomplete = function (players)
		return Util.GetNames(players)
	end;

	Parse = function (players)
		return players[1]
	end;

	Default = function(player)
		return player.Name
	end;

	ArgumentOperatorAliases = {
		me = ".";
		all = "*";
		others = "**";
		random = "?";
	};
}

return function (cmdr)
	cmdr:RegisterType("player", playerType)
	cmdr:RegisterType("players", Util.MakeListableType(playerType, {
		Prefixes = "% teamPlayers";
	}))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="365">
                <Properties>
                  <string name="Name">PlayerId</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local nameCache = {}
local function getUserId(name)
	if nameCache[name] then
		return nameCache[name]
	elseif Players:FindFirstChild(name) then
		nameCache[name] = Players[name].UserId
		return Players[name].UserId
	else
		local ok, userid = pcall(Players.GetUserIdFromNameAsync, Players, name)

		if not ok then
			return nil
		end

		nameCache[name] = userid
		return userid
	end
end

local playerIdType = {
	DisplayName = "Full Player Name";
	Prefixes = "# positiveInteger";

	Transform = function (text)
		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return text, findPlayer(text)
	end;

	ValidateOnce = function (text)
		return getUserId(text) ~= nil, "No player with that name could be found."
	end;

	Autocomplete = function (_, players)
		return Util.GetNames(players)
	end;

	Parse = function (text)
		return getUserId(text)
	end;

	Default = function(player)
		return player.Name
	end;

	ArgumentOperatorAliases = {
		me = ".";
		all = "*";
		others = "**";
		random = "?";
	};
}

return function (cmdr)
	cmdr:RegisterType("playerId", playerIdType)
	cmdr:RegisterType("playerIds", Util.MakeListableType(playerIdType, {
		Prefixes = "# positiveIntegers"
	}))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="366">
                <Properties>
                  <string name="Name">Primitives</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local stringType = {
	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return tostring(value)
	end;
}

local numberType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return value
	end;
}

local intType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil and value == math.floor(value), "Only whole numbers are valid."
	end;

	Parse = function (value)
		return value
	end
}

local positiveIntType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value > 0, "Only positive whole numbers are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local nonNegativeIntType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0, "Only non-negative whole numbers are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local byteType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0 and value <= 255, "Only bytes are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local digitType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0 and value <= 9, "Only digits are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local boolType do
	local truthy = Util.MakeDictionary({"true", "t", "yes", "y", "on", "enable", "enabled", "1", "+"});
	local falsy = Util.MakeDictionary({"false"; "f"; "no"; "n"; "off"; "disable"; "disabled"; "0"; "-"});

	boolType = {
		Transform = function (text)
			return text:lower()
		end;

		Validate = function (value)
			return truthy[value] ~= nil or falsy[value] ~= nil, "Please use true/yes/on or false/no/off."
		end;

		Parse = function (value)
			if truthy[value] then
				return true
			elseif falsy[value] then
				return false
			else
				return nil
			end
		end;
	}
end

return function (cmdr)
	cmdr:RegisterType("string", stringType)
	cmdr:RegisterType("number", numberType)
	cmdr:RegisterType("integer", intType)
	cmdr:RegisterType("positiveInteger", positiveIntType)
	cmdr:RegisterType("nonNegativeInteger", nonNegativeIntType)
	cmdr:RegisterType("byte", byteType)
	cmdr:RegisterType("digit", digitType)
	cmdr:RegisterType("boolean", boolType)

	cmdr:RegisterType("strings", Util.MakeListableType(stringType))
	cmdr:RegisterType("numbers", Util.MakeListableType(numberType))
	cmdr:RegisterType("integers", Util.MakeListableType(intType))
	cmdr:RegisterType("positiveIntegers", Util.MakeListableType(positiveIntType))
	cmdr:RegisterType("nonNegativeIntegers", Util.MakeListableType(nonNegativeIntType))
	cmdr:RegisterType("bytes", Util.MakeListableType(byteType))
	cmdr:RegisterType("digits", Util.MakeListableType(digitType))
	cmdr:RegisterType("booleans", Util.MakeListableType(boolType))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="367">
                <Properties>
                  <string name="Name">StoredKey</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local VALID_STORED_KEY_NAME_PATTERNS = {
	"^%a[%w_]*$",
	"^%$%a[%w_]*$",
	"^%.%a[%w_]*$",
	"^%$%.%a[%w_]*$",
}

return function (registry)
	local storedKeyType = {
		Autocomplete = function(text)
			local find = registry.Cmdr.Util.MakeFuzzyFinder(registry.Cmdr.Util.DictionaryKeys(registry:GetStore("vars_used") or {}))

			return find(text)
		end;

		Validate = function(text)
			for _, pattern in ipairs(VALID_STORED_KEY_NAME_PATTERNS) do
				if text:match(pattern) then
					return true
				end
			end

			return false, "Key names must start with an optional modifier: . $ or $. and must begin with a letter."
		end;

		Parse = function(text)
			return text
		end;
	}
	registry:RegisterType("storedKey", storedKeyType)
	registry:RegisterType("storedKeys", Util.MakeListableType(storedKeyType))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="368">
                <Properties>
                  <string name="Name">Team</string>
                  <string name="Source">local Teams = game:GetService("Teams")
local Util = require(script.Parent.Parent.Shared.Util)

local teamType = {
	Transform = function (text)
		local findTeam = Util.MakeFuzzyFinder(Teams:GetTeams())

		return findTeam(text)
	end;

	Validate = function (teams)
		return #teams &gt; 0, "No team with that name could be found."
	end;

	Autocomplete = function (teams)
		return Util.GetNames(teams)
	end;

	Parse = function (teams)
		return teams[1];
	end;
}

local teamPlayersType = {
	Listable = true;
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1]:GetPlayers()
	end;
}

local teamColorType = {
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1].TeamColor
	end;
}

return function (cmdr)
	cmdr:RegisterType("team", teamType)
	cmdr:RegisterType("teams", Util.MakeListableType(teamType))

	cmdr:RegisterType("teamPlayers", teamPlayersType)

	cmdr:RegisterType("teamColor", teamColorType)
	cmdr:RegisterType("teamColors", Util.MakeListableType(teamColorType))
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="369">
                <Properties>
                  <string name="Name">Type</string>
                  <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

return function (cmdr)
	local typeType = {
		Transform = function (text)
			local findCommand = Util.MakeFuzzyFinder(cmdr:GetTypeNames())

			return findCommand(text)
		end;

		Validate = function (commands)
			return #commands &gt; 0, "No type with that name could be found."
		end;

		Autocomplete = function (commands)
			return commands
		end;

		Parse = function (commands)
			return commands[1]
		end;
	}

	cmdr:RegisterType("type", typeType)
	cmdr:RegisterType("types", Util.MakeListableType(typeType))
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="370">
                <Properties>
                  <string name="Name">URL</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local storedKeyType = {
	Validate = function(text)
		if text:match("^https?://.+$") then
			return true
		end

		return false, "URLs must begin with http:// or https://"
	end;

	Parse = function(text)
		return text
	end;
}

return function (cmdr)
	cmdr:RegisterType("url", storedKeyType)
	cmdr:RegisterType("urls", Util.MakeListableType(storedKeyType))
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="371">
                <Properties>
                  <string name="Name">UserInput</string>
                  <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local combinedInputEnums = Enum.UserInputType:GetEnumItems()

for _, e in pairs(Enum.KeyCode:GetEnumItems()) do
	combinedInputEnums[#combinedInputEnums + 1] = e
end

local userInputType = {
	Transform = function (text)
		local findEnum = Util.MakeFuzzyFinder(combinedInputEnums)

		return findEnum(text)
	end;

	Validate = function (enums)
		return #enums &gt; 0
	end;

	Autocomplete = function (enums)
		return Util.GetNames(enums)
	end;

	Parse = function (enums)
		return enums[1];
	end;
}

return function (cmdr)
	cmdr:RegisterType("userInput", userInputType)
	cmdr:RegisterType("userInputs", Util.MakeListableType(userInputType))
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="372">
                <Properties>
                  <string name="Name">Vector</string>
                  <string name="Source">local Util = require(script.Parent.Parent.Shared.Util)

local function validateVector(value, i)
	if value == nil then
		return false, ("Invalid or missing number at position %d in Vector type."):format(i)
	end

	return true
end

local vector3Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector3.new;
	Length = 3;
})

local vector2Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector2.new;
	Length = 2;
})

return function (cmdr)
	cmdr:RegisterType("vector3", vector3Type)
	cmdr:RegisterType("vector3s", Util.MakeListableType(vector3Type))

	cmdr:RegisterType("vector2", vector2Type)
	cmdr:RegisterType("vector2s", Util.MakeListableType(vector2Type))
end</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="373">
              <Properties>
                <string name="Name">CmdrClient</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Shared = script:WaitForChild("Shared")
local Util = require(Shared:WaitForChild("Util"))

if RunService:IsClient() == false then
	error("Server scripts cannot require the client library. Please require the server library to use Cmdr in your own code.")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = script;
		RemoteFunction = script:WaitForChild("CmdrFunction");
		RemoteEvent = script:WaitForChild("CmdrEvent");
		ActivationKeys = {[Enum.KeyCode.F2] = true};
		Enabled = true;
		MashToEnable = false;
		ActivationUnlocksMouse = false;
		HideOnLostFocus = true;
		PlaceName = "Cmdr";
		Util = Util;
		Events = {};
	}, {
		-- This sucks, and may be redone or removed
		-- Proxies dispatch methods on to main Cmdr object
		__index = function (self, k)
			local r = self.Dispatcher[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Dispatcher, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(Shared.Dispatcher)(Cmdr)
end

if StarterGui:WaitForChild("Cmdr") and wait() and Player:WaitForChild("PlayerGui"):FindFirstChild("Cmdr") == nil then
	StarterGui.Cmdr:Clone().Parent = Player.PlayerGui
end

local Interface = require(script.CmdrInterface)(Cmdr)

--- Sets a list of keyboard keys (Enum.KeyCode) that can be used to open the commands menu
function Cmdr:SetActivationKeys (keysArray)
	self.ActivationKeys = Util.MakeDictionary(keysArray)
end

--- Sets the place name label on the interface
function Cmdr:SetPlaceName (name)
	self.PlaceName = name
	Interface.Window:UpdateLabel()
end

--- Sets whether or not the console is enabled
function Cmdr:SetEnabled (enabled)
	self.Enabled = enabled
end

--- Sets if activation will free the mouse.
function Cmdr:SetActivationUnlocksMouse (enabled)
	self.ActivationUnlocksMouse = enabled
end

--- Shows Cmdr window
function Cmdr:Show ()
	if not self.Enabled then
		return
	end

	Interface.Window:Show()
end

--- Hides Cmdr window
function Cmdr:Hide ()
	Interface.Window:Hide()
end

--- Toggles Cmdr window
function Cmdr:Toggle ()
	if not self.Enabled then
		return self:Hide()
	end

	Interface.Window:SetVisible(not Interface.Window:IsVisible())
end

--- Enables the "Mash to open" feature
function Cmdr:SetMashToEnable(isEnabled)
	self.MashToEnable = isEnabled

	if isEnabled then
		self:SetEnabled(false)
	end
end

--- Sets the hide on 'lost focus' feature.
function Cmdr:SetHideOnLostFocus(enabled)
	self.HideOnLostFocus = enabled
end

--- Sets the handler for a certain event type
function Cmdr:HandleEvent(name, callback)
	self.Events[name] = callback
end

-- Only register when we aren't in studio because don't want to overwrite what the server portion did
if RunService:IsServer() == false then
	Cmdr.Registry:RegisterTypesIn(script:WaitForChild("Types"))
	Cmdr.Registry:RegisterCommandsIn(script:WaitForChild("Commands"))
end

-- Hook up event listener
Cmdr.RemoteEvent.OnClientEvent:Connect(function(name, ...)
	if Cmdr.Events[name] then
		Cmdr.Events[name](...)
	end
end)

require(script.DefaultEventHandlers)(Cmdr)

return Cmdr
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="374">
                <Properties>
                  <string name="Name">CmdrInterface</string>
                  <string name="Source"><![CDATA[-- Here be dragons

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function (Cmdr)
	local Util = Cmdr.Util

	local Window = require(script:WaitForChild("Window"))
	Window.Cmdr = Cmdr

	local AutoComplete = require(script:WaitForChild("AutoComplete"))(Cmdr)
	Window.AutoComplete = AutoComplete


	-- Sets the Window.ProcessEntry callback so that we can dispatch our commands out
	function Window.ProcessEntry(text)
		text = Util.TrimString(text)

		if #text == 0 then return end

		Window:AddLine(Window:GetLabel() .. " " .. text, Color3.fromRGB(255, 223, 93))

		Window:AddLine(Cmdr.Dispatcher:EvaluateAndRun(text, Player, {
			IsHuman = true
		}))
	end

	-- Sets the Window.OnTextChanged callback so we can update the auto complete
	function Window.OnTextChanged (text)
		local command = Cmdr.Dispatcher:Evaluate(text, Player, true)
		local arguments = Util.SplitString(text)
		local commandText = table.remove(arguments, 1)
		local atEnd = false
		if command then
			arguments = Util.MashExcessArguments(arguments, #command.Object.Args)

			atEnd = #arguments == #command.Object.Args
		end

		local entryComplete = commandText and #arguments > 0

		if text:sub(#text, #text):match("%s") and not atEnd then
			entryComplete = true
			arguments[#arguments + 1] = ""
		end

		if command and entryComplete then
			local commandValid, errorText = command:Validate()

			Window:SetIsValidInput(commandValid, ("Validation errors: %s"):format(errorText or ""))

			local acItems = {}

			local lastArgument = command:GetArgument(#arguments)
			if lastArgument then
				local typedText = lastArgument.TextSegmentInProgress

				local isPartial = false
				if lastArgument.RawSegmentsAreAutocomplete then
					for i, segment in ipairs(lastArgument.RawSegments) do
						acItems[i] = {segment, segment}
					end
				else
					local items, options = lastArgument:GetAutocomplete()
					options = options or {}
					isPartial = options.IsPartial or false

					for i, item in pairs(items) do
						acItems[i] = {typedText, item}
					end
				end

				local valid = true

				if #typedText > 0 then
					valid, errorText = lastArgument:Validate()
				end

				if not atEnd and valid then
					Window:HideInvalidState()
				end

				return AutoComplete:Show(acItems, {
					at = atEnd and #text - #typedText + (text:sub(#text, #text):match("%s") and -1 or 0);
					prefix = #lastArgument.RawSegments == 1 and lastArgument.Prefix or "";
					isLast = #command.Arguments == #command.ArgumentDefinitions and #typedText > 0;
					numArgs = #arguments;
					command = command;
					arg = lastArgument;
					name = lastArgument.Name .. (lastArgument.Required and "" or "?");
					type = lastArgument.Type.DisplayName;
					description = (valid == false and errorText) or lastArgument.Object.Description;
					invalid = not valid;
					isPartial = isPartial;
				})
			end
		elseif commandText and #arguments == 0 then
			Window:SetIsValidInput(true)
			local exactCommand = Cmdr.Registry:GetCommand(commandText)
			local exactMatch
			if exactCommand then
				exactMatch = {exactCommand.Name, exactCommand.Name, options = {
					name = exactCommand.Name;
					description = exactCommand.Description;
				}}

				local arg = exactCommand.Args and exactCommand.Args[1]

				if type(arg) == "function" then
					arg = arg(command)
				end

				if
					arg
					and (not arg.Optional
					and arg.Default == nil)
				then
					Window:SetIsValidInput(false, "This command has required arguments.")
					Window:HideInvalidState()
				end
			else
				Window:SetIsValidInput(false, ("%q is not a valid command name. Use the help command to see all available commands."):format(commandText))
			end

			local acItems = {exactMatch}
			for _, cmd in pairs(Cmdr.Registry:GetCommandNames()) do
				if commandText:lower() == cmd:lower():sub(1, #commandText) and (exactMatch == nil or exactMatch[1] ~= commandText) then
					local commandObject = Cmdr.Registry:GetCommand(cmd)
					acItems[#acItems + 1] = {commandText, cmd, options = {
						name = commandObject.Name;
						description = commandObject.Description;
					}}
				end
			end

			return AutoComplete:Show(acItems)
		end

		Window:SetIsValidInput(false, "Use the help command to see all available commands.")
		AutoComplete:Hide()
	end

	Window:UpdateLabel()
	Window:UpdateWindowHeight()

	return {
		Window = Window;
		AutoComplete = AutoComplete;
	}
end
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="375">
                  <Properties>
                    <string name="Name">AutoComplete</string>
                    <string name="Source"><![CDATA[-- luacheck: ignore 212
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function(Cmdr)
	local AutoComplete = {
		Items = {},
		ItemOptions = {},
		SelectedItem = 0,
	}

	local Util = Cmdr.Util

	local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Autocomplete")
	local AutoItem = Gui:WaitForChild("TextButton")
	local Title = Gui:WaitForChild("Title")
	local Description = Gui:WaitForChild("Description")
	local Entry = Gui.Parent:WaitForChild("Frame"):WaitForChild("Entry")
	AutoItem.Parent = nil

	local defaultBarThickness = Gui.ScrollBarThickness

	-- Helper function that sets text and resizes labels
	local function SetText(obj, textObj, text, sizeFromContents)
		obj.Visible = text ~= nil
		textObj.Text = text or ""

		if sizeFromContents then
			textObj.Size = UDim2.new(
				0,
				Util.GetTextSize(text or "", textObj, Vector2.new(1000, 1000), 1, 0).X,
				obj.Size.Y.Scale,
				obj.Size.Y.Offset
			)
		end
	end

	local function UpdateContainerSize()
		Gui.Size = UDim2.new(
			0,
			math.max(Title.Field.TextBounds.X + Title.Field.Type.TextBounds.X, Gui.Size.X.Offset),
			0,
			math.min(Gui.UIListLayout.AbsoluteContentSize.Y, Gui.Parent.AbsoluteSize.Y - Gui.AbsolutePosition.Y - 10)
		)
	end

	-- Update the info display (Name, type, and description) based on given options.
	local function UpdateInfoDisplay(options)
		-- Update the objects' text and sizes
		SetText(Title, Title.Field, options.name, true)
		SetText(
			Title.Field.Type,
			Title.Field.Type,
			options.type and ": " .. options.type:sub(1, 1):upper() .. options.type:sub(2)
		)
		SetText(Description, Description.Label, options.description)

		Description.Label.TextColor3 = options.invalid and Color3.fromRGB(255, 73, 73) or Color3.fromRGB(255, 255, 255)
		Description.Size = UDim2.new(1, 0, 0, 40)

		-- Flow description text
		while not Description.Label.TextFits do
			Description.Size = Description.Size + UDim2.new(0, 0, 0, 2)

			if Description.Size.Y.Offset > 500 then
				break
			end
		end

		-- Update container
		task.wait()
		Gui.UIListLayout:ApplyLayout()
		UpdateContainerSize()
		Gui.ScrollBarThickness = defaultBarThickness
	end

	--- Shows the auto complete menu with the given list and possible options
	-- item = {typedText, suggestedText, options?=options}
	-- The options table is optional. `at` should only be passed into AutoComplete::Show
	-- name, type, and description may be passed in an options dictionary inside the items as well
	-- options.at?: the character index at which to show the menu
	-- options.name?: The name to display in the info box
	-- options.type?: The type to display in the info box
	-- options.prefix?: The current type prefix (%Team)
	-- options.description?: The description for the currently active info box
	-- options.invalid?: If true, description is shown in red.
	-- options.isLast?: If true, auto complete won't keep going after this argument.
	function AutoComplete:Show(items, options)
		options = options or {}

		-- Remove old options.
		for _, item in pairs(self.Items) do
			if item.gui then
				item.gui:Destroy()
			end
		end

		-- Reset state
		self.SelectedItem = 1
		self.Items = items
		self.Prefix = options.prefix or ""
		self.LastItem = options.isLast or false
		self.Command = options.command
		self.Arg = options.arg
		self.NumArgs = options.numArgs
		self.IsPartial = options.isPartial

		-- Generate the new option labels
		local autocompleteWidth = 200

		Gui.ScrollBarThickness = 0

		for i, item in pairs(self.Items) do
			local leftText = item[1]
			local rightText = item[2]

			local btn = AutoItem:Clone()
			btn.Name = leftText .. rightText
			btn.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1

			local start, stop = string.find(rightText:lower(), leftText:lower(), 1, true)
			btn.Typed.Text = string.rep(" ", start - 1) .. leftText
			btn.Suggest.Text = string.sub(rightText, 0, start - 1)
				.. string.rep(" ", #leftText)
				.. string.sub(rightText, stop + 1)


			btn.Parent = Gui
			btn.LayoutOrder = i

			local maxBounds = math.max(btn.Typed.TextBounds.X, btn.Suggest.TextBounds.X) + 20
			if maxBounds > autocompleteWidth then
				autocompleteWidth = maxBounds
			end

			item.gui = btn
		end

		Gui.UIListLayout:ApplyLayout()

		-- Todo: Use TextService to find accurate position for auto complete box
		local text = Entry.TextBox.Text
		local words = Util.SplitString(text)
		if text:sub(#text, #text) == " " and not options.at then
			words[#words + 1] = "e"
		end
		table.remove(words, #words)
		local extra = (options.at and options.at or (#table.concat(words, " ") + 1)) * 7

		-- Update the auto complete container
		Gui.Position =
			UDim2.new(0, Entry.TextBox.AbsolutePosition.X - 10 + extra, 0, Entry.TextBox.AbsolutePosition.Y + 30)
		Gui.Size = UDim2.new(0, autocompleteWidth, 0, Gui.UIListLayout.AbsoluteContentSize.Y)
		Gui.Visible = true

		-- Finally, update thge info display
		UpdateInfoDisplay(self.Items[1] and self.Items[1].options or options)
	end

	--- Returns the selected item in the auto complete
	function AutoComplete:GetSelectedItem()
		if Gui.Visible == false then
			return nil
		end

		return AutoComplete.Items[AutoComplete.SelectedItem]
	end

	--- Hides the auto complete
	function AutoComplete:Hide()
		Gui.Visible = false
	end

	--- Returns if the menu is visible
	function AutoComplete:IsVisible()
		return Gui.Visible
	end

	--- Changes the user's item selection by the given delta
	function AutoComplete:Select(delta)
		if not Gui.Visible then
			return
		end

		self.SelectedItem = self.SelectedItem + delta

		if self.SelectedItem > #self.Items then
			self.SelectedItem = 1
		elseif self.SelectedItem < 1 then
			self.SelectedItem = #self.Items
		end

		for i, item in pairs(self.Items) do
			item.gui.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1
		end

		Gui.CanvasPosition = Vector2.new(
			0,
			math.max(
				0,
				Title.Size.Y.Offset
					+ Description.Size.Y.Offset
					+ self.SelectedItem * AutoItem.Size.Y.Offset
					- Gui.Size.Y.Offset
			)
		)

		if self.Items[self.SelectedItem] and self.Items[self.SelectedItem].options then
			UpdateInfoDisplay(self.Items[self.SelectedItem].options or {})
		end
	end

	Gui.Parent:GetPropertyChangedSignal("AbsoluteSize"):Connect(UpdateContainerSize)

	return AutoComplete
end
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="376">
                  <Properties>
                    <string name="Name">Window</string>
                    <string name="Source"><![CDATA[-- Here be dragons
-- luacheck: ignore 212
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local WINDOW_MAX_HEIGHT = 300
local MOUSE_TOUCH_ENUM = { Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2, Enum.UserInputType.Touch }

--- Window handles the command bar GUI
local Window = {
	Valid = true,
	AutoComplete = nil,
	ProcessEntry = nil,
	OnTextChanged = nil,
	Cmdr = nil,
	HistoryState = nil,
}

local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Frame")
local Line = Gui:WaitForChild("Line")
local Entry = Gui:WaitForChild("Entry")

Line.Parent = nil

--- Update the text entry label
function Window:UpdateLabel()
	Entry.TextLabel.Text = Player.Name .. "@" .. self.Cmdr.PlaceName .. "$"
end

--- Get the text entry label
function Window:GetLabel()
	return Entry.TextLabel.Text
end

--- Recalculate the window height
function Window:UpdateWindowHeight()
	local windowHeight = Gui.UIListLayout.AbsoluteContentSize.Y
		+ Gui.UIPadding.PaddingTop.Offset
		+ Gui.UIPadding.PaddingBottom.Offset
	Gui.Size = UDim2.new(Gui.Size.X.Scale, Gui.Size.X.Offset, 0, math.clamp(windowHeight, 0, WINDOW_MAX_HEIGHT))
	Gui.CanvasPosition = Vector2.new(0, windowHeight)
end

--- Add a line to the command bar
function Window:AddLine(text, options)
	options = options or {}
	text = tostring(text)

	if typeof(options) == "Color3" then
		options = { Color = options }
	end

	if #text == 0 then
		Window:UpdateWindowHeight()
		return
	end

	local str = self.Cmdr.Util.EmulateTabstops(text or "nil", 8)

	local line = Line:Clone()
	line.Text = str
	line.TextColor3 = options.Color or line.TextColor3
	line.RichText = options.RichText or false
	line.Parent = Gui
end

--- Returns if the command bar is visible
function Window:IsVisible()
	return Gui.Visible
end

--- Sets the command bar visible or not
function Window:SetVisible(visible)
	Gui.Visible = visible

	if visible then
		self.PreviousChatWindowConfigurationEnabled = TextChatService.ChatWindowConfiguration.Enabled
		self.PreviousChatInputBarConfigurationEnabled = TextChatService.ChatInputBarConfiguration.Enabled
		TextChatService.ChatWindowConfiguration.Enabled = false
		TextChatService.ChatInputBarConfiguration.Enabled = false

		Entry.TextBox:CaptureFocus()
		self:SetEntryText("")

		if self.Cmdr.ActivationUnlocksMouse then
			self.PreviousMouseBehavior = UserInputService.MouseBehavior
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	else
		TextChatService.ChatWindowConfiguration.Enabled = if self.PreviousChatWindowConfigurationEnabled ~= nil then 
			self.PreviousChatWindowConfigurationEnabled else true
		TextChatService.ChatInputBarConfiguration.Enabled = if self.PreviousChatInputBarConfigurationEnabled ~= nil then 
			self.PreviousChatInputBarConfigurationEnabled else true

		Entry.TextBox:ReleaseFocus()
		self.AutoComplete:Hide()

		if self.PreviousMouseBehavior then
			UserInputService.MouseBehavior = self.PreviousMouseBehavior
			self.PreviousMouseBehavior = nil
		end
	end
end

--- Hides the command bar
function Window:Hide()
	return self:SetVisible(false)
end

--- Shows the command bar
function Window:Show()
	return self:SetVisible(true)
end

--- Sets the text in the command bar text box, and captures focus
function Window:SetEntryText(text)
	Entry.TextBox.Text = text

	if self:IsVisible() then
		Entry.TextBox:CaptureFocus()
		Entry.TextBox.CursorPosition = #text + 1
		Window:UpdateWindowHeight()
	end
end

--- Gets the text in the command bar text box
function Window:GetEntryText()
	return Entry.TextBox.Text:gsub("\t", "")
end

--- Sets whether the command is in a valid state or not.
-- Cannot submit if in invalid state.
function Window:SetIsValidInput(isValid, errorText)
	Entry.TextBox.TextColor3 = isValid and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 73, 73)
	self.Valid = isValid
	self._errorText = errorText
end

function Window:HideInvalidState()
	Entry.TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
end

--- Event handler for text box focus lost
function Window:LoseFocus(submit)
	local text = Entry.TextBox.Text

	self:ClearHistoryState()

	if Gui.Visible and not GuiService.MenuIsOpen then
		-- self:SetEntryText("")
		Entry.TextBox:CaptureFocus()
	elseif GuiService.MenuIsOpen and Gui.Visible then
		self:Hide()
	end

	if submit and self.Valid then
		wait()
		self:SetEntryText("")
		self.ProcessEntry(text)
	elseif submit then
		self:AddLine(self._errorText, Color3.fromRGB(255, 153, 153))
	end
end

function Window:TraverseHistory(delta)
	local history = self.Cmdr.Dispatcher:GetHistory()

	if self.HistoryState == nil then
		self.HistoryState = {
			Position = #history + 1,
			InitialText = self:GetEntryText(),
		}
	end

	self.HistoryState.Position = math.clamp(self.HistoryState.Position + delta, 1, #history + 1)

	self:SetEntryText(
		self.HistoryState.Position == #history + 1 and self.HistoryState.InitialText
			or history[self.HistoryState.Position]
	)
end

function Window:ClearHistoryState()
	self.HistoryState = nil
end

function Window:SelectVertical(delta)
	if self.AutoComplete:IsVisible() and not self.HistoryState then
		self.AutoComplete:Select(delta)
	else
		self:TraverseHistory(delta)
	end
end

local lastPressTime = 0
local pressCount = 0
--- Handles user input when the box is focused
function Window:BeginInput(input, gameProcessed)
	if GuiService.MenuIsOpen then
		self:Hide()
	end

	if gameProcessed and self:IsVisible() == false then
		return
	end

	if self.Cmdr.ActivationKeys[input.KeyCode] then -- Activate the command bar
		if self.Cmdr.MashToEnable and not self.Cmdr.Enabled then
			if tick() - lastPressTime < 1 then
				if pressCount >= 5 then
					return self.Cmdr:SetEnabled(true)
				else
					pressCount = pressCount + 1
				end
			else
				pressCount = 1
			end
			lastPressTime = tick()
		elseif self.Cmdr.Enabled then
			self:SetVisible(not self:IsVisible())
			wait()
			self:SetEntryText("")

			if GuiService.MenuIsOpen then -- Special case for menu getting stuck open (roblox bug)
				self:Hide()
			end
		end

		return
	end

	if self.Cmdr.Enabled == false or not self:IsVisible() then
		if self:IsVisible() then
			self:Hide()
		end

		return
	end

	if self.Cmdr.HideOnLostFocus and table.find(MOUSE_TOUCH_ENUM, input.UserInputType) then
		local ps = input.Position
		local ap = Gui.AbsolutePosition
		local as = Gui.AbsoluteSize
		if ps.X < ap.X or ps.X > ap.X + as.X or ps.Y < ap.Y or ps.Y > ap.Y + as.Y then
			self:Hide()
		end
	elseif input.KeyCode == Enum.KeyCode.Down then -- Auto Complete Down
		self:SelectVertical(1)
	elseif input.KeyCode == Enum.KeyCode.Up then -- Auto Complete Up
		self:SelectVertical(-1)
	elseif input.KeyCode == Enum.KeyCode.Return then -- Eat new lines
		wait()
		self:SetEntryText(self:GetEntryText():gsub("\n", ""):gsub("\r", ""))
	elseif input.KeyCode == Enum.KeyCode.Tab then -- Auto complete
		local item = self.AutoComplete:GetSelectedItem()
		local text = self:GetEntryText()
		if item and not (text:sub(#text, #text):match("%s") and self.AutoComplete.LastItem) then
			local replace = item[2]
			local newText
			local insertSpace = true
			local command = self.AutoComplete.Command

			if command then
				local lastArg = self.AutoComplete.Arg

				newText = command.Alias
				insertSpace = self.AutoComplete.NumArgs ~= #command.ArgumentDefinitions
					and self.AutoComplete.IsPartial == false

				local args = command.Arguments
				for i = 1, #args do
					local arg = args[i]
					local segments = arg.RawSegments
					if arg == lastArg then
						segments[#segments] = replace
					end

					local argText = arg.Prefix .. table.concat(segments, ",")

					-- Put auto completion options in quotation marks if they have a space
					if argText:find(" ") or argText == "" then
						argText = ("%q"):format(argText)
					end

					newText = ("%s %s"):format(newText, argText)

					if arg == lastArg then
						break
					end
				end
			else
				newText = replace
			end
			-- need to wait a frame so we can eat the \t
			wait()
			-- Update the text box
			self:SetEntryText(newText .. (insertSpace and " " or ""))
		else
			-- Still need to eat the \t even if there is no auto-complete to show
			wait()
			self:SetEntryText(self:GetEntryText())
		end
	else
		self:ClearHistoryState()
	end
end

-- Hook events
Entry.TextBox.FocusLost:Connect(function(submit)
	return Window:LoseFocus(submit)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	return Window:BeginInput(input, gameProcessed)
end)

Entry.TextBox:GetPropertyChangedSignal("Text"):Connect(function()
	Gui.CanvasPosition = Vector2.new(0, Gui.AbsoluteCanvasSize.Y)

	if Entry.TextBox.Text:match("\t") then -- Eat \t
		Entry.TextBox.Text = Entry.TextBox.Text:gsub("\t", "")
		return
	end
	if Window.OnTextChanged then
		return Window.OnTextChanged(Entry.TextBox.Text)
	end
end)

Gui.ChildAdded:Connect(function()
	task.defer(Window.UpdateWindowHeight)
end)

return Window
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="377">
                <Properties>
                  <string name="Name">DefaultEventHandlers</string>
                  <string name="Source">local StarterGui = game:GetService("StarterGui")
local Window = require(script.Parent.CmdrInterface.Window)

return function (Cmdr)
	Cmdr:HandleEvent("Message", function (text)
		StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = ("[Announcement] %s"):format(text);
			Color = Color3.fromRGB(249, 217, 56);
		})
	end)

	Cmdr:HandleEvent("AddLine", function (...)
		Window:AddLine(...)
	end)
end</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="378">
              <Properties>
                <string name="Name">CreateGui</string>
                <string name="Source"><![CDATA[return function()
	local Cmdr = Instance.new("ScreenGui")
	Cmdr.DisplayOrder = 1000
	Cmdr.Name = "Cmdr"
	Cmdr.ResetOnSpawn = false
	Cmdr.AutoLocalize = false

	local Frame = Instance.new("ScrollingFrame")
	Frame.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
	Frame.BackgroundTransparency = 0.4
	Frame.BorderSizePixel = 0
	Frame.CanvasSize = UDim2.new(0, 0, 0, 0)
	Frame.Name = "Frame"
	Frame.Position = UDim2.new(0.025, 0, 0, 25)
	Frame.ScrollBarThickness = 6
	Frame.ScrollingDirection = Enum.ScrollingDirection.Y
	Frame.Selectable = false
	Frame.Size = UDim2.new(0.95, 0, 0, 0)
	Frame.Visible = false
	Frame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	Frame.Parent = Cmdr

	local Autocomplete = Instance.new("ScrollingFrame")
	Autocomplete.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Autocomplete.BackgroundTransparency = 0.5
	Autocomplete.BorderSizePixel = 0
	Autocomplete.CanvasSize = UDim2.new(0, 0, 0, 0)
	Autocomplete.Name = "Autocomplete"
	Autocomplete.Position = UDim2.new(0, 167, 0, 75)
	Autocomplete.ScrollBarThickness = 6
	Autocomplete.ScrollingDirection = Enum.ScrollingDirection.Y
	Autocomplete.Selectable = false
	Autocomplete.Size = UDim2.new(0, 200, 0, 200)
	Autocomplete.Visible = false
	Autocomplete.AutomaticCanvasSize = Enum.AutomaticSize.Y
	Autocomplete.Parent = Cmdr

	local UIListLayout = Instance.new("UIListLayout")
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.Parent = Frame

	local Line = Instance.new("TextBox")
	Line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Line.BackgroundTransparency = 1
	Line.Font = Enum.Font.Code
	Line.Name = "Line"
	Line.Size = UDim2.new(1, 0, 0, 20)
	Line.AutomaticSize = Enum.AutomaticSize.Y
	Line.TextColor3 = Color3.fromRGB(255, 255, 255)
	Line.TextSize = 14
	Line.TextXAlignment = Enum.TextXAlignment.Left
	Line.TextEditable = false
	Line.ClearTextOnFocus = false
	Line.Parent = Frame

	local UIPadding = Instance.new("UIPadding")
	UIPadding.PaddingBottom = UDim.new(0, 10)
	UIPadding.PaddingLeft = UDim.new(0, 10)
	UIPadding.PaddingRight = UDim.new(0, 10)
	UIPadding.PaddingTop = UDim.new(0, 10)
	UIPadding.Parent = Frame

	local Entry = Instance.new("Frame")
	Entry.BackgroundTransparency = 1
	Entry.LayoutOrder = 999999999
	Entry.Name = "Entry"
	Entry.Size = UDim2.new(1, 0, 0, 20)
	Entry.Parent = Frame

	local UIListLayout2 = Instance.new("UIListLayout")
	UIListLayout2.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout2.Parent = Autocomplete

	local Title = Instance.new("Frame")
	Title.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Title.BackgroundTransparency = 0.2
	Title.BorderSizePixel = 0
	Title.LayoutOrder = -2
	Title.Name = "Title"
	Title.Size = UDim2.new(1, 0, 0, 40)
	Title.Parent = Autocomplete

	local Description = Instance.new("Frame")
	Description.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Description.BackgroundTransparency = 0.2
	Description.BorderSizePixel = 0
	Description.LayoutOrder = -1
	Description.Name = "Description"
	Description.Size = UDim2.new(1, 0, 0, 20)
	Description.Parent = Autocomplete

	local TextButton = Instance.new("TextButton")
	TextButton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	TextButton.BackgroundTransparency = 0.5
	TextButton.BorderSizePixel = 0
	TextButton.Font = Enum.Font.Code
	TextButton.Size = UDim2.new(1, 0, 0, 30)
	TextButton.Text = ""
	TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextButton.TextSize = 14
	TextButton.TextXAlignment = Enum.TextXAlignment.Left
	TextButton.Parent = Autocomplete

	local UIListLayout3 = Instance.new("UIListLayout")
	UIListLayout3.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout3.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout3.Padding = UDim.new(0, 7)
	UIListLayout3.Parent = Entry

	local TextBox = Instance.new("TextBox")
	TextBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.BackgroundTransparency = 1
	TextBox.ClearTextOnFocus = false
	TextBox.Font = Enum.Font.Code
	TextBox.LayoutOrder = 999999999
	TextBox.Position = UDim2.new(0, 140, 0, 0)
	TextBox.Size = UDim2.new(1, 0, 0, 20)
	TextBox.Text = "x"
	TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.TextSize = 14
	TextBox.TextXAlignment = Enum.TextXAlignment.Left
	TextBox.Selectable = false
	TextBox.Parent = Entry

	local TextLabel = Instance.new("TextLabel")
	TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.BackgroundTransparency = 1
	TextLabel.Font = Enum.Font.Code
	TextLabel.Size = UDim2.new(0, 0, 0, 20)
	TextLabel.AutomaticSize = Enum.AutomaticSize.X
	TextLabel.Text = ""
	TextLabel.TextColor3 = Color3.fromRGB(255, 223, 93)
	TextLabel.TextSize = 14
	TextLabel.TextXAlignment = Enum.TextXAlignment.Left
	TextLabel.Parent = Entry

	local Field = Instance.new("TextLabel")
	Field.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Field.BackgroundTransparency = 1
	Field.Font = Enum.Font.SourceSansBold
	Field.Name = "Field"
	Field.Size = UDim2.new(0, 37, 1, 0)
	Field.Text = "from"
	Field.TextColor3 = Color3.fromRGB(255, 255, 255)
	Field.TextSize = 20
	Field.TextXAlignment = Enum.TextXAlignment.Left
	Field.Parent = Title

	local UIPadding2 = Instance.new("UIPadding")
	UIPadding2.PaddingLeft = UDim.new(0, 10)
	UIPadding2.Parent = Title

	local Label = Instance.new("TextLabel")
	Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.SourceSansLight
	Label.Name = "Label"
	Label.Size = UDim2.new(1, 0, 1, 0)
	Label.Text = "The players to teleport. The players to teleport. The players to teleport. The players to teleport. "
	Label.TextColor3 = Color3.fromRGB(255, 255, 255)
	Label.TextSize = 16
	Label.TextWrapped = true
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Top
	Label.Parent = Description

	local UIPadding3 = Instance.new("UIPadding")
	UIPadding3.PaddingBottom = UDim.new(0, 10)
	UIPadding3.PaddingLeft = UDim.new(0, 10)
	UIPadding3.PaddingRight = UDim.new(0, 10)
	UIPadding3.Parent = Description

	local Typed = Instance.new("TextLabel")
	Typed.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Typed.BackgroundTransparency = 1
	Typed.Font = Enum.Font.Code
	Typed.Name = "Typed"
	Typed.Size = UDim2.new(1, 0, 1, 0)
	Typed.Text = "Lab"
	Typed.TextColor3 = Color3.fromRGB(131, 222, 255)
	Typed.TextSize = 14
	Typed.TextXAlignment = Enum.TextXAlignment.Left
	Typed.Parent = TextButton

	local UIPadding4 = Instance.new("UIPadding")
	UIPadding4.PaddingLeft = UDim.new(0, 10)
	UIPadding4.Parent = TextButton

	local Suggest = Instance.new("TextLabel")
	Suggest.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.BackgroundTransparency = 1
	Suggest.Font = Enum.Font.Code
	Suggest.Name = "Suggest"
	Suggest.Size = UDim2.new(1, 0, 1, 0)
	Suggest.Text = "   el"
	Suggest.TextColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.TextSize = 14
	Suggest.TextXAlignment = Enum.TextXAlignment.Left
	Suggest.Parent = TextButton

	local Type = Instance.new("TextLabel")
	Type.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Type.BackgroundTransparency = 1
	Type.BorderColor3 = Color3.fromRGB(255, 153, 153)
	Type.Font = Enum.Font.SourceSans
	Type.Name = "Type"
	Type.Position = UDim2.new(1, 0, 0, 0)
	Type.Size = UDim2.new(0, 0, 1, 0)
	Type.Text = ": Players"
	Type.TextColor3 = Color3.fromRGB(255, 255, 255)
	Type.TextSize = 15
	Type.TextXAlignment = Enum.TextXAlignment.Left
	Type.Parent = Field

	Cmdr.Parent = game:GetService("StarterGui")
	return Cmdr
end
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="379">
              <Properties>
                <string name="Name">Initialize</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local CreateGui = require(script.Parent.CreateGui)

--- Handles initial preparation of the game server-side.
return function (cmdr)
	local ReplicatedRoot, RemoteFunction, RemoteEvent

	local function Create (class, name, parent)
		local object = Instance.new(class)
		object.Name = name
		object.Parent = parent or ReplicatedRoot

		return object
	end

	ReplicatedRoot = script.Parent.CmdrClient
	ReplicatedRoot.Parent = ReplicatedStorage

	RemoteFunction = Create("RemoteFunction", "CmdrFunction")
	RemoteEvent = Create("RemoteEvent", "CmdrEvent")

	Create("Folder", "Commands")
	Create("Folder", "Types")

	script.Parent.Shared.Parent = ReplicatedRoot

	cmdr.ReplicatedRoot = ReplicatedRoot
	cmdr.RemoteFunction = RemoteFunction
	cmdr.RemoteEvent = RemoteEvent

	cmdr:RegisterTypesIn(script.Parent.BuiltInTypes)

	script.Parent.BuiltInTypes:Destroy()
	script.Parent.BuiltInCommands.Name = "Server commands"

	if StarterGui:FindFirstChild("Cmdr") == nil then
		CreateGui()
	end
end
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="380">
              <Properties>
                <string name="Name">Shared</string>
              </Properties>
              <Item class="ModuleScript" referent="381">
                <Properties>
                  <string name="Name">Argument</string>
                  <string name="Source"><![CDATA[local Util = require(script.Parent.Util)

local function unescapeOperators(text)
	for _, operator in ipairs({"%.", "%?", "%*", "%*%*"}) do
		text = text:gsub("\\" .. operator, operator:gsub("%%", ""))
	end

	return text
end

local Argument = {}
Argument.__index = Argument

--- Returns a new ArgumentContext, an object that handles parsing and validating arguments
function Argument.new (command, argumentObject, value)
	local self = {
		Command = command; -- The command that owns this argument
		Type = nil; -- The type definition
		Name = argumentObject.Name; -- The name for this specific argument
		Object = argumentObject; -- The raw ArgumentObject (definition)
		Required = argumentObject.Default == nil and argumentObject.Optional ~= true; -- If the argument is required or not.
		Executor = command.Executor; -- The player who is running the command
		RawValue = value; -- The raw, unparsed value
		RawSegments = {}; -- The raw, unparsed segments (if the raw value was comma-sep)
		TransformedValues = {}; -- The transformed value (generated later)
		Prefix = ""; -- The prefix for this command (%Team)
		TextSegmentInProgress = ""; -- The text of the raw segment the user is currently typing.
		RawSegmentsAreAutocomplete = false;
	}

	if type(argumentObject.Type) == "table" then
		self.Type = argumentObject.Type
	else
		local parsedType, parsedRawValue, prefix = Util.ParsePrefixedUnionType(
			command.Cmdr.Registry:GetTypeName(argumentObject.Type),
			value
		)

		self.Type = command.Dispatcher.Registry:GetType(parsedType)
		self.RawValue = parsedRawValue
		self.Prefix = prefix

		if self.Type == nil then
			error(string.format("%s has an unregistered type %q", self.Name or "<none>", parsedType or "<none>"))
		end
	end

	setmetatable(self, Argument)

	self:Transform()

	return self
end

function Argument:GetDefaultAutocomplete()
	if self.Type.Autocomplete then
		local strings, options = self.Type.Autocomplete(self:TransformSegment(""))
		return strings, options or {}
	end

	return {}
end

--- Calls the transform function on this argument.
-- The return value(s) from this function are passed to all of the other argument methods.
-- Called automatically at instantiation
function Argument:Transform()
	if #self.TransformedValues ~= 0 then
		return
	end

	local rawValue = self.RawValue
	if self.Type.ArgumentOperatorAliases then
		rawValue = self.Type.ArgumentOperatorAliases[rawValue] or rawValue
	end

	if rawValue == "." and self.Type.Default then
		rawValue = self.Type.Default(self.Executor) or ""
		self.RawSegmentsAreAutocomplete = true
	end

	if rawValue == "?" and self.Type.Autocomplete then
		local strings, options = self:GetDefaultAutocomplete()

		if not options.IsPartial and #strings > 0 then
			rawValue = strings[math.random(1, #strings)]
			self.RawSegmentsAreAutocomplete = true
		end

	end

	if self.Type.Listable and #self.RawValue > 0 then
		local randomMatch = rawValue:match("^%?(%d+)$")
		if randomMatch then
			local maxSize = tonumber(randomMatch)

			if maxSize and maxSize > 0 then
				local items = {}
				local remainingItems, options = self:GetDefaultAutocomplete()

				if not options.IsPartial and #remainingItems > 0 then
					for _ = 1, math.min(maxSize, #remainingItems) do
						table.insert(items, table.remove(remainingItems, math.random(1, #remainingItems)))
					end

					rawValue = table.concat(items, ",")
					self.RawSegmentsAreAutocomplete = true
				end
			end
		elseif rawValue == "*" or rawValue == "**" then
			local strings, options = self:GetDefaultAutocomplete()

			if not options.IsPartial and #strings > 0 then
				if rawValue == "**" and self.Type.Default then
					local defaultString = self.Type.Default(self.Executor) or ""

					for i, string in ipairs(strings) do
						if string == defaultString then
							table.remove(strings, i)
						end
					end
				end

				rawValue = table.concat(
					strings,
					","
				)
				self.RawSegmentsAreAutocomplete = true
			end
		end

		rawValue = unescapeOperators(rawValue)

		local rawSegments = Util.SplitStringSimple(rawValue, ",")

		if #rawSegments == 0 then
			rawSegments = {""}
		end

		if rawValue:sub(#rawValue, #rawValue) == "," then
			rawSegments[#rawSegments + 1] = "" -- makes auto complete tick over right after pressing ,
		end

		for i, rawSegment in ipairs(rawSegments) do
			self.RawSegments[i] = rawSegment
			self.TransformedValues[i] = { self:TransformSegment(rawSegment) }
		end

		self.TextSegmentInProgress = rawSegments[#rawSegments]
	else
		rawValue = unescapeOperators(rawValue)

		self.RawSegments[1] = unescapeOperators(rawValue)
		self.TransformedValues[1] = { self:TransformSegment(rawValue) }
		self.TextSegmentInProgress = self.RawValue
	end
end

function Argument:TransformSegment(rawSegment)
	if self.Type.Transform then
		return self.Type.Transform(rawSegment, self.Executor)
	else
		return rawSegment
	end
end

--- Returns whatever the Transform method gave us.
function Argument:GetTransformedValue(segment)
	return unpack(self.TransformedValues[segment])
end

--- Validates that the argument will work without any type errors.
function Argument:Validate(isFinal)
	if self.RawValue == nil or #self.RawValue == 0 and self.Required == false then
		return true
	end

	if self.Required and (self.RawSegments[1] == nil or #self.RawSegments[1] == 0) then
		return false, "This argument is required."
	end

	if self.Type.Validate or self.Type.ValidateOnce then
		for i = 1, #self.TransformedValues do
			if self.Type.Validate then
				local valid, errorText = self.Type.Validate(self:GetTransformedValue(i))

				if not valid then
					return valid, errorText or "Invalid value"
				end
			end

			if isFinal and self.Type.ValidateOnce then
				local validOnce, errorTextOnce = self.Type.ValidateOnce(self:GetTransformedValue(i))

				if not validOnce then
					return validOnce, errorTextOnce
				end
			end
		end

		return true
	else
		return true
	end
end

--- Gets a list of all possible values that could match based on the current value.
function Argument:GetAutocomplete()
	if self.Type.Autocomplete then
		return self.Type.Autocomplete(self:GetTransformedValue(#self.TransformedValues))
	else
		return {}
	end
end

function Argument:ParseValue(i)
	if self.Type.Parse then
		return self.Type.Parse(self:GetTransformedValue(i))
	else
		return self:GetTransformedValue(i)
	end
end

--- Returns the final value of the argument.
function Argument:GetValue()
	if #self.RawValue == 0 and not self.Required and self.Object.Default ~= nil then
		return self.Object.Default
	end

	if not self.Type.Listable then
		return self:ParseValue(1)
	end

	local values = {}

	for i = 1, #self.TransformedValues do
		local parsedValue = self:ParseValue(i)

		if type(parsedValue) ~= "table" then
			error(("Listable types must return a table from Parse (%s)"):format(self.Type.Name))
		end

		for _, value in pairs(parsedValue) do
			values[value] = true -- Put them into a dictionary to ensure uniqueness
		end
	end

	local valueArray = {}

	for value in pairs(values) do
		valueArray[#valueArray + 1] = value
	end

	return valueArray
end

return Argument
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="382">
                <Properties>
                  <string name="Name">Command</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Argument = require(script.Parent.Argument)

local IsServer = RunService:IsServer()

local Command = {}
Command.__index = Command

--- Returns a new CommandContext, an object which is created for every command validation.
-- This is also what's passed as the context to the "Run" functions in commands
function Command.new (options)
	local self = {
		Dispatcher = options.Dispatcher; -- The dispatcher that created this command context
		Cmdr = options.Dispatcher.Cmdr; -- A quick reference to Cmdr for command context
		Name = options.CommandObject.Name; -- The command name (not alias)
		RawText = options.Text; -- The raw text used to trigger this command
		Object = options.CommandObject; -- The command object (definition)
		Group = options.CommandObject.Group; -- The group this command is in
		State = {}; -- A table which will hold any custom command state information
		Aliases = options.CommandObject.Aliases;
		Alias = options.Alias; -- The command name that was used
		Description = options.CommandObject.Description;
		Executor = options.Executor; -- The player who ran the command
		ArgumentDefinitions = options.CommandObject.Args; -- The argument definitions from the command definition
		RawArguments = options.Arguments; -- Array of strings which are the unparsed values for the arguments
		Arguments = {}; -- A table which will hold ArgumentContexts for each argument
		Data = options.Data; -- A special container for any additional data the command needs to collect from the client
		Response = nil; -- Will be set at the very end when the command is run and a string is returned from the Run function.
	}

	setmetatable(self, Command)

	return self
end

--- Parses all of the command arguments into ArgumentContexts
-- Called by the command dispatcher automatically
-- allowIncompleteArguments: if true, will not throw an error for missing arguments
function Command:Parse (allowIncompleteArguments)
	local hadOptional = false
	for i, definition in ipairs(self.ArgumentDefinitions) do
		if type(definition) == "function" then
			definition = definition(self)

			if definition == nil then
				break
			end
		end

		local required = (definition.Default == nil and definition.Optional ~= true)

		if required and hadOptional then
			error(("Command %q: Required arguments cannot occur after optional arguments."):format(self.Name))
		elseif not required then
			hadOptional = true
		end

		if self.RawArguments[i] == nil and required and allowIncompleteArguments ~= true then
			return false, ("Required argument #%d %s is missing."):format(i, definition.Name)
		elseif self.RawArguments[i] or allowIncompleteArguments then
			self.Arguments[i] = Argument.new(self, definition, self.RawArguments[i] or "")
		end
	end

	return true
end

--- Validates that all of the arguments are in a valid state.
-- This must be called before :Run() is called.
-- Returns boolean (true if ok), errorText
function Command:Validate (isFinal)
	self._Validated = true
	local errorText = ""
	local success = true

	for i, arg in pairs(self.Arguments) do
		local argSuccess, argErrorText = arg:Validate(isFinal)

		if not argSuccess then
			success = false
			errorText = ("%s; #%d %s: %s"):format(errorText, i, arg.Name, argErrorText or "error")
		end
	end

	return success, errorText:sub(3)
end

--- Returns the last argument that has a value.
-- Useful for getting the autocomplete for the argument the user is working on.
function Command:GetLastArgument()
	for i = #self.Arguments, 1, -1 do
		if self.Arguments[i].RawValue then
			return self.Arguments[i]
		end
	end
end

--- Returns a table containing the parsed values for all of the arguments.
function Command:GatherArgumentValues ()
	local values = {}

	for i = 1, #self.ArgumentDefinitions do
		local arg = self.Arguments[i]
		if arg then
			values[i] = arg:GetValue()
		elseif type(self.ArgumentDefinitions[i]) == "table" then
			values[i] = self.ArgumentDefinitions[i].Default
		end
	end

	return values, #self.ArgumentDefinitions
end

--- Runs the command. Handles dispatching to the server if necessary.
-- Command:Validate() must be called before this is called or it will throw.
function Command:Run ()
	if self._Validated == nil then
		error("Must validate a command before running.")
	end

	local beforeRunHook = self.Dispatcher:RunHooks("BeforeRun", self)
	if beforeRunHook then
		return beforeRunHook
	end

	if not IsServer and self.Object.Data and self.Data == nil then
		local values, length = self:GatherArgumentValues()
		self.Data = self.Object.Data(self, unpack(values, 1, length))
	end

	if not IsServer and self.Object.ClientRun then
		local values, length = self:GatherArgumentValues()
		self.Response = self.Object.ClientRun(self, unpack(values, 1, length))
	end

	if self.Response == nil then
		if self.Object.Run then -- We can just Run it here on this machine
			local values, length = self:GatherArgumentValues()
			self.Response = self.Object.Run(self, unpack(values, 1, length))

		elseif IsServer then -- Uh oh, we're already on the server and there's no Run function.
			if self.Object.ClientRun then
				warn(self.Name, "command fell back to the server because ClientRun returned nil, but there is no server implementation! Either return a string from ClientRun, or create a server implementation for this command.")
			else
				warn(self.Name, "command has no implementation!")
			end

			self.Response = "No implementation."
		else -- We're on the client, so we send this off to the server to let the server see what it can do with it.
			self.Response = self.Dispatcher:Send(self.RawText, self.Data)
		end
	end

	local afterRunHook = self.Dispatcher:RunHooks("AfterRun", self)
	if afterRunHook then
		return afterRunHook
	else
		return self.Response
	end
end

--- Returns an ArgumentContext for the specific index
function Command:GetArgument (index)
	return self.Arguments[index]
end

-- Below are functions that are only meant to be used in command implementations --

--- Returns the extra data associated with this command.
-- This needs to be used instead of just context.Data for reliability when not using a remote command.
function Command:GetData ()
	if self.Data then
		return self.Data
	end

	if self.Object.Data and not IsServer then
		self.Data = self.Object.Data(self)
	end

	return self.Data
end

--- Sends an event message to a player
function Command:SendEvent(player, event, ...)
	assert(typeof(player) == "Instance", "Argument #1 must be a Player")
	assert(player:IsA("Player"), "Argument #1 must be a Player")
	assert(type(event) == "string", "Argument #2 must be a string")

	if IsServer then
		self.Dispatcher.Cmdr.RemoteEvent:FireClient(player, event, ...)
	elseif self.Dispatcher.Cmdr.Events[event] then
		assert(player == Players.LocalPlayer, "Event messages can only be sent to the local player on the client.")
		self.Dispatcher.Cmdr.Events[event](...)
	end
end

--- Sends an event message to all players
function Command:BroadcastEvent(...)
	if not IsServer then
		error("Can't broadcast event messages from the client.", 2)
	end

	self.Dispatcher.Cmdr.RemoteEvent:FireAllClients(...)
end

--- Alias of self:SendEvent(self.Executor, "AddLine", text)
function Command:Reply(...)
	return self:SendEvent(self.Executor, "AddLine", ...)
end

--- Alias of Registry:GetStore(...)
function Command:GetStore(...)
	return self.Dispatcher.Cmdr.Registry:GetStore(...)
end

--- Returns true if the command has an implementation on the caller's machine.
function Command:HasImplementation()
	return ((RunService:IsClient() and self.Object.ClientRun) or self.Object.Run) and true or false
end

return Command
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="383">
                <Properties>
                  <string name="Name">Dispatcher</string>
                  <string name="Source">local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local Util = require(script.Parent.Util)
local Command = require(script.Parent.Command)

local HISTORY_SETTING_NAME = "CmdrCommandHistory"
local displayedBeforeRunHookWarning = false

--- The dispatcher handles creating and running commands during the game.
local Dispatcher = {
	Cmdr = nil;
	Registry = nil;
}

--- Takes in raw command information and generates a command out of it.
-- text and executor are required arguments.
-- allowIncompleteData, when true, will ignore errors about arguments missing so we can parse live as the user types.
-- data is for special networked Data about the command gathered on the client. Purely Optional.
-- returns the command if successful, or (false, errorText) if not
function Dispatcher:Evaluate (text, executor, allowIncompleteArguments, data)
	if RunService:IsClient() == true and executor ~= Players.LocalPlayer then
		error("Can't evaluate a command that isn't sent by the local player.")
	end

	local arguments = Util.SplitString(text)
	local commandName = table.remove(arguments, 1)
	local commandObject = self.Registry:GetCommand(commandName)

	if commandObject then
		-- No need to continue splitting when there are no more arguments. We'll just mash any additional arguments into the last one.
		arguments = Util.MashExcessArguments(arguments, #commandObject.Args)

		-- Create the CommandContext and parse it.
		local command = Command.new({
			Dispatcher = self,
			Text = text,
			CommandObject = commandObject,
			Alias = commandName,
			Executor = executor,
			Arguments = arguments,
			Data = data
		})
		local success, errorText = command:Parse(allowIncompleteArguments)

		if success then
			return command
		else
			return false, errorText
		end
	else
		return false, ("%q is not a valid command name. Use the help command to see all available commands."):format(tostring(commandName))
	end
end

--- A helper that evaluates and runs the command in one go.
-- Either returns any validation errors as a string, or the output of the command as a string. Definitely a string, though.
function Dispatcher:EvaluateAndRun (text, executor, options)
	executor = executor or Players.LocalPlayer
	options = options or {}

	if RunService:IsClient() and options.IsHuman then
		self:PushHistory(text)
	end

	local command, errorText = self:Evaluate(text, executor, nil, options.Data)

	if not command then
		return errorText
	end

	local ok, out = xpcall(function()
		local valid, errorText = command:Validate(true) -- luacheck: ignore

		if not valid then
			return errorText
		end

		return command:Run() or "Command executed."
	end, function(value)
		return debug.traceback(tostring(value))
	end)

	if not ok then
		warn(("Error occurred while evaluating command string %q\n%s"):format(text, tostring(out)))
	end

	return ok and out or "An error occurred while running this command. Check the console for more information."
end

--- Send text as the local user to remote server to be evaluated there.
function Dispatcher:Send (text, data)
	if RunService:IsClient() == false then
		error("Dispatcher:Send can only be called from the client.")
	end

	return self.Cmdr.RemoteFunction:InvokeServer(text, {
		Data = data
	})
end

--- Invoke a command programmatically as the local user e.g. from a settings menu
-- Command should be the first argument, all arguments afterwards should be the arguments to the command.
function Dispatcher:Run (...)
	if not Players.LocalPlayer then
		error("Dispatcher:Run can only be called from the client.")
	end

	local args = {...}
	local text = args[1]

	for i = 2, #args do
		text = text .. " " .. tostring(args[i])
	end

	local command, errorText = self:Evaluate(text, Players.LocalPlayer)

	if not command then
		error(errorText) -- We do a full-on error here since this is code-invoked and they should know better.
	end

	local success, errorText = command:Validate(true) -- luacheck: ignore

	if not success then
		error(errorText)
	end

	return command:Run()
end

--- Runs hooks matching name and returns nil for ok or a string for cancellation
function Dispatcher:RunHooks(hookName, commandContext, ...)
	if not self.Registry.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	if
		hookName == "BeforeRun"
		and #self.Registry.Hooks[hookName] == 0
		and commandContext.Group ~= "DefaultUtil"
		and commandContext.Group ~= "UserAlias"
		and commandContext:HasImplementation()
	then

		if RunService:IsStudio() then
			if displayedBeforeRunHookWarning == false then
				commandContext:Reply((RunService:IsServer() and "&lt;Server&gt;" or "&lt;Client&gt;") .. " Commands will not run in-game if no BeforeRun hook is configured. Learn more: https://eryn.io/Cmdr/guide/Hooks.html", Color3.fromRGB(255,228,26))
				displayedBeforeRunHookWarning = true
			end
		else
			return "Command blocked for security as no BeforeRun hook is configured."
		end
	end

	for _, hook in ipairs(self.Registry.Hooks[hookName]) do
		local value = hook.callback(commandContext, ...)

		if value ~= nil then
			return tostring(value)
		end
	end
end

function Dispatcher:PushHistory(text)
	assert(RunService:IsClient(), "PushHistory may only be used from the client.")

	local history = self:GetHistory()

	-- Remove duplicates
	if Util.TrimString(text) == "" or text == history[#history] then
		return
	end

	history[#history + 1] = text

	TeleportService:SetTeleportSetting(HISTORY_SETTING_NAME, history)
end

function Dispatcher:GetHistory()
	assert(RunService:IsClient(), "GetHistory may only be used from the client.")

	return TeleportService:GetTeleportSetting(HISTORY_SETTING_NAME) or {}
end

return function (cmdr)
	Dispatcher.Cmdr = cmdr
	Dispatcher.Registry = cmdr.Registry

	return Dispatcher
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="384">
                <Properties>
                  <string name="Name">Registry</string>
                  <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Util = require(script.Parent.Util)

--- The registry keeps track of all the commands and types that Cmdr knows about.
local Registry = {
	TypeMethods = Util.MakeDictionary({"Transform", "Validate", "Autocomplete", "Parse", "DisplayName", "Listable", "ValidateOnce", "Prefixes", "Default", "ArgumentOperatorAliases"});
	CommandMethods = Util.MakeDictionary({"Name", "Aliases", "AutoExec", "Description", "Args", "Run", "ClientRun", "Data", "Group"});
	CommandArgProps = Util.MakeDictionary({"Name", "Type", "Description", "Optional", "Default"});
	Types = {};
	TypeAliases = {};
	Commands = {};
	CommandsArray = {};
	Cmdr = nil;
	Hooks = {
		BeforeRun = {};
		AfterRun = {}
	};
	Stores = setmetatable({}, {
		__index = function (self, k)
			self[k] = {}
			return self[k]
		end
	});
	AutoExecBuffer = {};
}

--- Registers a type in the system.
-- name: The type Name. This must be unique.
function Registry:RegisterType (name, typeObject)
	if not name or typeof(name) ~= "string" then
		error("Invalid type name provided: nil")
	end

	if not name:find("^[%d%l]%w*$") then
		error(('Invalid type name provided: "%s", type names must be alphanumeric and start with a lower-case letter or a digit.'):format(name))
	end

	for key in pairs(typeObject) do
		if self.TypeMethods[key] == nil then
			error("Unknown key/method in type \"" .. name .. "\": " .. key)
		end
	end

	if self.Types[name] ~= nil then
		error(('Type "%s" has already been registered.'):format(name))
	end

	typeObject.Name = name
	typeObject.DisplayName = typeObject.DisplayName or name

	self.Types[name] = typeObject

	if typeObject.Prefixes then
		self:RegisterTypePrefix(name, typeObject.Prefixes)
	end
end

function Registry:RegisterTypePrefix (name, union)
	if not self.TypeAliases[name] then
		self.TypeAliases[name] = name
	end

	self.TypeAliases[name] = ("%s %s"):format(self.TypeAliases[name], union)
end

function Registry:RegisterTypeAlias (name, alias)
	assert(self.TypeAliases[name] == nil, ("Type alias %s already exists!"):format(alias))
	self.TypeAliases[name] = alias
end

--- Helper method that registers types from all module scripts in a specific container.
function Registry:RegisterTypesIn (container)
	for _, object in pairs(container:GetChildren()) do
		if object:IsA("ModuleScript") then
			object.Parent = self.Cmdr.ReplicatedRoot.Types

			require(object)(self)
		else
			self:RegisterTypesIn(object)
		end
	end
end

-- These are exactly the same thing. No one will notice. Except for you, dear reader.
Registry.RegisterHooksIn = Registry.RegisterTypesIn

--- Registers a command based purely on its definition.
-- Prefer using Registry:RegisterCommand for proper handling of server/client model.
function Registry:RegisterCommandObject (commandObject, fromCmdr)
	for key in pairs(commandObject) do
		if self.CommandMethods[key] == nil then
			error("Unknown key/method in command " .. (commandObject.Name or "unknown command") .. ": " .. key)
		end
	end

	if commandObject.Args then
		for i, arg in pairs(commandObject.Args) do
			if type(arg) == "table" then
				for key in pairs(arg) do
					if self.CommandArgProps[key] == nil then
						error(('Unknown property in command "%s" argument #%d: %s'):format(commandObject.Name or "unknown", i, key))
					end
				end
			end
		end
	end

	if commandObject.AutoExec and RunService:IsClient() then
		table.insert(self.AutoExecBuffer, commandObject.AutoExec)
		self:FlushAutoExecBufferDeferred()
	end

	-- Unregister the old command if it exists...
	local oldCommand = self.Commands[commandObject.Name:lower()]
	if oldCommand and oldCommand.Aliases then
		for _, alias in pairs(oldCommand.Aliases) do
			self.Commands[alias:lower()] = nil
		end
	elseif not oldCommand then
		table.insert(self.CommandsArray, commandObject)
	end

	self.Commands[commandObject.Name:lower()] = commandObject

	if commandObject.Aliases then
		for _, alias in pairs(commandObject.Aliases) do
			self.Commands[alias:lower()] = commandObject
		end
	end
end

--- Registers a command definition and its server equivalent.
-- Handles replicating the definition to the client.
function Registry:RegisterCommand (commandScript, commandServerScript, filter)
	local commandObject = require(commandScript)
	assert(
		typeof(commandObject) == "table",
		`Invalid return value from command script "{commandScript.Name}" (CommandDefinition expected, got {typeof(commandObject)})`
	)

	if commandServerScript then
		assert(RunService:IsServer(), "The commandServerScript parameter is not valid for client usage.")
		commandObject.Run = require(commandServerScript)
	end

	if filter and not filter(commandObject) then
		return
	end

	self:RegisterCommandObject(commandObject)

	commandScript.Parent = self.Cmdr.ReplicatedRoot.Commands
end

--- A helper method that registers all commands inside a specific container.
function Registry:RegisterCommandsIn (container, filter)
	local skippedServerScripts = {}
	local usedServerScripts = {}

	for _, commandScript in pairs(container:GetChildren()) do
		if commandScript:IsA("ModuleScript") then
			if not commandScript.Name:find("Server") then
				local serverCommandScript = container:FindFirstChild(commandScript.Name .. "Server")

				if serverCommandScript then
					usedServerScripts[serverCommandScript] = true
				end

				self:RegisterCommand(commandScript, serverCommandScript, filter)
			else
				skippedServerScripts[commandScript] = true
			end
		else
			self:RegisterCommandsIn(commandScript, filter)
		end
	end

	for skippedScript in pairs(skippedServerScripts) do
		if not usedServerScripts[skippedScript] then
			warn("Command script " .. skippedScript.Name .. " was skipped because it has 'Server' in its name, and has no equivalent shared script.")
		end
	end
end

--- Registers the default commands, with an optional filter function or array of groups.
function Registry:RegisterDefaultCommands (arrayOrFunc)
	assert(RunService:IsServer(), "RegisterDefaultCommands cannot be called from the client.")

	local isArray = type(arrayOrFunc) == "table"

	if isArray then
		arrayOrFunc = Util.MakeDictionary(arrayOrFunc)
	end

	self:RegisterCommandsIn(self.Cmdr.DefaultCommandsFolder, isArray and function (command)
		return arrayOrFunc[command.Group] or false
	end or arrayOrFunc)
end

--- Gets a command definition by name. (Can be an alias)
function Registry:GetCommand (name)
	name = name or ""
	return self.Commands[name:lower()]
end

--- Returns a unique array of all registered commands (not including aliases)
function Registry:GetCommands ()
	return self.CommandsArray
end

--- Returns an array of the names of all registered commands (not including aliases)
function Registry:GetCommandNames ()
	local commands = {}

	for _, command in pairs(self.CommandsArray) do
		table.insert(commands, command.Name)
	end

	return commands
end

Registry.GetCommandsAsStrings = Registry.GetCommandNames

--- Returns an array of the names of all registered types (not including aliases)
function Registry:GetTypeNames ()
	local typeNames = {}

	for typeName in pairs(self.Types) do
		table.insert(typeNames, typeName)
	end

	return typeNames
end


--- Gets a type definition by name.
function Registry:GetType (name)
	return self.Types[name]
end

--- Returns a type name, parsing aliases.
function Registry:GetTypeName (name)
	return self.TypeAliases[name] or name
end

--- Adds a hook to be called when any command is run
function Registry:RegisterHook(hookName, callback, priority)
	if not self.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	table.insert(self.Hooks[hookName], { callback = callback; priority = priority or 0; } )
	table.sort(self.Hooks[hookName], function(a, b) return a.priority < b.priority end)
end

-- Backwards compatability (deprecated)
Registry.AddHook = Registry.RegisterHook

--- Returns the store with the given name
-- Used for commands that require persistent state, like bind or ban
function Registry:GetStore(name)
	return self.Stores[name]
end

--- Calls self:FlushAutoExecBuffer at the end of the frame
function Registry:FlushAutoExecBufferDeferred()
	if self.AutoExecFlushConnection then
		return
	end

	self.AutoExecFlushConnection = RunService.Heartbeat:Connect(function()
		self.AutoExecFlushConnection:Disconnect()
		self.AutoExecFlushConnection = nil
		self:FlushAutoExecBuffer()
	end)
end

--- Runs all pending auto exec commands in Registry.AutoExecBuffer
function Registry:FlushAutoExecBuffer()
	for _, commandGroup in ipairs(self.AutoExecBuffer) do
		for _, command in ipairs(commandGroup) do
			self.Cmdr.Dispatcher:EvaluateAndRun(command)
		end
	end

	self.AutoExecBuffer = {}
end

return function (cmdr)
	Registry.Cmdr = cmdr

	return Registry
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="385">
                <Properties>
                  <string name="Name">Util</string>
                  <string name="Source"><![CDATA[local TextService = game:GetService("TextService")

local Util = {}

--- Takes an array and flips its values into dictionary keys with value of true.
function Util.MakeDictionary(array)
	local dictionary = {}

	for i = 1, #array do
		dictionary[array[i]] = true
	end

	return dictionary
end

--- Takes a dictionary and returns its keys.
function Util.DictionaryKeys(dict)
	local keys = {}

	for key in pairs(dict) do
		table.insert(keys, key)
	end

	return keys
end

-- Takes an array of instances and returns (array<names>, array<instances>)
local function transformInstanceSet(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name
	end

	return names, instances
end

--- Returns a function that is a fuzzy finder for the specified set or container.
-- Can pass an array of strings, array of instances, array of EnumItems,
-- array of dictionaries with a Name key or an instance (in which case its children will be used)
-- Exact matches will be inserted in the front of the resulting array
function Util.MakeFuzzyFinder(setOrContainer)
	local names
	local instances = {}

	if typeof(setOrContainer) == "Enum" then
		setOrContainer = setOrContainer:GetEnumItems()
	end

	if typeof(setOrContainer) == "Instance" then
		names, instances = transformInstanceSet(setOrContainer:GetChildren())
	elseif typeof(setOrContainer) == "table" then
		if
			typeof(setOrContainer[1]) == "Instance" or typeof(setOrContainer[1]) == "EnumItem" or
				(typeof(setOrContainer[1]) == "table" and typeof(setOrContainer[1].Name) == "string")
		 then
			names, instances = transformInstanceSet(setOrContainer)
		elseif type(setOrContainer[1]) == "string" then
			names = setOrContainer
		elseif setOrContainer[1] ~= nil then
			error("MakeFuzzyFinder only accepts tables of instances or strings.")
		else
			names = {}
		end
	else
		error("MakeFuzzyFinder only accepts a table, Enum, or Instance.")
	end

	-- Searches the set (checking exact matches first)
	return function(text, returnFirst)
		local results = {}

		for i, name in pairs(names) do
			local value = instances and instances[i] or name

			-- Continue on checking for non-exact matches...
			-- Still need to loop through everything, even on returnFirst, because possibility of an exact match.
			if name:lower() == text:lower() then
				if returnFirst then
					return value
				else
					table.insert(results, 1, value)
				end
			elseif name:lower():find(text:lower(), 1, true) then
				results[#results + 1] = value
			end
		end

		if returnFirst then
			return results[1]
		end

		return results
	end
end

--- Takes an array of instances and returns an array of those instances' names.
function Util.GetNames(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name or tostring(instances[i])
	end

	return names
end

--- Splits a string using a simple separator (no quote parsing)
function Util.SplitStringSimple(inputstr, sep)
	if sep == nil then
		sep = "%s"
	end
	local t = {}
	local i = 1
	for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
		t[i] = str
		i = i + 1
	end
	return t
end

local function charCode(n)
	return utf8.char(tonumber(n, 16))
end

--- Parses escape sequences into their fully qualified characters
function Util.ParseEscapeSequences(text)
	return text:gsub("\\(.)", {
		t = "\t";
		n = "\n";
	})
	:gsub("\\u(%x%x%x%x)", charCode)
	:gsub("\\x(%x%x)", charCode)
end

function Util.EncodeEscapedOperator(text, op)
	local first = op:sub(1, 1)
	local escapedOp = op:gsub(".", "%%%1")
	local escapedFirst = "%" .. first

	return text:gsub("(" .. escapedFirst .. "+)(" .. escapedOp .. ")", function(esc, op)
			return (esc:sub(1, #esc-1) .. op):gsub(".", function(char)
					return "\\u" .. string.format("%04x", string.byte(char), 16)
			end)
	end)
end

local OPERATORS = {"&&", "||", ";"}
function Util.EncodeEscapedOperators(text)
	for _, operator in ipairs(OPERATORS) do
		text = Util.EncodeEscapedOperator(text, operator)
	end

	return text
end

local function encodeControlChars(text)
	return (
		text
		:gsub("\\\\", "___!CMDR_ESCAPE!___")
		:gsub("\\\"", "___!CMDR_QUOTE!___")
		:gsub("\\'", "___!CMDR_SQUOTE!___")
		:gsub("\\\n", "___!CMDR_NL!___")
	)
end

local function decodeControlChars(text)
	return (
		text
		:gsub("___!CMDR_ESCAPE!___", "\\")
		:gsub("___!CMDR_QUOTE!___", "\"")
		:gsub("___!CMDR_NL!___", "\n")
	)
end

--- Splits a string by space but taking into account quoted sequences which will be treated as a single argument.
function Util.SplitString(text, max)
	text = encodeControlChars(text)
	max = max or math.huge
	local t = {}
	local spat, epat = [=[^(['"])]=], [=[(['"])$]=]
	local buf, quoted
	for str in text:gmatch("[^ ]+") do
		str = Util.ParseEscapeSequences(str)
		local squoted = str:match(spat)
		local equoted = str:match(epat)
		local escaped = str:match([=[(\*)['"]$]=])
		if squoted and not quoted and not equoted then
			buf, quoted = str, squoted
		elseif buf and equoted == quoted and #escaped % 2 == 0 then
			str, buf, quoted = buf .. " " .. str, nil, nil
		elseif buf then
			buf = buf .. " " .. str
		end
		if not buf then
			t[#t + (#t > max and 0 or 1)] = decodeControlChars(str:gsub(spat, ""):gsub(epat, ""))
		end
	end

	if buf then
		t[#t + (#t > max and 0 or 1)] = decodeControlChars(buf)
	end

	return t
end

--- Takes an array of arguments and a max value.
-- Any indicies past the max value will be appended to the last valid argument.
function Util.MashExcessArguments(arguments, max)
	local t = {}
	for i = 1, #arguments do
		if i > max then
			t[max] = ("%s %s"):format(t[max] or "", arguments[i])
		else
			t[i] = arguments[i]
		end
	end
	return t
end

--- Trims whitespace from both sides of a string.
function Util.TrimString(str)
	local _, from = string.find(str, "^%s*")
	-- trim the string in two steps to prevent quadratic backtracking when no "%S" match is found
	return from == #str and "" or string.match(str, ".*%S", from + 1)
end

--- Returns the text bounds size based on given text, label (from which properties will be pulled), and optional Vector2 container size.
function Util.GetTextSize(text, label, size)
	return TextService:GetTextSize(text, label.TextSize, label.Font, size or Vector2.new(label.AbsoluteSize.X, 0))
end

--- Makes an Enum type.
function Util.MakeEnumType(name, values)
	local findValue = Util.MakeFuzzyFinder(values)
	return {
		Validate = function(text)
			return findValue(text, true) ~= nil, ("Value %q is not a valid %s."):format(text, name)
		end,
		Autocomplete = function(text)
			local list = findValue(text)
			return type(list[1]) ~= "string" and Util.GetNames(list) or list
		end,
		Parse = function(text)
			return findValue(text, true)
		end
	}
end

--- Parses a prefixed union type argument (such as %Team)
function Util.ParsePrefixedUnionType(typeValue, rawValue)
	local split = Util.SplitStringSimple(typeValue)

	-- Check prefixes in order from longest to shortest
	local types = {}
	for i = 1, #split, 2 do
		types[#types + 1] = {
			prefix = split[i - 1] or "",
			type = split[i]
		}
	end

	table.sort(
		types,
		function(a, b)
			return #a.prefix > #b.prefix
		end
	)

	for i = 1, #types do
		local t = types[i]

		if rawValue:sub(1, #t.prefix) == t.prefix then
			return t.type, rawValue:sub(#t.prefix + 1), t.prefix
		end
	end
end

--- Creates a listable type from a singlular type
function Util.MakeListableType(type, override)
	local listableType = {
		Listable = true,
		Transform = type.Transform,
		Validate = type.Validate,
		ValidateOnce = type.ValidateOnce,
		Autocomplete = type.Autocomplete,
		Default = type.Default,
		ArgumentOperatorAliases = type.ArgumentOperatorAliases,
		Parse = function(...)
			return {type.Parse(...)}
		end
	}

	if override then
		for key, value in pairs(override) do
			listableType[key] = value
		end
	end

	return listableType
end

local function encodeCommandEscape(text)
	return (text:gsub("\\%$", "___!CMDR_DOLLAR!___"))
end

local function decodeCommandEscape(text)
	return (text:gsub("___!CMDR_DOLLAR!___", "$"))
end

function Util.RunCommandString(dispatcher, commandString)
	commandString = Util.ParseEscapeSequences(commandString)
	commandString = Util.EncodeEscapedOperators(commandString)

	local commands = commandString:split("&&")

	local output = ""
	for i, command in ipairs(commands) do
		local outputEncoded = output:gsub("%$", "\\x24"):gsub("%%","%%%%")
		command = command:gsub("||", output:find("%s") and ("%q"):format(outputEncoded) or outputEncoded)

		output = tostring(
			dispatcher:EvaluateAndRun(
				(
					Util.RunEmbeddedCommands(dispatcher, command)
				)
			)
		)


		if i == #commands then
			return output
		end
	end
end

--- Runs embedded commands and replaces them
function Util.RunEmbeddedCommands(dispatcher, str)
	str = encodeCommandEscape(str)

	local results = {}
	-- We need to do this because you can't yield in the gsub function
	for text in str:gmatch("$(%b{})") do
		local doQuotes = true
		local commandString = text:sub(2, #text-1)

		if commandString:match("^{.+}$") then -- Allow double curly for literal replacement
			doQuotes = false
			commandString = commandString:sub(2, #commandString-1)
		end

		results[text] = Util.RunCommandString(dispatcher, commandString)

		if doQuotes then
			if results[text]:find("%s") or results[text] == "" then
				results[text] = string.format("%q", results[text])
			end
		end
	end

	return decodeCommandEscape(str:gsub("$(%b{})", results))
end

--- Replaces arguments in the format $1, $2, $something with whatever the
-- given function returns for it.
function Util.SubstituteArgs(str, replace)
	str = encodeCommandEscape(str)
	-- Convert numerical keys to strings
	if type(replace) == "table" then
		for i = 1, #replace do
			local k = tostring(i)
			replace[k] = replace[i]

			if replace[k]:find("%s") then
				replace[k] = string.format("%q", replace[k])
			end
		end
	end
	return decodeCommandEscape(str:gsub("($%d+)%b{}", "%1"):gsub("$(%w+)", replace))
end

--- Creates an alias command
function Util.MakeAliasCommand(name, commandString)
	local commandName, commandDescription = unpack(name:split("|"))
	local args = {}

	commandString = Util.EncodeEscapedOperators(commandString)

	local seenArgs = {}

	for arg in commandString:gmatch("$(%d+)") do
		if seenArgs[arg] == nil then
			seenArgs[arg] = true
			local options = commandString:match(`${arg}(%b\{})`)

			local argOptional, argType, argName, argDescription
			if options then
				options = options:sub(2, #options - 1) -- remove braces
				argType, argName, argDescription = unpack(options:split("|"))
			end

			argOptional = argType and not not argType:match("%?$")
			argType = if argType then argType:match("^%w+") else "string"
			argName = argName or `Argument {arg}`
			argDescription = argDescription or ""

			table.insert(args, {
				Type = argType,
				Name = argName,
				Description = argDescription,
				Optional = argOptional,
			})
		end
	end

	return {
		Name = commandName,
		Aliases = {},
		Description = `<Alias> {commandDescription or commandString}`,
		Group = "UserAlias",
		Args = args,
		Run = function(context)
			return Util.RunCommandString(context.Dispatcher, Util.SubstituteArgs(commandString, context.RawArguments))
		end,
	}
end

--- Makes a type that contains a sequence, e.g. Vector3 or Color3
function Util.MakeSequenceType(options)
	options = options or {}

	assert(options.Parse ~= nil or options.Constructor ~= nil, "MakeSequenceType: Must provide one of: Constructor, Parse")

	options.TransformEach = options.TransformEach or function(...)
		return ...
	end

	options.ValidateEach = options.ValidateEach or function()
		return true
	end

	return {
		Prefixes = options.Prefixes;

		Transform = function (text)
			return Util.Map(Util.SplitPrioritizedDelimeter(text, {",", "%s"}), function(value)
				return options.TransformEach(value)
			end)
		end;

		Validate = function (components)
			if options.Length and #components > options.Length then
				return false, ("Maximum of %d values allowed in sequence"):format(options.Length)
			end

			for i = 1, options.Length or #components do
				local valid, reason = options.ValidateEach(components[i], i)

				if not valid then
					return false, reason
				end
			end

			return true
		end;

		Parse = options.Parse or function(components)
			return options.Constructor(unpack(components))
		end
	}
end

--- Splits a string by a single delimeter chosen from the given set.
-- The first matching delimeter from the set becomes the split character.
function Util.SplitPrioritizedDelimeter(text, delimeters)
	for i, delimeter in ipairs(delimeters) do
		if text:find(delimeter) or i == #delimeters then
			return Util.SplitStringSimple(text, delimeter)
		end
	end
end

--- Maps values of an array through a callback and returns an array of mapped values
function Util.Map(array, callback)
	local results = {}

	for i, v in ipairs(array) do
		results[i] = callback(v, i)
	end

	return results
end

--- Maps arguments #2-n through callback and returns values as tuple
function Util.Each(callback, ...)
	local results = {}
	for i, value in ipairs({...}) do
		results[i] = callback(value)
	end
	return unpack(results)
end

--- Emulates tabstops with spaces
function Util.EmulateTabstops(text, tabWidth)
	local column = 0
	local textLength = #text
	local result = table.create(textLength)
	for i = 1, textLength do
		local char = string.sub(text, i, i)
		if char == "\t" then
			local spaces = tabWidth - column % tabWidth
			table.insert(result, string.rep(" ", spaces))
			column += spaces
		else
			table.insert(result, char)
			if char == "\n" then
				column = 0 -- Reset column counter on newlines
			elseif char ~= "\r" then
				column += 1
			end
		end
	end
	return table.concat(result)
end

function Util.Mutex()
	local queue = {}
	local locked = false

	return function ()
		if locked then
			table.insert(queue, coroutine.running())
			coroutine.yield()
		else
			locked = true
		end

		return function()
			if #queue > 0 then
				coroutine.resume(table.remove(queue, 1))
			else
				locked = false
			end
		end
	end
end

return Util
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="386">
      <Properties>
        <string name="Name">GameScripts</string>
      </Properties>
      <Item class="Script" referent="387">
        <Properties>
          <string name="Name">ServerMain</string>
          <token name="RunContext">0</token>
          <string name="Source">--[[
	@class ServerMain
]]
local ServerScriptService = game:GetService("ServerScriptService")

local loader = ServerScriptService.Game:FindFirstChild("LoaderUtils", true).Parent
local require = require(loader).bootstrapGame(ServerScriptService.Game)

local serviceBag = require("ServiceBag").new()
serviceBag:GetService(require("GameService"))
serviceBag:Init()
serviceBag:Start()</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="388">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="389">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="390">
        <Properties>
          <string name="Name">GameScripts</string>
        </Properties>
        <Item class="LocalScript" referent="391">
          <Properties>
            <string name="Name">ClientMain</string>
            <string name="Source">--[[
	@class ClientMain
]]
local loader = game:GetService("ReplicatedStorage"):WaitForChild("Game"):WaitForChild("loader")
local require = require(loader).bootstrapGame(loader.Parent)

local serviceBag = require("ServiceBag").new()
serviceBag:GetService(require("GameServiceClient"))
serviceBag:Init()
serviceBag:Start()</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>